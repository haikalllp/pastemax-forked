<file_map>
/Users/haikalp/Documents/Code/Projects/pastemax-forked
├── .cursor
│   └── rules
│       ├── current-stack.mdc
│       └── reserve.mdc
├── .github
│   ├── workflows
│   │   ├── build.yml
│   │   ├── debug-build.yml
│   │   └── release.yml
│   └── README.actions.md
├── docs
│   ├── feature
│   │   ├── 1.2.0-1.3.0
│   │   │   ├── fixes.md
│   │   │   ├── KnownIssue.md
│   │   │   └── update.md
│   │   ├── ignoreBinariesUI
│   │   │   ├── ignoreBinariesTODOS.md
│   │   │   └── prompt(IgnoreBinaries).txt
│   │   └── multi-root
│   │       ├── multipleRootPlan.md
│   │       ├── multipleRootPrompt.md
│   │       └── testCase.md
│   ├── design.md
│   ├── excluded-files.md
│   ├── mainOLD.js
│   ├── tiktoken.md
│   └── ux-rubric.md
├── OldImplementation
│   ├── src
│   │   ├── components
│   │   │   ├── CopyButton.tsx
│   │   │   ├── FileCard.tsx
│   │   │   ├── FileList.tsx
│   │   │   ├── SearchBar.tsx
│   │   │   ├── Sidebar.tsx
│   │   │   ├── ThemeToggle.tsx
│   │   │   ├── TreeItem.tsx
│   │   │   └── UserInstructions.tsx
│   │   ├── styles
│   │   │   └── index.css
│   │   ├── types
│   │   │   └── FileTypes.ts
│   │   ├── utils
│   │   │   ├── pathUtils.ts
│   │   │   └── README.md
│   │   └── App.tsx
│   ├── main.js
│   ├── preload.js
│   └── renderer.js
├── public
│   ├── favicon.icns
│   ├── favicon.ico
│   ├── favicon.png
│   └── favicon.svg
├── scripts
│   ├── fix-dependencies.js
│   ├── notarize.js
│   ├── README.md
│   ├── test-excluded-files.js
│   ├── test-gitignore-crossplatform.js
│   ├── test-gitignore.js
│   ├── test-local-build.js
│   ├── test-path-utils.js
│   └── verify-build.js
├── shared
│   ├── path-utils.d.ts
│   ├── path-utils.js
│   └── README.md
├── src
│   ├── assets
│   │   └── favicon.svg
│   ├── components
│   │   ├── CopyButton.tsx
│   │   ├── FileCard.tsx
│   │   ├── FileList.tsx
│   │   ├── SearchBar.tsx
│   │   ├── Sidebar.tsx
│   │   ├── ThemeToggle.tsx
│   │   ├── TreeItem.tsx
│   │   └── UserInstructions.tsx
│   ├── context
│   │   └── ThemeContext.tsx
│   ├── styles
│   │   └── index.css
│   ├── types
│   │   └── FileTypes.ts
│   ├── utils
│   │   ├── pathUtils.ts
│   │   └── README.md
│   ├── App.tsx
│   ├── declarations.d.ts
│   ├── index.html
│   ├── main.tsx
│   └── react-app-env.d.ts
├── .cursor-tasks.md
├── .eslintrc.cjs
├── build.js
├── CHANGELOG.md
├── CONTRIBUTING.md
├── dev.js
├── docker-compose.yml
├── Dockerfile
├── excluded-files.js
├── index.html
├── LICENSE
├── main.js
├── package.json
├── preload.js
├── README.docker.md
├── README.md
├── RELEASE.md
├── renderer.js
├── repoPromptCompose.xml
├── tsconfig.json
├── tsconfig.node.json
└── vite.config.ts

</file_map>

<file_contents>
File: /Users/haikalp/Documents/Code/Projects/pastemax-forked/src/components/SearchBar.tsx
```tsx
import React, { useState } from "react";
import { Search, X } from "lucide-react";

interface SearchBarProps {
  searchTerm: string;
  onSearchChange: (term: string) => void;
  placeholder?: string;
}

const SearchBar = ({
  searchTerm,
  onSearchChange,
  placeholder = "Search...",
}: SearchBarProps) => {
  const [isFocused, setIsFocused] = useState(false);

  return (
    <div className={`search-bar ${isFocused ? "focused" : ""}`}>
      <div className="search-icon">
        <Search size={16} />
      </div>
      <input
        type="text"
        className="search-input"
        placeholder={placeholder}
        value={searchTerm}
        onChange={(e) => onSearchChange(e.target.value)}
        onFocus={() => setIsFocused(true)}
        onBlur={() => setIsFocused(false)}
      />
      {searchTerm && (
        <button
          className="search-clear-btn"
          onClick={() => onSearchChange("")}
          aria-label="Clear search"
        >
          <X size={14} />
        </button>
      )}
    </div>
  );
};

export default SearchBar;

```

File: /Users/haikalp/Documents/Code/Projects/pastemax-forked/src/components/TreeItem.tsx
```tsx
import React, {
  useRef,
  useEffect,
  memo
} from "react";
import type { MouseEventHandler, ChangeEventHandler } from "react";
import { TreeItemProps, TreeNode, FileData, RootFolder, isDirectoryNode, NodeType } from "../types/FileTypes";
import { ChevronRight, File, Folder, FolderOpen, X, Trash } from "lucide-react";
import * as pathUtils from "../utils/pathUtils";

// Ensure we have the critical path utilities, with fallbacks if needed
const {
  normalizePath = (path: string): string => path?.replace(/\\/g, '/') || path,
  arePathsEqual = (path1: string, path2: string): boolean => {
    if (!path1 && !path2) return true;
    if (!path1 || !path2) return false;
    return normalizePath(path1).toLowerCase() === normalizePath(path2).toLowerCase();
  },
  isSubPath = (parent: string, child: string): boolean => {
    if (!parent || !child) return false;
    const normalizedParent = normalizePath(parent).replace(/\/+$/, '') + '/';
    const normalizedChild = normalizePath(child);
    return normalizedChild.toLowerCase().startsWith(normalizedParent.toLowerCase());
  }
} = pathUtils;

/**
 * TreeItem represents a single item (file or folder) in the file tree.
 * It handles:
 * - File/folder selection with checkboxes
 * - Folder expansion/collapse
 * - Visual indicators for selection state
 * - Special cases for binary/skipped/excluded files
 */
const TreeItem = ({
  node,
  selectedFiles,
  toggleFileSelection,
  toggleFolderSelection,
  toggleExpanded,
  allFiles,
  isRootNode = false,
  removeRootFolder
}: TreeItemProps) => {
  const { id, name, path, type, level = 0, isExpanded, fileData, rootId } = node;
  const checkboxRef = useRef<HTMLInputElement>(null);

  const isSelected = type === "file" && selectedFiles.some((selectedFile) => 
    arePathsEqual(selectedFile.path, path)
  );

  // Update the indeterminate state manually whenever it changes
  useEffect(() => {
    if (checkboxRef.current && fileData) {
      const isPartiallySelected = isDirectoryPartiallySelected(fileData, selectedFiles.map(f => f.path), allFiles);
      if (checkboxRef.current.indeterminate !== isPartiallySelected) {
        checkboxRef.current.indeterminate = isPartiallySelected;
      }
    }
  }, [fileData, selectedFiles, allFiles]);

  const handleToggle: MouseEventHandler<HTMLDivElement> = (event) => {
    event.stopPropagation();
    toggleExpanded(node);
  };

  const handleItemClick: MouseEventHandler<HTMLDivElement> = (event) => {
    if (isDirectoryNode(node)) {
      toggleExpanded(node);
    } else if (type === "file" && !isDisabled && fileData) {
      toggleFileSelection(fileData);
    }
  };

  const handleCheckboxChange: ChangeEventHandler<HTMLInputElement> = (event) => {
    event.stopPropagation();
    if (type === "file" && fileData) {
      toggleFileSelection(fileData);
    } else if (isDirectoryNode(node) && fileData) {
      const rootFolder: RootFolder = {
        id: rootId || '',
        path: fileData.path,
        name: fileData.name,
        isExpanded: isExpanded || false
      };
      toggleFolderSelection(rootFolder);
    }
  };

  // Check if file is binary or otherwise unselectable
  const isDisabled = fileData ? fileData.isBinary || fileData.isSkipped : false;
  const isBinary = fileData?.isBinary || false;
  const isSkipped = fileData?.isSkipped || false;
  const isExcludedByDefault = fileData?.excludedByDefault || false;

  // Check if this is a directory containing binary files (used for styling)
  const hasBinaryFiles = isDirectoryNode(node) && allFiles && 
    allFiles.some(file => 
      file.path && 
      !file.isDirectory && 
      file.isBinary && 
      pathUtils.isSubPath(path, file.path)
    );

  // Add additional class for top-level directories (level 0)
  const isTopLevelDirectory = (type === "folder" || type === "root") && level === 0;
  
  // Handle removing a root folder
  const handleRemoveRoot: MouseEventHandler<HTMLButtonElement> = (event) => {
    event.stopPropagation();
    if (removeRootFolder && rootId) {
      removeRootFolder(rootId);
    }
  };
  
  return (
    <div
      className={`tree-item ${type === "file" ? "file-item" : "directory-item"} ${
        isSelected ? "selected" : ""
      } ${isDisabled ? "disabled" : ""} ${isBinary ? "binary" : ""} ${
        isSkipped ? "skipped" : ""
      } ${isExcludedByDefault ? "excluded" : ""} ${
        hasBinaryFiles ? "has-binary" : ""
      } ${isTopLevelDirectory ? "top-level-directory" : ""}`}
      onClick={handleItemClick}
      style={{
        paddingLeft: `${(level) * 16}px`,
      }}
    >
      {(type === "folder" || type === "root") && (
        <div className="tree-item-toggle" onClick={handleToggle}>
          <ChevronRight
            className={`tree-item-chevron ${isExpanded ? "expanded" : ""}`}
            size={18}
          />
        </div>
      )}

      <label
        className={`tree-item-label ${isDisabled ? "disabled" : ""}`}
        onClick={(e) => e.stopPropagation()}
      >
        <input
          ref={checkboxRef}
          type="checkbox"
          className="tree-item-checkbox"
          checked={isSelected}
          onChange={handleCheckboxChange}
          disabled={isDisabled}
        />
      </label>

      <div className="tree-item-icon">
        {type === "file" ? (
          <File size={18} />
        ) : (
          isExpanded ? <FolderOpen size={18} /> : <Folder size={18} />
        )}
      </div>

      <div className="tree-item-content">
        <span className="tree-item-name">{name}</span>
        {isTopLevelDirectory && rootId && (
          <span className="tree-item-path">{path}</span>
        )}
      </div>

      {isBinary && <span className="tree-item-badge binary">Binary</span>}
      {isSkipped && <span className="tree-item-badge skipped">Skipped</span>}
      {isExcludedByDefault && (
        <span className="tree-item-badge excluded">Excluded</span>
      )}
      
      {isTopLevelDirectory && rootId && removeRootFolder && (
        <button 
          className="tree-item-remove-btn" 
          onClick={handleRemoveRoot}
          title="Remove this root folder"
        >
          <Trash size={16} />
        </button>
      )}
    </div>
  );
};

// These helper functions are moved outside the component to prevent recreation on each render

// Returns whether all files in this directory are selected
const isDirectorySelected = (item: FileData, selectedFiles: string[], allFiles: FileData[]): boolean => {
  // If no files are selected, return false
  if (selectedFiles.length === 0) {
    return false;
  }

  // For all folders, get all files in this folder and subfolders
  const allSelectableFiles = getAllFilesInFolder(item, allFiles);
  
  // If there are no selectable files, it can't be selected
  if (allSelectableFiles.length === 0) {
    return false;
  }
  
  // Check if all eligible files are selected
  return allSelectableFiles.every(file => selectedFiles.includes(file.path));
};

// Returns all files (not directories) in this folder and subfolders that are selectable
const getAllFilesInFolder = (item: FileData, allFiles: FileData[]): FileData[] => {
  if (!item || !item.path) {
    return [];
  }
  
  const itemPath = normalizePath(item.path);
  
  return allFiles.filter(file => {
    // Skip directories, binary files, etc.
    if (!file || !file.path || file.isDirectory || file.isBinary || file.isSkipped || file.excludedByDefault) {
      return false;
    }
    
    const filePath = normalizePath(file.path);
    
    // Check if this file is in the folder or its subfolders
    return arePathsEqual(filePath, itemPath) || isSubPath(itemPath, filePath);
  });
};

// Returns whether some but not all files in this directory are selected
const isDirectoryPartiallySelected = (item: FileData, selectedFiles: string[], allFiles: FileData[]): boolean => {
  // If no files are selected, return false
  if (selectedFiles.length === 0) {
    return false;
  }
  
  // For all folders, get all files in this folder and subfolders
  const allSelectableFiles = getAllFilesInFolder(item, allFiles);
  
  // If no selectable files, it can't be partially selected
  if (allSelectableFiles.length === 0) {
    return false;
  }
  
  // Check if any of the files are selected but not all of them
  const someSelected = allSelectableFiles.some(file => selectedFiles.includes(file.path));
  const allSelected = allSelectableFiles.every(file => selectedFiles.includes(file.path));
  
  return someSelected && !allSelected;
};

// Memo the component to prevent unnecessary re-renders
export default memo(TreeItem); 
```

File: /Users/haikalp/Documents/Code/Projects/pastemax-forked/OldImplementation/src/components/FileList.tsx
```tsx
import React from "react";
import { FileListProps, FileData } from "../types/FileTypes";
import FileCard from "./FileCard";
import * as pathUtils from "../utils/pathUtils";

// Ensure we have the critical path utilities, with fallbacks if needed
const {
  arePathsEqual = (path1: string, path2: string): boolean => {
    if (!path1 && !path2) return true;
    if (!path1 || !path2) return false;
    return path1.replace(/\\/g, '/').toLowerCase() === path2.replace(/\\/g, '/').toLowerCase();
  }
} = pathUtils;

const FileList = ({
  files,
  selectedFiles,
  toggleFileSelection,
}: FileListProps) => {
  // Only show files that are in the selectedFiles array and not binary/skipped/excluded/directories
  const displayableFiles = files.filter(
    (file: FileData) =>
      selectedFiles.some(selectedPath => arePathsEqual(selectedPath, file.path)) && 
      !file.isBinary && 
      !file.isSkipped &&
      !file.excludedByDefault &&
      !file.isDirectory
  );

  return (
    <div className="file-list-container">
      {displayableFiles.length > 0 ? (
        <div className="file-list">
          {displayableFiles.map((file: FileData) => (
            <FileCard
              key={file.path}
              file={file}
              isSelected={true} // All displayed files are selected
              toggleSelection={toggleFileSelection}
            />
          ))}
        </div>
      ) : (
        <div className="file-list-empty">
          {files.length > 0
            ? "No files selected. Select files from the sidebar."
            : "Select a folder to view files"}
        </div>
      )}
    </div>
  );
};

export default FileList;

```

File: /Users/haikalp/Documents/Code/Projects/pastemax-forked/OldImplementation/src/components/FileCard.tsx
```tsx
import React from "react";
import { FileCardProps } from "../types/FileTypes";
import { Plus, X, FileText } from "lucide-react";
import CopyButton from "./CopyButton";

interface FileCardComponentProps {
  file: {
    name: string;
    path: string;
    tokenCount: number;
    content: string;
  };
  isSelected: boolean;
  toggleSelection: (path: string) => void;
}

const FileCard = ({
  file,
  isSelected,
  toggleSelection,
}: FileCardComponentProps) => {
  const { name, path: filePath, tokenCount } = file;

  // Format token count for display
  const formattedTokens = tokenCount.toLocaleString();

  return (
    <div className={`file-card ${isSelected ? "selected" : ""}`}>
      <div className="file-card-header">
        <div className="file-card-icon">
          <FileText size={16} />
        </div>
        <div className="file-card-name monospace">{name}</div>
      </div>
      <div className="file-card-info">
        <div className="file-card-tokens">~{formattedTokens} tokens</div>
      </div>

      <div className="file-card-actions">
        <button
          className="file-card-action"
          onClick={() => toggleSelection(filePath)}
          title={isSelected ? "Remove from selection" : "Add to selection"}
        >
          {isSelected ? <X size={16} /> : <Plus size={16} />}
        </button>
        <CopyButton text={file.content} className="file-card-action">
          {""}
        </CopyButton>
      </div>
    </div>
  );
};

export default FileCard;

```

File: /Users/haikalp/Documents/Code/Projects/pastemax-forked/OldImplementation/src/types/FileTypes.ts
```ts
export interface FileData {
  name: string;
  path: string;
  content: string;
  tokenCount: number;
  size: number;
  isBinary: boolean;
  isSkipped: boolean;
  error?: string;
  fileType?: string;
  excludedByDefault?: boolean;
  isDirectory?: boolean;
}

export interface TreeNode {
  id: string;
  name: string;
  path: string;
  type: "file" | "directory";
  children?: TreeNode[];
  isExpanded?: boolean;
  level: number;
  fileData?: FileData;
}

export interface SidebarProps {
  selectedFolder: string | null;
  openFolder: () => void;
  allFiles: FileData[];
  selectedFiles: string[];
  toggleFileSelection: (filePath: string) => void;
  toggleFolderSelection: (folderPath: string, isSelected: boolean) => void;
  searchTerm: string;
  onSearchChange: (term: string) => void;
  selectAllFiles: () => void;
  deselectAllFiles: () => void;
  expandedNodes: Record<string, boolean>;
  toggleExpanded: (nodeId: string) => void;
  processingStatus?: {
    status: "idle" | "processing" | "complete" | "error" | "cancelled";
    message: string;
  };
}

export interface FileListProps {
  files: FileData[];
  selectedFiles: string[];
  toggleFileSelection: (filePath: string) => void;
}

export interface FileCardProps {
  file: FileData;
  isSelected: boolean;
  toggleSelection: (filePath: string) => void;
}

export interface TreeItemProps {
  node: TreeNode;
  selectedFiles: string[];
  toggleFileSelection: (filePath: string) => void;
  toggleFolderSelection: (folderPath: string, isSelected: boolean) => void;
  toggleExpanded: (nodeId: string) => void;
  allFiles: FileData[];
}

export interface SortOption {
  value: string;
  label: string;
}

export interface SearchBarProps {
  searchTerm: string;
  onSearchChange: (term: string) => void;
}

export interface CopyButtonProps {
  onCopy: () => void;
  isDisabled: boolean;
  copyStatus: boolean;
}

```

File: /Users/haikalp/Documents/Code/Projects/pastemax-forked/src/components/CopyButton.tsx
```tsx
import React, { useState } from "react";
import { Copy, Check } from "lucide-react";

interface CopyButtonProps {
  text: string;
  className?: string;
  children?: JSX.Element | string;
}

const CopyButton = ({ text, className = "", children }: CopyButtonProps) => {
  const [copied, setCopied] = useState(false);

  const handleCopy = async () => {
    try {
      await navigator.clipboard.writeText(text);
      setCopied(true);

      // Reset the copied state after 2 seconds
      setTimeout(() => {
        setCopied(false);
      }, 2000);
    } catch (err) {
      console.error("Failed to copy:", err);
    }
  };

  // Add inline styles to ensure no focus outline appears
  const buttonStyle = {
    outline: "none",
  };

  return (
    <button
      type="button"
      className={`${className}`}
      onClick={handleCopy}
      title={copied ? "Copied!" : "Copy to clipboard"}
      style={buttonStyle}
    >
      {copied ? <Check size={16} /> : <Copy size={16} />}
      {children}
    </button>
  );
};

export default CopyButton;

```

File: /Users/haikalp/Documents/Code/Projects/pastemax-forked/src/App.tsx
```tsx
import React, { useState, useEffect, useCallback } from "react";
import type { Dispatch, SetStateAction } from 'react';
import Sidebar from "./components/Sidebar";
import FileList from "./components/FileList";
import CopyButton from "./components/CopyButton";
import UserInstructions from "./components/UserInstructions";
import { FileData, RootFolder, TreeNode, SidebarProps, isFileData, isRootFolder, isTreeNode } from "./types/FileTypes";
import { ThemeProvider } from "./context/ThemeContext";
import ThemeToggle from "./components/ThemeToggle";
import { PlusCircle, FolderOpen} from "lucide-react";

/**
 * Import path utilities for handling file paths across different operating systems.
 * While not all utilities are used directly, they're kept for consistency and future use.
 */
import * as pathUtils from "./utils/pathUtils";

// Ensure we have the critical path utilities, with fallbacks if needed
const {
  generateAsciiFileTree,
  normalizePath,
  arePathsEqual = (path1: string, path2: string): boolean => {
    // Fallback implementation if the imported version isn't available
    if (!path1 && !path2) return true;
    if (!path1 || !path2) return false;
    return normalizePath(path1).toLowerCase() === normalizePath(path2).toLowerCase();
  },
  isSubPath = (parent: string, child: string): boolean => {
    // Fallback implementation if the imported version isn't available
    if (!parent || !child) return false;
    const normalizedParent = normalizePath(parent);
    const normalizedChild = normalizePath(child);
    return normalizedChild.toLowerCase().startsWith(normalizedParent.toLowerCase());
  },
  join = (...parts: string[]): string => parts.filter(Boolean).join('/'),
  basename = (path: string): string => {
    // Fallback implementation if the imported version isn't available
    if (!path) return "";
    const normalizedPath = normalizePath(path);
    const parts = normalizedPath.split("/");
    return parts[parts.length - 1] || "";
  }
} = pathUtils;

// Access the electron API from the window object
declare global {
  interface Window {
    electron: {
      ipcRenderer: {
        send: (channel: string, data?: any) => void;
        on: (channel: string, func: (...args: any[]) => void) => void;
        removeListener: (
          channel: string,
          func: (...args: any[]) => void,
        ) => void;
      };
    };
  }
}

/**
 * Keys used for storing app state in localStorage.
 * Keeping them in one place makes them easier to manage and update.
 */
const STORAGE_KEYS = {
  SELECTED_FOLDER: "pastemax-selected-folder",
  ROOT_FOLDERS: "pastemax-root-folders",
  SELECTED_FILES: "pastemax-selected-files",
  SORT_ORDER: "pastemax-sort-order",
  SEARCH_TERM: "pastemax-search-term",
  EXPANDED_NODES: "pastemax-expanded-nodes",
};

/**
 * The main App component that handles:
 * - File selection and management
 * - Folder navigation
 * - File content copying
 * - UI state management
 */
const App = (): JSX.Element => {
  // Clear saved folder on startup (temporary, for testing)
  useEffect(() => {
    // Commenting out for multiple root folders testing
    // localStorage.removeItem(STORAGE_KEYS.SELECTED_FOLDER);
    
    // These can remain for session data management
    localStorage.removeItem("hasLoadedInitialData");
    sessionStorage.removeItem("hasLoadedInitialData");
    
    // For testing, we could initialize ROOT_FOLDERS with test data if needed
    // const testRootFolder = {
    //   id: "test-root-1",
    //   path: "C:/test-folder",
    //   name: "Test Root",
    //   isExpanded: true
    // };
    // localStorage.setItem(STORAGE_KEYS.ROOT_FOLDERS, JSON.stringify([testRootFolder]));
  }, []);

  // Load initial state from localStorage if available
  const savedFolder = localStorage.getItem(STORAGE_KEYS.SELECTED_FOLDER);
  const savedFiles = localStorage.getItem(STORAGE_KEYS.SELECTED_FILES);
  const savedSortOrder = localStorage.getItem(STORAGE_KEYS.SORT_ORDER);
  const savedSearchTerm = localStorage.getItem(STORAGE_KEYS.SEARCH_TERM);

  const [selectedFolder, setSelectedFolder] = useState<string | null>(savedFolder);
  const [rootFolders, setRootFolders] = useState<RootFolder[]>(() => {
    const savedRoots = localStorage.getItem(STORAGE_KEYS.ROOT_FOLDERS);
    return (savedRoots ? JSON.parse(savedRoots) : []) as RootFolder[];
  });
  const [allFiles, setAllFiles] = useState<FileData[]>([]);
  const [selectedFiles, setSelectedFiles] = useState<FileData[]>([]);
  const [sortOrder, setSortOrder] = useState<string>(savedSortOrder || "tokens-desc");
  const [searchTerm, setSearchTerm] = useState<string>(savedSearchTerm || "");
  const [expandedNodes, setExpandedNodes] = useState<Set<string>>(new Set());
  const [displayedFiles, setDisplayedFiles] = useState<FileData[]>([]);
  const [processingStatus, setProcessingStatus] = useState<{ status: string; message: string } | null>(null);
  const [includeFileTree, setIncludeFileTree] = useState<boolean>(false);
  const [selectedFile, setSelectedFile] = useState<FileData | null>(null);

  // State for sort dropdown
  const [sortDropdownOpen, setSortDropdownOpen] = useState(false);

  // Check if we're running in Electron or browser environment
  const isElectron = window.electron !== undefined;

  const [isSafeMode, setIsSafeMode] = useState(false);

  // Load expanded nodes state from localStorage
  useEffect(() => {
    const savedExpandedNodes = localStorage.getItem(
      STORAGE_KEYS.EXPANDED_NODES,
    );
    if (savedExpandedNodes) {
      try {
        setExpandedNodes(new Set(JSON.parse(savedExpandedNodes)));
      } catch (error) {
        console.error("Error parsing saved expanded nodes:", error);
      }
    }
  }, []);

  // Persist selected folder when it changes
  useEffect(() => {
    if (selectedFolder) {
      localStorage.setItem(STORAGE_KEYS.SELECTED_FOLDER, selectedFolder);
    } else {
      localStorage.removeItem(STORAGE_KEYS.SELECTED_FOLDER);
    }
  }, [selectedFolder]);

  // Persist selected files when they change
  useEffect(() => {
    localStorage.setItem(
      STORAGE_KEYS.SELECTED_FILES,
      JSON.stringify(selectedFiles),
    );
  }, [selectedFiles]);

  // Persist sort order when it changes
  useEffect(() => {
    localStorage.setItem(STORAGE_KEYS.SORT_ORDER, sortOrder);
  }, [sortOrder]);

  // Persist search term when it changes
  useEffect(() => {
    localStorage.setItem(STORAGE_KEYS.SEARCH_TERM, searchTerm);
  }, [searchTerm]);

  // Add a function to cancel directory loading
  const cancelDirectoryLoading = useCallback(() => {
    if (isElectron) {
      window.electron.ipcRenderer.send("cancel-directory-loading");
      setProcessingStatus({
        status: "idle",
        message: "Directory loading cancelled",
      });
    }
  }, [isElectron]);

  // Add this new useEffect for safe mode detection
  useEffect(() => {
    if (!isElectron) return;
    
    const handleStartupMode = (mode: { safeMode: boolean }) => {
      setIsSafeMode(mode.safeMode);
    
      // If we're in safe mode, don't auto-load the previously selected folder
      if (mode.safeMode) {
        console.log("Starting in safe mode - not loading saved folder");
        localStorage.removeItem("hasLoadedInitialData");
        localStorage.removeItem(STORAGE_KEYS.SELECTED_FOLDER);
      }
    };
    
    window.electron.ipcRenderer.on("startup-mode", handleStartupMode);
    
    return () => {
      window.electron.ipcRenderer.removeListener("startup-mode", handleStartupMode);
    };
  }, [isElectron]);

  // Modify the existing useEffect for loading initial data
  useEffect(() => {
    if (!isElectron || !selectedFolder || isSafeMode) return;
    
    // Use a flag in sessionStorage to ensure we only load data once per session
    const hasLoadedInitialData = sessionStorage.getItem("hasLoadedInitialData");
    if (hasLoadedInitialData === "true") return;
    
    console.log("Loading saved folder on startup:", selectedFolder);
    setProcessingStatus({
      status: "processing",
      message: "Loading files from previously selected folder... (Press ESC to cancel)",
    });
    window.electron.ipcRenderer.send("request-file-list", selectedFolder);
    
    // Mark that we've loaded the initial data
    sessionStorage.setItem("hasLoadedInitialData", "true");
  }, [isElectron, selectedFolder, isSafeMode]);
  

  // Listen for folder selection from main process
  useEffect(() => {
    if (!isElectron) {
      console.warn("Not running in Electron environment");
      return;
    }

    const handleFolderSelected = (folderPath: string) => {
      // Check if folderPath is valid string
      if (typeof folderPath === "string") {
        console.log("Folder selected:", folderPath);
        setSelectedFolder(folderPath);
        // We'll select all files after they're loaded
        setSelectedFiles([]);
        setProcessingStatus({
          status: "processing",
          message: "Requesting file list...",
        });
        window.electron.ipcRenderer.send("request-file-list", folderPath);
      } else {
        console.error("Invalid folder path received:", folderPath);
        setProcessingStatus({
          status: "error",
          message: "Invalid folder path received",
        });
      }
    };

    const handleFileListData = (files: FileData[]) => {
      console.log("Received file list data:", files ? files.length : 0, "files");
      
      // Ensure we have a valid array of files
      if (!files || !Array.isArray(files)) {
        console.error("Invalid file list data received:", files);
        setProcessingStatus({
          status: "error",
          message: "Error: Received invalid file list data",
        });
        return;
      }
      
      // Log directory entries for debugging
      const directoryEntries = files.filter(file => file && file.isDirectory);
      console.log(`Directory entries in file list: ${directoryEntries.length}`);
      if (directoryEntries.length > 0) {
        directoryEntries.slice(0, 3).forEach(dir => {
          console.log(`Directory: ${dir.name}, path: ${dir.path}, isDirectory: ${dir.isDirectory}`);
        });
      }
      
      // Process files and ensure they have the correct structure
      setAllFiles(files);
      setProcessingStatus({
        status: "complete",
        message: `Loaded ${files.length} files`,
      });

      // Apply filters and sort to the new files
      applyFiltersAndSort(files, sortOrder, searchTerm);

      // Ensure the root folder is expanded by default if it exists
      const rootFolder = files.find(file => 
        file && file.path && file.isDirectory && 
        arePathsEqual(file.path, selectedFolder || '')
      );
      
      if (rootFolder) {
        console.log("Found root folder in file list:", rootFolder.name, rootFolder.path);
        setExpandedNodes((prev: Set<string>) => new Set([...prev, `node-${selectedFolder}`]));
      } else {
        console.log("Root folder not found in file list, selected folder is:", selectedFolder);
      }

      // Try to restore saved selection from localStorage, filtering for files that still exist
      const savedFiles = localStorage.getItem(STORAGE_KEYS.SELECTED_FILES);
      let newSelectedFiles: FileData[] = [];
      
      if (savedFiles) {
        try {
          const parsedSavedFiles: FileData[] = JSON.parse(savedFiles);
          // Filter saved files to ensure they exist in the new file list and are selectable
          newSelectedFiles = parsedSavedFiles.filter((file: FileData) =>
            files.some((f: FileData) =>
              f && f.path && file.path && 
              f.path === file.path && 
              !f.isBinary && !f.isSkipped && 
              !f.excludedByDefault && !f.isDirectory
            )
          );
        } catch (error) {
          console.error("Error parsing saved selected files:", error);
        }
      }

      // If no valid saved selection, default to selecting all non-binary, non-skipped, non-excluded files
      if (newSelectedFiles.length === 0) {
        newSelectedFiles = files
          .filter(
            (file: FileData) =>
              file && file.path && 
              !file.isBinary && !file.isSkipped && 
              !file.excludedByDefault && !file.isDirectory
          )
          .map((file: FileData) => file);
      }

      setSelectedFiles(newSelectedFiles);
    };

    const handleProcessingStatus = (status: {
      status: "idle" | "processing" | "complete" | "error" | "cancelled";
      message: string;
    }) => {
      console.log("Processing status:", status);
      
      // Always update the processing status immediately
      setProcessingStatus(status);
      
      // If we're completing, add a slight delay before updating state
      // This ensures UI transitions are smooth and user sees completion
      if (status.status === "complete") {
        // Keep the loading UI visible for a moment so user can see completion message
        setTimeout(() => {
          setProcessingStatus({
            status: "idle",
            message: status.message || "Processing complete"
          });
        }, 800); // 800ms delay gives user time to see the completion message
      } else if (status.status === "cancelled") {
        // Show cancelled status briefly before returning to idle
        setTimeout(() => {
          setProcessingStatus({
            status: "idle",
            message: ""
          });
        }, 1500);
      }
    };

    // New handler for root folder added event
    const handleRootFolderAdded = (newRoot: RootFolder) => {
      console.log("Root folder added:", newRoot);
      
      setRootFolders((prevRoots: RootFolder[]) => {
        // Ensure we're not duplicating roots
        const isRootAlreadyAdded = prevRoots.some(
          root => root.id === newRoot.id || arePathsEqual(root.path, newRoot.path)
        );
        
        if (isRootAlreadyAdded) {
          console.log("Root already exists, not adding duplicate", newRoot.path);
          return prevRoots;
        }
        
        // Add the new root to the existing roots
        const updatedRoots = [...prevRoots, newRoot];
        // Save to localStorage
        localStorage.setItem(STORAGE_KEYS.ROOT_FOLDERS, JSON.stringify(updatedRoots));
        return updatedRoots;
      });
      
      // Request file list for the new root
      setProcessingStatus({
        status: "processing",
        message: `Loading files from ${newRoot.name}...`,
      });
      window.electron.ipcRenderer.send("request-file-list", newRoot.path);
    };
    
    // Handler for root folder removed event
    const handleRootFolderRemoved = (rootId: string) => {
      console.log("Root folder removed:", rootId);
      
      setRootFolders((prevRoots: RootFolder[]) => {
        const updatedRoots = prevRoots.filter((root: RootFolder) => root.id !== rootId);
        // Save to localStorage
        localStorage.setItem(STORAGE_KEYS.ROOT_FOLDERS, JSON.stringify(updatedRoots));
        return updatedRoots;
      });
      
      // Remove files from this root from allFiles
      setAllFiles((prevFiles: FileData[]) => prevFiles.filter((file: FileData) => file.rootId !== rootId));
      
      // Update selected files
      setSelectedFiles((prevSelected: FileData[]) => 
        prevSelected.filter((file: FileData) => file.rootId !== rootId)
      );
      
      // Clean up expandedNodes for this root path
      setExpandedNodes((prev: Set<string>) => new Set([...prev].filter(node => !node.startsWith(`node-${rootId}`))));
      
      setProcessingStatus({
        status: "idle",
        message: `Removed folder: ${rootId}`
      });
    };
    
    // Handle root folder error
    const handleRootFolderError = (error: { error: string, path?: string, rootId?: string }) => {
      console.error("Root folder error:", error);
      
      // Set a detailed error message
      let errorMessage = error.error;
      if (error.path) {
        errorMessage += ` (${error.path})`;
      }
      
      // Update the UI with the error message
      setProcessingStatus({
        status: "error",
        message: errorMessage,
      });
      
      // Clear the error after 5 seconds
      setTimeout(() => {
        setProcessingStatus({
          status: "idle",
          message: "",
        });
      }, 5000);
    };

    // Add new handler for when all root folders are removed
    const handleAllRootFoldersRemoved = () => {
      console.log("All root folders removed event received from main process");
      // All state updates are already handled in the removeAllRootFolders function
      // This handler is mostly for confirmation or debugging
    };

    // Add event listeners
    window.electron.ipcRenderer.on("folder-selected", handleFolderSelected);
    window.electron.ipcRenderer.on("file-list-data", handleFileListData);
    window.electron.ipcRenderer.on("file-processing-status", handleProcessingStatus);
    
    // Add new event listeners for root folder events
    window.electron.ipcRenderer.on("root-folder-added", handleRootFolderAdded);
    window.electron.ipcRenderer.on("root-folder-removed", handleRootFolderRemoved);
    window.electron.ipcRenderer.on("root-folder-error", handleRootFolderError);
    window.electron.ipcRenderer.on("root-folders-all-removed", handleAllRootFoldersRemoved);

    return () => {
      window.electron.ipcRenderer.removeListener(
        "folder-selected",
        handleFolderSelected,
      );
      window.electron.ipcRenderer.removeListener(
        "file-list-data",
        handleFileListData,
      );
      window.electron.ipcRenderer.removeListener(
        "file-processing-status",
        handleProcessingStatus,
      );
      
      // Remove root folder event listeners
      window.electron.ipcRenderer.removeListener(
        "root-folder-added",
        handleRootFolderAdded,
      );
      window.electron.ipcRenderer.removeListener(
        "root-folder-removed",
        handleRootFolderRemoved,
      );
      window.electron.ipcRenderer.removeListener(
        "root-folder-error",
        handleRootFolderError,
      );
      window.electron.ipcRenderer.removeListener(
        "root-folders-all-removed",
        handleAllRootFoldersRemoved,
      );
    };
  }, [isElectron, sortOrder, searchTerm, allFiles]);

  const openFolder = () => {
    if (isElectron) {
      console.log("Opening folder dialog");
      setProcessingStatus({ status: "idle", message: "Select a folder..." });
      window.electron.ipcRenderer.send("open-folder");
    } else {
      console.warn("Folder selection not available in browser");
    }
  };

  // Add another root folder
  const addRootFolder = () => {
    if (isElectron) {
      console.log("Adding another root folder");
      setProcessingStatus({ status: "idle", message: "Select additional folder..." });
      window.electron.ipcRenderer.send("add-root-folder");
    } else {
      console.warn("Folder selection not available in browser");
    }
  };
  
  // Function to remove a root folder
  const removeRootFolder = useCallback((rootId: string) => {
    console.log("Removing root folder:", rootId);
    
    // First find the root to get its path for cleanup
    const rootToRemove = rootFolders.find((root: RootFolder) => root.id === rootId);
    
    if (rootToRemove) {
      // Send IPC message to main process to remove from its cache
      if (isElectron) {
        window.electron.ipcRenderer.send("remove-root-folder", rootId);
      }
      
      // Update rootFolders state
      setRootFolders((prevRoots: RootFolder[]) => {
        const updatedRoots = prevRoots.filter((root: RootFolder) => root.id !== rootId);
        // Save to localStorage
        localStorage.setItem(STORAGE_KEYS.ROOT_FOLDERS, JSON.stringify(updatedRoots));
        return updatedRoots;
      });
      
      // Remove files from this root from allFiles
      setAllFiles((prevFiles: FileData[]) => prevFiles.filter((file: FileData) => file.rootId !== rootId));
      
      // Update selected files
      setSelectedFiles((prevSelected: FileData[]) => 
        prevSelected.filter((file: FileData) => file.rootId !== rootId)
      );
      
      // Clean up expandedNodes for this root path
      setExpandedNodes((prev: Set<string>) => new Set([...prev].filter(node => !node.startsWith(`node-${rootId}`))));
      
      setProcessingStatus({
        status: "idle",
        message: `Removed folder: ${rootToRemove.name}`
      });
    }
  }, [allFiles, rootFolders, isElectron]);
  
  // Function to remove all root folders
  const removeAllRootFolders = useCallback(() => {
    console.log("Removing all root folders");
    
    // Send IPC message to main process to clear its cache
    if (isElectron) {
      window.electron.ipcRenderer.send("remove-all-root-folders");
    }
    
    // Clear all localStorage related to root folders and app state
    localStorage.setItem(STORAGE_KEYS.ROOT_FOLDERS, JSON.stringify([]));
    localStorage.setItem(STORAGE_KEYS.EXPANDED_NODES, JSON.stringify(JSON.stringify(new Set())));
    
    // Consider clearing or resetting search terms if they're scoped to folders
    localStorage.setItem(STORAGE_KEYS.SEARCH_TERM, "");
    setSearchTerm("");
    
    // Clear all in-memory state
    setRootFolders([]);
    setAllFiles([]);
    setSelectedFiles([]);
    setExpandedNodes(new Set());
    
    // Reset UI state
    setProcessingStatus({
      status: "idle",
      message: "All root folders removed"
    });
  }, [isElectron]);

  // Apply filters and sorting to files
  const applyFiltersAndSort = (
    files: FileData[],
    sort: string,
    filter: string,
  ) => {
    let filtered = files;

    // Apply filter
    if (filter) {
      const lowerFilter = filter.toLowerCase();
      filtered = files.filter(
        (file) => {
          // Normalize paths before doing case-insensitive comparison
          const normalizedPath = normalizePath(file.path);
          
          return file.name.toLowerCase().includes(lowerFilter) ||
            normalizedPath.toLowerCase().includes(lowerFilter);
        }
      );
    }

    // Apply sort
    const sorted = sortFiles(filtered, sort);

    setDisplayedFiles(sorted);
  };

  // Update toggleFileSelection to accept FileData
  const toggleFileSelection = (file: FileData): void => {
    if (!isFileData(file)) return;
    
    const normalizedPath = normalizePath(file.path);
    setSelectedFiles((prevFiles: FileData[]) => {
      const isSelected = prevFiles.some(existingFile => 
        isFileData(existingFile) && arePathsEqual(existingFile.path, normalizedPath)
      );
      
      if (isSelected) {
        return prevFiles.filter(existingFile => 
          isFileData(existingFile) && !arePathsEqual(existingFile.path, normalizedPath)
        );
      } else {
        return [...prevFiles, file];
      }
    });
  };

  // Update toggleFolderSelection to accept RootFolder
  const toggleFolderSelection = (folder: RootFolder): void => {
    if (!isRootFolder(folder)) return;
    
    const normalizedFolderPath = normalizePath(folder.path);
    const folderRootId = folder.id;
    
    const filesInFolder = allFiles.filter((file: FileData) => {
      if (folderRootId && file.rootId !== folderRootId) {
        return false;
      }
      
      const inFolder = isSubPath(normalizedFolderPath, file.path);
      const selectable = !file.isBinary && !file.isSkipped && !file.excludedByDefault && !file.isDirectory;
      return inFolder && selectable;
    });
    
    setSelectedFiles((prevFiles: FileData[]) => {
      const allSelected = filesInFolder.every((file: FileData) => 
        prevFiles.some((p: FileData) => arePathsEqual(p.path, file.path))
      );
      
      if (allSelected) {
        return prevFiles.filter((p: FileData) => 
          !filesInFolder.some((f: FileData) => arePathsEqual(f.path, p.path))
        );
      } else {
        const newSelection = [...prevFiles];
        filesInFolder.forEach((file: FileData) => {
          if (!prevFiles.some((p: FileData) => arePathsEqual(p.path, file.path))) {
            newSelection.push(file);
          }
        });
        return newSelection;
      }
    });
  };

  // Update toggleExpanded to accept TreeNode
  const toggleExpanded = (node: TreeNode): void => {
    if (!isTreeNode(node)) return;
    
    setExpandedNodes((prev: Set<string>) => {
      const newSet = new Set(prev);
      if (newSet.has(node.id)) {
        newSet.delete(node.id);
      } else {
        newSet.add(node.id);
      }
      
      // For debugging
      console.log(`Toggling node ${node.id} to ${newSet.has(node.id) ? 'expanded' : 'collapsed'}`);
      
      // If this is a root node, store its expanded state in the rootFolders state as well
      if (node.id.startsWith('node-') && rootFolders.length > 0) {
        const nodePath = node.path;
        
        // Find the matching root folder
        const updatedRootFolders = rootFolders.map((root: RootFolder) => {
          if (!isRootFolder(root)) return root;
          
          const normalizedRootPath = normalizePath(root.path);
          const normalizedNodePath = normalizePath(nodePath);
          
          // Check if this is the root node being toggled
          if (arePathsEqual(normalizedRootPath, normalizedNodePath)) {
            console.log(`Updating root folder ${root.name} expanded state to ${newSet.has(node.id)}`);
            return {
              ...root,
              isExpanded: newSet.has(node.id)
            };
          }
          return root;
        });
        
        // Update the rootFolders state and store in localStorage
        setRootFolders(updatedRootFolders);
        localStorage.setItem(STORAGE_KEYS.ROOT_FOLDERS, JSON.stringify(updatedRootFolders));
      }
      
      // Also store in localStorage for persistence
      localStorage.setItem(STORAGE_KEYS.EXPANDED_NODES, JSON.stringify(Array.from(newSet)));
      
      return newSet;
    });
  };

  // Update selectAllFiles with proper types
  const selectAllFiles = (): void => {
    setSelectedFiles((prevFiles: FileData[]) => {
      const newFiles = allFiles.filter((file: FileData) => 
        !file.isBinary && 
        !file.isSkipped && 
        !file.excludedByDefault && 
        !file.isDirectory &&
        !prevFiles.some((p: FileData) => arePathsEqual(p.path, file.path))
      );
      return [...prevFiles, ...newFiles];
    });
  };

  // Deselect all files
  const deselectAllFiles = (): void => {
    setSelectedFiles([]);
  };

  // Handle sort change
  const handleSortChange = (newSort: string) => {
    setSortOrder(newSort);
    applyFiltersAndSort(allFiles, newSort, searchTerm);
    setSortDropdownOpen(false); // Close dropdown after selection
  };

  // Handle search change
  const handleSearchChange = (term: string): void => {
    setSearchTerm(term);
  };

  // Toggle sort dropdown
  const toggleSortDropdown = () => {
    setSortDropdownOpen(!sortDropdownOpen);
  };

  // Calculate total tokens from selected files
  const calculateTotalTokens = () => {
    return selectedFiles.reduce((total: number, path: string) => {
      // Use our safely imported arePathsEqual function
      const file = allFiles.find((f: FileData) => arePathsEqual(f.path, path));
      return total + (file ? file.tokenCount : 0);
    }, 0);
  };

  // NEW: State for user instructions
  const [userInstructions, setUserInstructions] = useState("");

  // Modify getSelectedFilesContent to organize content by root
  const getSelectedFilesContent = () => {
    // Get user instructions
    const instructionsElement = document.getElementById("user-instructions");
    const userInstructions = instructionsElement && 'value' in instructionsElement 
      ? (instructionsElement as HTMLTextAreaElement).value 
      : "";
    
    // Group selected files by root
    const rootGroups: Record<string, FileData[]> = {};
    
    selectedFiles.forEach((filePath: string) => {
      const file = allFiles.find((f: FileData) => f.path === filePath);
      if (file) {
        const rootId = file.rootId || 'default';
        if (!rootGroups[rootId]) {
          rootGroups[rootId] = [];
        }
        rootGroups[rootId].push(file);
      }
    });
    
    // Create output with root separation
    let output = userInstructions ? `${userInstructions}\n\n` : "";
    
    Object.entries(rootGroups).forEach(([rootId, files]) => {
      // Find root folder name
      let rootName = "Root Folder";
      const root = rootFolders.find((r: RootFolder) => r.id === rootId);
      if (root) {
        rootName = root.name;
      }
      
      // Add root section header
      output += `Root: ${rootName}\n`;
      
      // Add file tree for this root
      const rootFiles = allFiles.filter((f: FileData) => f.rootId === rootId);
      const rootPath = root?.path || files[0]?.rootPath;
      if (rootPath) {
        output += `File Structure:\n${generateAsciiFileTree(rootFiles, rootPath)}\n\n`;
      }
      
      // Add selected files content
      output += `Selected Files:\n`;
      files.forEach(file => {
        output += `\n---- ${file.path} ----\n${file.content}\n`;
      });
      
      output += `\n`;
    });
    
    return output;
  };

  // Sort options for the dropdown
  const sortOptions = [
    { value: "tokens-desc", label: "Tokens: High to Low" },
    { value: "tokens-asc", label: "Tokens: Low to High" },
    { value: "name-asc", label: "Name: A to Z" },
    { value: "name-desc", label: "Name: Z to A" },
  ];

  // Update sorting logic with proper type handling
  const sortFiles = (files: FileData[], order: string): FileData[] => {
    return [...files].sort((a: FileData, b: FileData) => {
      let comparison = 0;

      if (order === "name-asc" || order === "name-desc") {
        comparison = a.name.localeCompare(b.name);
      } else if (order === "tokens-asc" || order === "tokens-desc") {
        const aTokens = a.tokenCount || 0;
        const bTokens = b.tokenCount || 0;
        comparison = aTokens - bTokens;
      } else if (order === "size-asc" || order === "size-desc") {
        const aSize = a.size || 0;
        const bSize = b.size || 0;
        comparison = aSize - bSize;
      }

      return order.endsWith("-desc") ? -comparison : comparison;
    });
  };

  return (
    <ThemeProvider children={
      <div className="app-container">
        <header className="header">
          <h1>PasteMax</h1>
          <div className="header-actions">
            <ThemeToggle />
            <div className="folder-info">
              {selectedFolder ? (
                <div className="selected-folder">{selectedFolder}</div>
              ) : (
                <span>No folder selected</span>
              )}
              <div className="folder-buttons">
                <button
                  className="select-folder-btn"
                  onClick={openFolder}
                  disabled={processingStatus?.status === "processing"}
                >
                  <FolderOpen className="btn-icon" />
                  Select Folder
                </button>
                {rootFolders.length > 0 && (
                  <button
                    className="add-another-btn"
                    onClick={addRootFolder}
                    disabled={processingStatus?.status === "processing"}
                  >
                    <PlusCircle className="btn-icon" />
                    Add Another
                  </button>
                )}
              </div>
            </div>
          </div>
        </header>

        {processingStatus?.status === "processing" && (
          <div className="processing-indicator">
            <div className="spinner"></div>
            <span>{processingStatus.message}</span>
            <button
              className="cancel-btn"
              onClick={cancelDirectoryLoading}
            >
              Cancel
            </button>
          </div>
        )}

        {processingStatus?.status === "error" && (
          <div className="error-message">Error: {processingStatus.message}</div>
        )}

        {selectedFolder && (
          <div className="main-content">
            <Sidebar
              rootFolders={rootFolders}
              selectedFolder={selectedFolder}
              openFolder={openFolder}
              addRootFolder={addRootFolder}
              removeRootFolder={removeRootFolder}
              removeAllRootFolders={removeAllRootFolders}
              allFiles={allFiles}
              selectedFiles={selectedFiles}
              toggleFileSelection={toggleFileSelection}
              toggleFolderSelection={toggleFolderSelection}
              selectAllFiles={selectAllFiles}
              deselectAllFiles={deselectAllFiles}
              expandedNodes={expandedNodes}
              toggleExpanded={toggleExpanded}
              processingStatus={processingStatus}
              onExpandedNodesChange={setExpandedNodes}
              onSelectedFileChange={setSelectedFile}
              selectedFile={selectedFile}
              searchTerm={searchTerm}
              onSearchChange={handleSearchChange}
            />
            <div className="content-area">
              <div className="content-header">
                <div className="content-title">Selected Files</div>
                <div className="content-actions">
                  <div className="sort-dropdown">
                    <button
                      className="sort-dropdown-button"
                      onClick={toggleSortDropdown}
                    >
                      Sort:{" "}
                      {sortOptions.find((opt) => opt.value === sortOrder)
                        ?.label || sortOrder}
                    </button>
                    {sortDropdownOpen && (
                      <div className="sort-options">
                        {sortOptions.map((option) => (
                          <div
                            key={option.value}
                            className={`sort-option ${
                              sortOrder === option.value ? "active" : ""
                            }`}
                            onClick={() => handleSortChange(option.value)}
                          >
                            {option.label}
                          </div>
                        ))}
                      </div>
                    )}
                  </div>
                  <div className="file-stats">
                    {selectedFiles.length} files | ~
                    {calculateTotalTokens().toLocaleString()} tokens
                  </div>
                </div>
              </div>

              <FileList
                files={displayedFiles}
                selectedFiles={selectedFiles}
                toggleFileSelection={toggleFileSelection}
              />

              {/* Render the user instructions textbox */}
              <div className="user-instructions-container">
                <UserInstructions
                  instructions={userInstructions}
                  setInstructions={setUserInstructions}
                />
              </div>

              <div className="copy-button-container">
                <div style={{ display: "flex", flexDirection: "column", alignItems: "center", gap: "12px", width: "100%", maxWidth: "400px" }}>
                  <label style={{ display: "flex", alignItems: "center", gap: "8px", cursor: "pointer" }}>
                    <input
                      type="checkbox"
                      checked={includeFileTree}
                      onChange={() => setIncludeFileTree(!includeFileTree)}
                    />
                    <span>Include File Tree</span>
                  </label>
                  <CopyButton
                    text={getSelectedFilesContent()}
                    className="primary full-width"
                  >
                    <span>COPY ALL SELECTED ({selectedFiles.length} files)</span>
                  </CopyButton>
                </div>
              </div>
            </div>
          </div>
        )}
      </div>
    } />
  );
};

export default App;
```

File: /Users/haikalp/Documents/Code/Projects/pastemax-forked/main.js
```js
const { app, BrowserWindow, ipcMain, dialog, globalShortcut } = require("electron");
const fs = require("fs");
const path = require("path");
const os = require("os");
const crypto = require("crypto"); // Added for CSP nonce generation

// Import shared path utilities
const { 
  normalizePath, 
  makeRelativePath, 
  ensureAbsolutePath, 
  safePathJoin, 
  safeRelativePath,
  getPathSeparator,
  basename,
  dirname,
  isWindows,
  isNode,
  isValidPath,
  join,
  extname,
  arePathsEqual,
  isSubPath,
} = require("./shared/path-utils");

// Global variables for directory loading control
let isLoadingDirectory = false;
let loadingTimeoutId = null;
let isHandlingGitignore = false; // New flag to track gitignore processing specifically
const MAX_DIRECTORY_LOAD_TIME = 60000; // 60 seconds timeout

// Add a cache for gitignore file paths to avoid rescanning
const gitignoreCache = new Map();
// Maximum age in milliseconds before invalidating the cache (10 minutes)
const GITIGNORE_CACHE_MAX_AGE = 10 * 60 * 1000;

// Track root folders for multi-root support
let rootFolders = [];

// Store reference to mainWindow globally so we can access it for theme updates
let mainWindow = null;
// Track current theme for DevTools sync
let currentTheme = 'light';

// Global state to track directory loading progress
let totalFilesProcessed = 0;
let totalFilesFound = 0;
let totalDirectoriesProcessed = 0;
let totalDirectoriesFound = 0;
let isDeepScanEnabled = true; // Enable this for thorough scanning, can be disabled for faster superficial scans

// Import the excluded files list and other configurations
const { 
  excludedFiles, 
  binaryExtensions, 
  skipDirectories,
  defaultIgnorePatterns,
  excludedRegexPatterns
} = require("./excluded-files");

// List of directories that should be completely skipped during traversal
// These are directories that often cause performance issues and don't provide useful content
const SKIP_DIRS = skipDirectories;

// Add handling for the 'ignore' module
let ignore;
try {
  ignore = require("ignore");
  console.log("Successfully loaded ignore module");
} catch (err) {
  console.error("Failed to load ignore module:", err);
  // Simple fallback implementation for when the ignore module fails to load
  ignore = {
    // Simple implementation that just matches exact paths
    createFilter: () => {
      return (path) => !excludedFiles.includes(path);
    },
  };
  console.log("Using fallback for ignore module");
}

// Initialize tokenizer with better error handling
let tiktoken;
try {
  tiktoken = require("tiktoken");
  console.log("Successfully loaded tiktoken module");
} catch (err) {
  console.error("Failed to load tiktoken module:", err);
  tiktoken = null;
}

// Initialize the encoder once at startup with better error handling
let encoder;
try {
  if (tiktoken) {
    encoder = tiktoken.get_encoding("o200k_base"); // gpt-4o encoding
    console.log("Tiktoken encoder initialized successfully");
  } else {
    throw new Error("Tiktoken module not available");
  }
} catch (err) {
  console.error("Failed to initialize tiktoken encoder:", err);
  // Fallback to a simpler method if tiktoken fails
  console.log("Using fallback token counter");
  encoder = null;
}

// Binary file extensions that should be excluded from token counting
// Use the centralized list from excluded-files.js and add any built-in defaults
const BINARY_EXTENSIONS = [
  // Images
  ".jpg",
  ".jpeg",
  ".png",
  ".gif",
  ".bmp",
  ".tiff",
  ".ico",
  ".icns",
  ".webp",
  ".svg",
  ".heic",
  ".heif",
  ".pdf",
  ".psd",
  // Audio/Video
  ".mp3",
  ".mp4",
  ".wav",
  ".ogg",
  ".avi",
  ".mov",
  ".mkv",
  ".flac",
  // Archives
  ".zip",
  ".rar",
  ".tar",
  ".gz",
  ".7z",
  // Documents
  ".pdf",
  ".doc",
  ".docx",
  ".ppt",
  ".pptx",
  ".xls",
  ".xlsx",
  // Compiled
  ".exe",
  ".dll",
  ".so",
  ".class",
  ".o",
  ".pyc",
  // Database
  ".db",
  ".sqlite",
  ".sqlite3",
  // Others
  ".bin",
  ".dat",
].concat(binaryExtensions || []); // Add extensions from excluded-files.js

// Max file size to read (5MB)
const MAX_FILE_SIZE = 5 * 1024 * 1024;

function createWindow() {
  // Check if we're starting in safe mode (Shift key pressed)
  const isSafeMode = process.argv.includes('--safe-mode');
  const isDev = process.env.NODE_ENV === "development";
  
  // In development, suppress Electron security warnings about CSP
  // This is only for development since we need 'unsafe-eval' for Vite HMR
  if (isDev) {
    process.env.ELECTRON_DISABLE_SECURITY_WARNINGS = 'true';
    console.log("Development mode: Security warnings about CSP are suppressed");
  } else {
    // Production security enhancements
    console.log("Production mode: Applying strict security settings");
  }
  
  mainWindow = new BrowserWindow({
    width: 1200,
    height: 800,
    webPreferences: {
      nodeIntegration: false,
      contextIsolation: true,
      preload: safePathJoin(__dirname, "preload.js"),
      // Production security settings
      sandbox: !isDev, // Enable sandbox in production for better security
      devTools: isDev, // Only enable DevTools in development
      webSecurity: true, // Enforce web security
      additionalArguments: [`--app-path=${app.getAppPath()}`], // Pass app path for better cross-platform file resolution
    },
  });

  // Set proper Content-Security-Policy
  // This helps prevent the Insecure Content-Security-Policy warning
  mainWindow.webContents.session.webRequest.onHeadersReceived((details, callback) => {
    // Generate a random nonce for CSP
    const nonce = Buffer.from(crypto.randomBytes(16)).toString('base64');
    
    // Different CSP for development and production
    const isDev = process.env.NODE_ENV === "development";
    
    // Only log CSP once for main documents
    if (details.resourceType === 'mainFrame') {
      if (isDev) {
        console.log("Using development CSP with 'unsafe-eval' for Vite HMR");
      } else {
        console.log("Using production CSP with nonce-based script-src");
      }
    }
    
    let cspValue;
    if (isDev) {
      // Development policy that works with Vite's HMR
      // 'unsafe-eval' is required for Vite HMR in development mode only
      cspValue = [
        "default-src 'self';" +
        "script-src 'self' 'unsafe-inline' 'unsafe-eval';" +
        "style-src 'self' 'unsafe-inline' https://fonts.googleapis.com;" +
        "font-src 'self' data: https://fonts.gstatic.com;" +
        "connect-src 'self' ws: wss: http://localhost:* https://localhost:*;" +
        "img-src 'self' data:;"
      ];
    } else {
      // Secure policy for production with nonce-based script-src
      cspValue = [
        "default-src 'self';" +
        `script-src 'self' 'nonce-${nonce}';` +
        "style-src 'self' 'unsafe-inline';" + // 'unsafe-inline' needed for most CSS frameworks
        "font-src 'self' data:;" +
        "connect-src 'self';" +
        "img-src 'self' data:;" +
        "object-src 'none';" + // Prevent object/embed tags
        "base-uri 'self';" + // Restrict base URIs
        "form-action 'self';" + // Restrict form submissions
        "frame-ancestors 'self';" + // Control embedding 
        "upgrade-insecure-requests;" // Upgrade HTTP to HTTPS
      ];
    }
    
    callback({
      responseHeaders: {
        ...details.responseHeaders,
        'Content-Security-Policy': cspValue,
        'X-Content-Type-Options': ['nosniff'],
        'X-XSS-Protection': ['1; mode=block'],
        'X-Frame-Options': ['SAMEORIGIN']
      }
    });
  });

  // Pass the safe mode flag to the renderer
  mainWindow.webContents.once('did-finish-load', () => {
    mainWindow.webContents.send('startup-mode', { 
      safeMode: isSafeMode 
    });
  });

  // Register the escape key to cancel directory loading
  globalShortcut.register('Escape', () => {
    if (isLoadingDirectory) {
      cancelDirectoryLoading(mainWindow);
    }
  });

  // Clean up shortcuts when window is closed
  mainWindow.on('closed', () => {
    globalShortcut.unregisterAll();
  });

  // Listen for DevTools open events to sync theme
  mainWindow.webContents.on('devtools-opened', () => {
    if (mainWindow && !mainWindow.isDestroyed()) {
      console.log('DevTools opened, applying current theme');
      // Apply current theme to DevTools
      syncDevToolsTheme(currentTheme);
    }
  });

  // Also listen for toggling DevTools via keyboard shortcut
  app.on('web-contents-created', (event, contents) => {
    contents.on('devtools-opened', () => {
      console.log('DevTools opened via shortcut, applying current theme');
      syncDevToolsTheme(currentTheme);
    });
  });

  // In development, load from Vite dev server
  // In production, load from built files
  if (process.env.NODE_ENV === "development") {
    // Use the URL provided by the dev script, or fall back to Vite's default port
    const startUrl = process.env.ELECTRON_START_URL || "http://localhost:5173";
    // Wait a moment for dev server to be ready (increased timeout)
    setTimeout(() => {
      // Clear any cached data to prevent redirection loops
      mainWindow.webContents.session.clearCache().then(() => {
        // Set development-specific webPreferences before loading URL
        mainWindow.webContents.setWindowOpenHandler(({ url }) => {
          // Open external links in browser, internal links in the app
          if (url.startsWith('http')) {
            return { action: 'allow' };
          }
          return { action: 'deny' };
        });
        
        mainWindow.loadURL(startUrl);
        // Open DevTools in development mode with options to reduce warnings
        if (mainWindow.webContents.isDevToolsOpened()) {
          mainWindow.webContents.closeDevTools();
        }
        // Open DevTools in the same window instead of detached
        mainWindow.webContents.openDevTools();
        console.log(`Loading from dev server at ${startUrl}`);
      });
    }, 2000);
  } else {
    const indexPath = safePathJoin(__dirname, "dist", "index.html");
    console.log(`Loading from built files at ${indexPath}`);

    // Use loadURL with file protocol for better path resolution
    const indexUrl = `file://${indexPath}`;
    mainWindow.loadURL(indexUrl);
  }

  // Add basic error handling for failed loads
  mainWindow.webContents.on(
    "did-fail-load",
    (event, errorCode, errorDescription, validatedURL) => {
      console.error(
        `Failed to load the application: ${errorDescription} (${errorCode})`,
      );
      console.error(`Attempted to load URL: ${validatedURL}`);

      if (process.env.NODE_ENV === "development") {
        const retryUrl =
          process.env.ELECTRON_START_URL || "http://localhost:5173";
        // Clear cache before retrying
        mainWindow.webContents.session.clearCache().then(() => {
          setTimeout(() => mainWindow.loadURL(retryUrl), 2000);
        });
      } else {
        // Retry with explicit file URL
        const indexPath = safePathJoin(__dirname, "dist", "index.html");
        const indexUrl = `file://${indexPath}`;
        mainWindow.loadURL(indexUrl);
      }
    },
  );
}

app.whenReady().then(() => {
  // Set secure app-wide defaults for production
  const isDev = process.env.NODE_ENV === "development";
  
  if (!isDev) {
    // Production security settings
    
    // Prevent navigation to non-local content
    app.on('web-contents-created', (event, contents) => {
      contents.on('will-navigate', (event, navigationUrl) => {
        const parsedUrl = new URL(navigationUrl);
        // Only allow navigation to local content
        if (!parsedUrl.protocol.includes('file:')) {
          console.log('Blocked navigation to:', navigationUrl);
          event.preventDefault();
        }
      });
      
      // Block new window creation to external URLs
      contents.setWindowOpenHandler(({ url }) => {
        // Only allow opening windows for internal pages
        if (url.startsWith('file:')) {
          return { action: 'allow' };
        }
        // Open external URLs in the default browser instead
        if (url.startsWith('https:')) {
          setImmediate(() => {
            console.log('Opening in browser:', url);
            require('electron').shell.openExternal(url);
          });
        }
        return { action: 'deny' };
      });
    });
  }
  
  createWindow();

  app.on("activate", () => {
    if (BrowserWindow.getAllWindows().length === 0) createWindow();
  });
});

app.on("window-all-closed", () => {
  if (process.platform !== "darwin") {
    app.quit();
  }
});

// Generate a unique ID for root folders
function generateRootId() {
  return `root-${Date.now()}-${Math.floor(Math.random() * 1000)}`;
}

// Handle folder selection (first root)
ipcMain.on("open-folder", async (event) => {
  const result = await dialog.showOpenDialog({
    properties: ["openDirectory"],
  });

  if (!result.canceled && result.filePaths && result.filePaths.length > 0) {
    const selectedPath = result.filePaths[0];
    try {
      // Clear the gitignore cache since we're loading a new project
      gitignoreCache.clear();
      console.log("Cleared gitignore cache for new project");
      
      // Create a new root folder object
      const newRoot = {
        id: generateRootId(),
        path: selectedPath,
        name: path.basename(selectedPath),
        isExpanded: true
      };
      
      // Reset root folders array
      rootFolders = [newRoot];
      
      // Ensure we're only sending a string, not an object
      const pathString = String(selectedPath);
      console.log("Sending folder-selected event with path:", pathString);
      event.sender.send("folder-selected", pathString);
      
      // Also send the root folder information
      console.log("Sending root-folder-added event with root:", newRoot);
      event.sender.send("root-folder-added", newRoot);
    } catch (err) {
      console.error("Error sending folder-selected event:", err);
      // Try a more direct approach as a fallback
      event.sender.send("folder-selected", String(selectedPath));
    }
  }
});

// Handle adding another root folder
ipcMain.on("add-root-folder", async (event) => {
  const result = await dialog.showOpenDialog({
    properties: ["openDirectory"],
  });

  if (!result.canceled && result.filePaths && result.filePaths.length > 0) {
    const selectedPath = result.filePaths[0];
    try {
      // Check if this path is already in rootFolders
      const pathExists = rootFolders.some(root => 
        arePathsEqual(normalizePath(root.path), normalizePath(selectedPath))
      );
      
      if (pathExists) {
        event.sender.send("root-folder-error", {
          error: "This folder has already been added",
          path: selectedPath
        });
        return;
      }
      
      // Check if this path is a subfolder of any existing root
      const isSubfolderOfExistingRoot = rootFolders.some(root => 
        isSubPath(normalizePath(root.path), normalizePath(selectedPath))
      );
      
      if (isSubfolderOfExistingRoot) {
        event.sender.send("root-folder-error", {
          error: "This folder is a subfolder of an existing root folder",
          path: selectedPath
        });
        return;
      }
      
      // Check if any existing root is a subfolder of this path
      const hasSubfolderRoot = rootFolders.some(root => 
        isSubPath(normalizePath(selectedPath), normalizePath(root.path))
      );
      
      if (hasSubfolderRoot) {
        event.sender.send("root-folder-error", {
          error: "An existing root folder is a subfolder of this folder",
          path: selectedPath
        });
        return;
      }
      
      // Add to root folders array
      const newRoot = {
        id: generateRootId(),
        path: selectedPath,
        name: path.basename(selectedPath),
        isExpanded: true
      };
      
      rootFolders.push(newRoot);
      
      console.log("Added new root folder:", newRoot);
      event.sender.send("root-folder-added", newRoot);
    } catch (err) {
      console.error("Error adding root folder:", err);
      event.sender.send("root-folder-error", {
        error: err.message,
        path: selectedPath
      });
    }
  }
});

// Handle removal of a root folder
ipcMain.on("remove-root-folder", (event, rootId) => {
  console.log(`Removing root folder with ID: ${rootId}`);
  
  const initialLength = rootFolders.length;
  clearRootState(rootId);
  
  if (rootFolders.length < initialLength) {
    console.log(`Successfully removed root folder with ID: ${rootId}`);
    event.sender.send("root-folder-removed", {
      rootId,
      remainingRoots: rootFolders
    });
    
    // Send state cleanup event
    event.sender.send("state-cleanup", {
      type: "root-removed",
      rootId
    });
  } else {
    console.error(`Root folder with ID ${rootId} not found`);
    event.sender.send("root-folder-error", {
      error: "Root folder not found",
      rootId
    });
  }
});

// Handle removal of all root folders
ipcMain.on("remove-all-root-folders", (event) => {
  const initialLength = rootFolders.length;
  clearAllState();
  
  console.log(`Removed all root folders (${initialLength} folders)`);
  event.sender.send("root-folders-all-removed");
  
  // Send state cleanup event
  event.sender.send("state-cleanup", {
    type: "all-roots-removed"
  });
});

// Add clear cache handler
ipcMain.on("clear-cache", (event) => {
  clearCache();
  
  // Send cache cleared event
  event.sender.send("cache-cleared");
  
  // Send state cleanup event
  event.sender.send("state-cleanup", {
    type: "cache-cleared"
  });
});

/**
 * Parse .gitignore files if they exist and create an ignore filter
 * Handles path normalization for cross-platform compatibility
 * Finds and consolidates patterns from all .gitignore files in the project
 * 
 * @param {string} rootDir - The root directory containing .gitignore files
 * @param {Electron.WebContents|Electron.IpcMainEvent} [sender] - Event or WebContents to send status updates to
 * @returns {Promise<object>} - Configured ignore filter
 */
async function loadGitignore(rootDir, sender) {
  console.log(`Loading gitignore patterns for ${rootDir}`);
  
  // Only send status updates if we're still in the initial loading phase or explicitly handling gitignore files
  const shouldSendUpdates = isLoadingDirectory || isHandlingGitignore;
  
  // Set the gitignore handling flag
  isHandlingGitignore = true;
  
  // Send processing status update if we have a sender and should send updates
  const sendStatusUpdate = (message) => {
    try {
      if (sender && shouldSendUpdates) {
        const statusUpdate = {
          status: "processing",
          message: message
        };
        
        // Handle both WebContents and IpcMainEvent objects
        if (sender.send) {
          sender.send("file-processing-status", statusUpdate);
        } else if (sender.webContents && sender.webContents.send) {
          sender.webContents.send("file-processing-status", statusUpdate);
        }
      }
    } catch (err) {
      console.error("Error sending gitignore status update:", err);
    }
  };
  
  if (shouldSendUpdates) {
    sendStatusUpdate("Finding and parsing .gitignore files...");
  }
  
  // Create a default ignore filter
  let ig;
  
  try {
    ig = ignore();
  } catch (err) {
    console.error("Error creating ignore filter:", err);
    // Reset the gitignore handling flag
    isHandlingGitignore = false;
    // Return a simple fallback filter that doesn't ignore anything
    return {
      ignores: (path) => {
        console.log("Using fallback ignore filter for:", path);
        return false;
      }
    };
  }
  
  try {
    // Ensure root directory path is absolute and normalized
    rootDir = ensureAbsolutePath(rootDir);
    
    // Step 1: Find all .gitignore files in the project
    if (shouldSendUpdates) {
      sendStatusUpdate("Scanning for .gitignore files...");
    }
    const gitignoreFiles = await findAllGitignoreFiles(rootDir, 10, shouldSendUpdates ? sender : null);
    
    // Step 2: Consolidate patterns from all gitignore files
    let consolidatedPatterns = [];
    if (gitignoreFiles.length > 0) {
      if (shouldSendUpdates) {
        sendStatusUpdate(`Processing ${gitignoreFiles.length} .gitignore files...`);
      }
      consolidatedPatterns = await consolidateIgnorePatterns(gitignoreFiles, rootDir);
    } else {
      console.log(`No .gitignore files found in ${rootDir}, using only default ignores`);
    }
    
    // Step 3: Merge with default ignores and excluded files
    if (shouldSendUpdates) {
      sendStatusUpdate("Finalizing file exclusion patterns...");
    }
    const finalPatterns = mergeWithDefaultIgnores(consolidatedPatterns);
    
    // Step 4: Add all patterns to the ignore filter
    ig.add(finalPatterns);
    
    console.log(`Ignore filter configured with ${finalPatterns.length} patterns`);
    
    // Reset the gitignore handling flag
    isHandlingGitignore = false;
    
    return ig;
  } catch (err) {
    console.error("Error configuring ignore filter:", err);
    
    // Reset the gitignore handling flag
    isHandlingGitignore = false;
    
    // Return a simple fallback filter that doesn't ignore anything
    return {
      ignores: (path) => {
        console.log("Using fallback ignore filter with error:", path);
        return false;
      }
    };
  }
}

// Check if file is binary based on extension
function isBinaryFile(filePath) {
  const ext = path.extname(filePath).toLowerCase();
  return BINARY_EXTENSIONS.includes(ext);
}

// Additional function to detect binary files using content heuristics
function detectBinaryContent(buffer, sampleSize = 512) {
  // Check a small sample of the file for null bytes or non-UTF8 characters
  // This is a simple heuristic and not foolproof, but catches many binary files
  try {
    if (!buffer || buffer.length === 0) return false;
    
    // Check up to sampleSize bytes (or the whole buffer if smaller)
    const checkSize = Math.min(buffer.length, sampleSize);
    
    // Count null bytes and non-printable characters
    let nullCount = 0;
    let nonPrintableCount = 0;
    
    for (let i = 0; i < checkSize; i++) {
      const byte = buffer[i];
      if (byte === 0) nullCount++;
      // Check for non-printable characters (control characters except tabs, newlines)
      if ((byte < 9 || (byte > 10 && byte < 32)) && byte !== 13) {
        nonPrintableCount++;
      }
    }
    
    // If more than 1% nulls or 10% non-printable, likely binary
    return (nullCount / checkSize > 0.01) || (nonPrintableCount / checkSize > 0.1);
  } catch (err) {
    console.error("Error detecting binary content:", err);
    return false; // On error, assume not binary
  }
}

// Count tokens using tiktoken with o200k_base encoding
function countTokens(text) {
  // Simple fallback implementation if encoder fails
  if (!encoder) {
    return Math.ceil(text.length / 4);
  }

  try {
    // Remove any special tokens that might cause issues
    const cleanText = text.replace(/<\|endoftext\|>/g, '');
    const tokens = encoder.encode(cleanText);
    return tokens.length;
  } catch (err) {
    console.error("Error counting tokens:", err);
    // Fallback to character-based estimation on error
    return Math.ceil(text.length / 4);
  }
}

/**
 * Checks if a directory should be completely skipped
 * @param {string} dirName - The name of the directory to check
 * @returns {boolean} - True if the directory should be skipped
 */
function shouldSkipDirectory(dirName) {
  return SKIP_DIRS.includes(dirName);
}

/**
 * Recursively reads files from a directory with chunked processing and cancellation support.
 * Implements several performance and safety features:
 * - Processes files in small chunks to maintain UI responsiveness
 * - Supports immediate cancellation at any point
 * - Handles binary files and large files appropriately
 * - Respects .gitignore and custom exclusion patterns
 * - Provides progress updates to the UI
 * - Handles cross-platform path issues including UNC paths
 *
 * @param {string} dir - The directory to process
 * @param {string} rootDir - The root directory (used for relative path calculations)
 * @param {object} ignoreFilter - The ignore filter instance for file exclusions
 * @param {BrowserWindow} window - The Electron window instance for sending updates
 * @returns {Promise<Array>} Array of processed file objects
 */
async function readFilesRecursively(dir, rootDir, ignoreFilter, window, isRoot = false, rootId = null) {
  // Ensure rootId is consistently handled
  const effectiveRootId = rootId || generateRootId();
  
  if (!dir || !rootDir) {
    console.error("Invalid directory paths:", { dir, rootDir });
    return [];
  }

  // Normalize paths for consistency
  const normalizedDir = normalizePath(dir);
  const normalizedRootDir = normalizePath(rootDir);

  let results = [];
  let entries;

  try {
    entries = await fs.promises.readdir(normalizedDir, { withFileTypes: true });
  } catch (error) {
    console.error(`Error reading directory ${normalizedDir}:`, error);
    window?.webContents.send("file-processing-status", {
      status: "error",
      message: `Error reading directory: ${error.message}`,
      path: normalizedDir,
      rootId: effectiveRootId
    });
    return [];
  }

  // Update progress counters
  totalDirectoriesProcessed++;
  if (isRoot) {
    totalDirectoriesFound = 1; // Reset for new root
    totalFilesFound = 0;
    totalFilesProcessed = 0;
  }

  // Process each entry
  for (const entry of entries) {
    const fullPath = safePathJoin(normalizedDir, entry.name);
    
    // Skip if path is invalid or should be excluded
    if (!_isValidPath(fullPath) || shouldSkipDirectory(entry.name)) {
      continue;
    }

    // Apply gitignore filter
    const relativePath = makeRelativePath(normalizedRootDir, fullPath);
    if (ignoreFilter && ignoreFilter(relativePath)) {
      continue;
    }

    if (entry.isDirectory()) {
      totalDirectoriesFound++;
      
      // Process subdirectory
      const subResults = await readFilesRecursively(
        fullPath,
        normalizedRootDir,
        ignoreFilter,
        window,
        false,
        effectiveRootId // Pass the effective rootId to maintain consistency
      );
      
      // Add directory entry with rootId
      results.push({
        name: entry.name,
        path: fullPath,
        relativePath,
        isDirectory: true,
        children: [],
        rootId: effectiveRootId // Include rootId for directories
      });
      
      results = results.concat(subResults);
      
    } else if (entry.isFile()) {
      totalFilesFound++;
      
      try {
        const stats = await fs.promises.stat(fullPath);
        
        // Skip files that are too large
        if (stats.size > MAX_FILE_SIZE) {
          console.log(`Skipping large file: ${fullPath} (${stats.size} bytes)`);
          continue;
        }

        // Create file entry with rootId
        const fileEntry = {
          name: entry.name,
          path: fullPath,
          relativePath,
          isDirectory: false,
          size: stats.size,
          modifiedTime: stats.mtime,
          rootId: effectiveRootId // Include rootId for files
        };

        // Add binary flag for binary files
        if (isBinaryFile(fullPath)) {
          fileEntry.isBinary = true;
        }

        results.push(fileEntry);
        totalFilesProcessed++;

        // Send progress update
        if (window && totalFilesFound > 0) {
          window.webContents.send("file-processing-status", {
            status: "processing",
            processed: totalFilesProcessed,
            total: totalFilesFound,
            current: fullPath,
            rootId: effectiveRootId
          });
        }
      } catch (error) {
        console.error(`Error processing file ${fullPath}:`, error);
      }
    }
  }

  // Send completion status for root directory
  if (isRoot && window) {
    window.webContents.send("file-processing-status", {
      status: "complete",
      processed: totalFilesProcessed,
      total: totalFilesFound,
      rootId: effectiveRootId
    });
  }

  return results;
}

// Handle file list request
ipcMain.on("request-file-list", async (event, { folderPath, rootId = null }) => {
  if (!isLoadingDirectory) {
    console.log("Directory loading is not active");
    return;
  }

  const window = BrowserWindow.fromWebContents(event.sender);
  if (!window) {
    console.error("No window found for file list request");
    return;
  }

  try {
    // Reset progress counters for this request
    resetProgressCounters();

    // Load gitignore filter for this root
    const ignoreFilter = await loadGitignore(folderPath, event.sender);

    // Process the directory
    const files = await readFilesRecursively(
      folderPath,
      folderPath,
      ignoreFilter,
      window,
      true,
      rootId
    );

    if (!Array.isArray(files)) {
      console.error("Error: readFilesRecursively did not return an array");
      event.sender.send("file-list-data", {
        error: "Failed to read directory structure",
        files: [],
        rootId
      });
      return;
    }

    // Send the results back to the renderer
    event.sender.send("file-list-data", {
      files,
      rootId,
      error: null
    });

  } catch (error) {
    console.error("Error processing directory:", error);
    event.sender.send("file-list-data", {
      error: error.message || "Failed to process directory",
      files: [],
      rootId
    });
  }
});

/**
 * Checks if a file should be excluded by default, using glob matching and .gitignore patterns
 * This function implements the primary exclusion logic for determining which files to show.
 * 
 * Order of operations:
 * 1. Special handling for root directory and root files
 * 2. Check against common regex patterns for excluded files (fast path)
 * 3. Check against .gitignore patterns
 * 4. Check against default excluded file patterns
 * 
 * @param {string} filePath - The file path to check
 * @param {string} rootDir - The root directory
 * @returns {Promise<boolean>} - Whether the file should be excluded
 */
async function shouldExcludeByDefault(filePath, rootDir) {
  // Handle empty paths to prevent errors
  if (!filePath || !rootDir) {
    console.warn("shouldExcludeByDefault received empty path:", { filePath, rootDir });
    return false;
  }

  try {
    // Ensure both paths are normalized for consistent handling across platforms
    filePath = normalizePath(filePath);
    rootDir = normalizePath(rootDir);

    // Handle Windows drive letter case sensitivity
    if (process.platform === 'win32') {
      filePath = filePath.toLowerCase();
      rootDir = rootDir.toLowerCase();
    }

    // Check if the paths are on the same drive (Windows)
    if (process.platform === 'win32') {
      const fileDrive = filePath.slice(0, 2).toLowerCase();
      const rootDrive = rootDir.slice(0, 2).toLowerCase();
      
      if (fileDrive !== rootDrive) {
        console.log(`File on different drive: ${filePath} vs ${rootDir}`);
        return false; // Different drives, can't be excluded by relative patterns
      }
    }

    // Calculate the relative path
    // Use our safeRelativePath for proper cross-platform path handling
    const relativePath = safeRelativePath(rootDir, filePath);
    // Then normalize to forward slashes and make it a proper relative path
    const relativePathNormalized = makeRelativePath(relativePath);
    
    // Handle empty relative paths (root directory case)
    if (!relativePathNormalized || relativePathNormalized === '') {
      console.log("Root directory or empty path detected in shouldExcludeByDefault");
      return false; // Don't exclude the root directory itself
    }
    
    // Special handling for files directly in root (no path separators)
    if (!relativePathNormalized.includes('/') && !relativePathNormalized.includes('\\')) {
      // Check for specific root-level files that should be excluded
      const rootFilesToExclude = [
        'package-lock.json', 'yarn.lock', 'pnpm-lock.yaml', 
        '.gitignore', '.npmrc', '.prettierrc', '.eslintrc', 
        'tsconfig.json', '.babelrc'
      ];
      
      if (rootFilesToExclude.includes(relativePathNormalized)) {
        return true;
      }
      
      // We want to show files in the root directory by default
      return false;
    }
    
    // Check for common large/generated files that should be excluded using regex patterns from excluded-files.js
    // These are quick checks that don't require loading full patterns
    for (const pattern of excludedRegexPatterns) {
      if (pattern.test(relativePathNormalized)) {
        return true;
      }
    }
    
    // Debug log - only for certain paths to avoid spam
    if (relativePathNormalized.includes('node_modules') || 
        relativePathNormalized.includes('.git/') ||
        relativePathNormalized.endsWith('.min.js')) {
      console.log(`Checking if ${relativePathNormalized} should be excluded`);
    }
    
    // Load gitignore patterns for this root directory
    const gitignoreFilter = await loadGitignore(rootDir, null);
    
    // Check if the file is ignored by gitignore patterns
    if (gitignoreFilter && typeof gitignoreFilter.ignores === 'function') {
      try {
        if (gitignoreFilter.ignores(relativePathNormalized)) {
          if (relativePathNormalized.includes('node_modules') || 
              relativePathNormalized.includes('.git/') ||
              relativePathNormalized.endsWith('.min.js')) {
            console.log(`File excluded by gitignore: ${relativePathNormalized}`);
          }
          return true;
        }
      } catch (ignoreErr) {
        console.error(`Error checking gitignore for ${relativePathNormalized}:`, ignoreErr);
      }
    }
    
    // Finally, check against the default exclusion patterns
    try {
      const ig = ignore().add(excludedFiles);
      const shouldExclude = ig.ignores(relativePathNormalized);
      
      if (shouldExclude && (
          relativePathNormalized.includes('node_modules') || 
          relativePathNormalized.includes('.git/') ||
          relativePathNormalized.endsWith('.min.js'))) {
        console.log(`File excluded by patterns: ${relativePathNormalized}`);
      }
      
      return shouldExclude;
    } catch (ignoreError) {
      console.error("Error in ignore.ignores():", ignoreError);
      return false; // On ignore error, don't exclude the file
    }
  } catch (error) {
    console.error("Error in shouldExcludeByDefault:", error);
    return false; // On any error, don't exclude the file
  }
}

// Add a debug handler for file selection
ipcMain.on("debug-file-selection", (event, data) => {
  console.log("DEBUG - File Selection:", data);
});

/**
 * Handles the cancellation of directory loading operations.
 * Ensures clean cancellation by:
 * - Clearing all timeouts
 * - Resetting loading flags
 * - Notifying the UI immediately
 * 
 * @param {BrowserWindow} window - The Electron window instance to send updates to
 */
function cancelDirectoryLoading(window) {
  if (!isLoadingDirectory) return;
  
  console.log("Cancelling directory loading process immediately");
  isLoadingDirectory = false;
  
  if (loadingTimeoutId) {
    clearTimeout(loadingTimeoutId);
    loadingTimeoutId = null;
  }
  
  // Send cancellation message immediately
  window.webContents.send("file-processing-status", {
    status: "cancelled",
    message: "Directory loading cancelled",
  });
}

/**
 * Sets up a safety timeout for directory loading operations.
 * Prevents infinite loading by automatically cancelling after MAX_DIRECTORY_LOAD_TIME.
 * 
 * @param {BrowserWindow} window - The Electron window instance
 * @param {string} folderPath - The path being processed (for logging)
 */
function setupDirectoryLoadingTimeout(window, folderPath) {
  // Clear any existing timeout
  if (loadingTimeoutId) {
    clearTimeout(loadingTimeoutId);
  }
  
  // Set a new timeout
  loadingTimeoutId = setTimeout(() => {
    console.log(`Directory loading timed out after ${MAX_DIRECTORY_LOAD_TIME / 1000} seconds: ${folderPath}`);
    cancelDirectoryLoading(window);
  }, MAX_DIRECTORY_LOAD_TIME);
}

// Add IPC listener for theme changes
ipcMain.on("theme-changed", (event, theme) => {
  // Store the current theme
  currentTheme = theme;
  
  // Apply theme to DevTools if they're open
  syncDevToolsTheme(theme);
});

/**
 * Synchronizes the DevTools appearance with the application theme
 * @param {string} theme - The current theme ('light' or 'dark')
 */
function syncDevToolsTheme(theme) {
  // Only proceed if we're in development mode
  const isDev = process.env.NODE_ENV === "development";
  if (!isDev) {
    return; // DevTools aren't enabled in production
  }

  if (!mainWindow || mainWindow.isDestroyed()) return;
  
  // Ensure DevTools are open before trying to access them
  if (!mainWindow.webContents.isDevToolsOpened()) {
    console.log('DevTools not open, skipping theme sync');
    return;
  }
  
  const devTools = mainWindow.webContents.devToolsWebContents;
  if (!devTools) {
    console.log('DevTools WebContents not available');
    return;
  }
  
  try {
    console.log(`Applying ${theme} theme to DevTools`);
    
    // Apply dark theme CSS when in dark mode
    if (theme === 'dark') {
      devTools.insertCSS(`
        :root, :host {
          --toolbar-bg: #1e1e1e;
          --toolbar-color: #e8e8e8;
          --toolbar-border: #3e3e42;
          --searchable-view-bg: #252526;
          --input-bg: #333333;
          --input-color: #e8e8e8;
          --input-border: #3e3e42;
          --panel-bg: #1e1e1e;
          --panel-color: #e8e8e8;
          --panel-item-hover: #333333;
          --tab-selected-bg: #0e639c;
          --tab-selected-color: white;
          --search-match-bg: rgba(255, 255, 0, 0.2);
        }
        
        body.platform-windows .monospace, 
        body.platform-windows .source-code,
        body.platform-linux .monospace, 
        body.platform-linux .source-code,
        body.platform-mac .monospace, 
        body.platform-mac .source-code {
          font-family: Consolas, Menlo, Monaco, "Courier New", monospace !important;
        }

        .platform-windows #console-prompt .CodeMirror.CodeMirror-focused.cm-focused,
        .platform-linux #console-prompt .CodeMirror.CodeMirror-focused.cm-focused,
        .platform-mac #console-prompt .CodeMirror.CodeMirror-focused.cm-focused {
          background-color: #333333 !important;
        }
      `).catch(err => console.error('Error injecting dark mode CSS:', err));
      
      // Use executeJavaScript to add dark-mode class
      devTools.executeJavaScript(`
        document.documentElement.classList.add('dark-mode');
        document.body.classList.add('dark-mode');
      `).catch(err => console.error('Error adding dark-mode class:', err));
    } else {
      // Remove dark theme and reset to default light theme
      devTools.executeJavaScript(`
        document.documentElement.classList.remove('dark-mode');
        document.body.classList.remove('dark-mode');
      `).catch(err => console.error('Error removing dark-mode class:', err));
    }
  } catch (err) {
    console.error('Failed to sync DevTools theme:', err);
  }
}

// Reset the progress counters when starting a new directory scan
function resetProgressCounters() {
  totalFilesProcessed = 0;
  totalFilesFound = 0;
  totalDirectoriesProcessed = 0;
  totalDirectoriesFound = 0;
}

/**
 * Checks if any of the cached gitignore files have been modified
 * @param {string} rootDir - The root directory
 * @returns {Promise<boolean>} - Returns true if any files were modified
 */
async function checkGitignoreFilesChanged(rootDir) {
  if (!gitignoreCache.has(rootDir)) {
    return true; // No cache, consider it changed
  }
  
  const { timestamp, files } = gitignoreCache.get(rootDir);
  
  // Check if any of the cached files have been modified
  for (const filePath of files) {
    try {
      const stats = await fs.promises.stat(filePath);
      const lastModified = stats.mtimeMs;
      
      if (lastModified > timestamp) {
        console.log(`Gitignore file changed: ${filePath}`);
        return true;
      }
    } catch (err) {
      console.error(`Error checking file modification time for ${filePath}:`, err);
      // If we can't check, assume it changed
      return true; 
    }
  }
  
  return false;
}

/**
 * Find all .gitignore files in a project directory structure
 * @param {string} rootDir - The root directory to start searching from
 * @param {number} maxDepth - Maximum depth to search (default: 10)
 * @param {Electron.WebContents|Electron.IpcMainEvent} [sender] - Event or WebContents to send status updates to
 * @returns {Promise<Array<string>>} - Array of paths to .gitignore files
 */
async function findAllGitignoreFiles(rootDir, maxDepth = 10, sender = null) {
  console.log(`Finding all .gitignore files in ${rootDir} (max depth: ${maxDepth})`);
  
  // Only send updates if we're in initial loading or explicitly handling gitignore
  const shouldSendUpdates = isLoadingDirectory || isHandlingGitignore;
  
  // Send processing status update if we have a sender and should send updates
  const sendStatusUpdate = (message) => {
    try {
      if (sender && shouldSendUpdates) {
        const statusUpdate = {
          status: "processing",
          message: message
        };
        
        // Handle both WebContents and IpcMainEvent objects
        if (sender.send) {
          sender.send("file-processing-status", statusUpdate);
        } else if (sender.webContents && sender.webContents.send) {
          sender.webContents.send("file-processing-status", statusUpdate);
        }
      }
    } catch (err) {
      console.error("Error sending gitignore status update:", err);
    }
  };
  
  // Check the cache first
  const cacheKey = rootDir;
  if (gitignoreCache.has(cacheKey)) {
    const { timestamp, files } = gitignoreCache.get(cacheKey);
    
    if (shouldSendUpdates) {
      sendStatusUpdate("Checking for changes in .gitignore files...");
    }
    
    // Check if files have been modified
    const filesChanged = await checkGitignoreFilesChanged(rootDir);
    
    // Use cached results if they're not too old and files haven't changed
    if (Date.now() - timestamp < GITIGNORE_CACHE_MAX_AGE && !filesChanged) {
      console.log(`Using cached gitignore files for ${rootDir} (${files.length} files)`);
      return files;
    }
    if (filesChanged) {
      console.log(`Gitignore files changed, rescanning for ${rootDir}`);
      if (shouldSendUpdates) {
        sendStatusUpdate("Detected changes in .gitignore files, rescanning...");
      }
    } else {
      console.log(`Cache expired for ${rootDir}, rescanning for gitignore files`);
      if (shouldSendUpdates) {
        sendStatusUpdate("Refreshing .gitignore cache...");
      }
    }
  }

  const gitignoreFiles = [];
  const dirsToSkip = new Set(SKIP_DIRS);
  
  if (shouldSendUpdates) {
    sendStatusUpdate("Scanning directories for .gitignore files...");
  }
  
  // Helper function to recursively find gitignore files
  async function findGitignoreInDir(dir, currentDepth = 0) {
    if (currentDepth > maxDepth) {
      return; // Stop if we've reached the maximum depth
    }
    
    // Check if we should skip this directory
    const dirName = basename(dir);
    if (dirsToSkip.has(dirName)) {
      return; // Skip this directory
    }
    
    try {
      // Check if there's a .gitignore file in this directory
      const gitignorePath = safePathJoin(dir, '.gitignore');
      try {
        await fs.promises.access(gitignorePath, fs.constants.F_OK);
        gitignoreFiles.push(gitignorePath);
        if (shouldSendUpdates) {
          sendStatusUpdate(`Found .gitignore in ${dirName}`);
        }
      } catch (e) {
        // No .gitignore in this directory, continue
      }
      
      // Read the directory entries
      const entries = await fs.promises.readdir(dir, { withFileTypes: true });
      
      // Process subdirectories
      for (const entry of entries) {
        if (entry.isDirectory() && !dirsToSkip.has(entry.name)) {
          await findGitignoreInDir(safePathJoin(dir, entry.name), currentDepth + 1);
        }
      }
    } catch (err) {
      console.error(`Error scanning directory ${dir} for gitignore files:`, err);
    }
  }
  
  try {
    if (shouldSendUpdates) {
      sendStatusUpdate("Starting deep scan for .gitignore files...");
    }
    await findGitignoreInDir(rootDir);
    
    // Update the cache with the newly found files
    gitignoreCache.set(cacheKey, {
      timestamp: Date.now(),
      files: gitignoreFiles
    });
    
    console.log(`Found ${gitignoreFiles.length} .gitignore files in ${rootDir}`);
    return gitignoreFiles;
  } catch (error) {
    console.error("Error finding gitignore files:", error);
    if (shouldSendUpdates) {
      sendStatusUpdate("Error finding .gitignore files");
    }
    return [];
  }
}

/**
 * Read and parse a gitignore file
 * @param {string} filePath - Path to the gitignore file
 * @param {string} rootDir - The root directory of the project
 * @returns {Object} - Object containing patterns and metadata
 */
async function readGitignoreFile(filePath, rootDir) {
  try {
    const content = await fs.promises.readFile(filePath, 'utf8');
    const dirPath = dirname(filePath);
    const relativeDir = safeRelativePath(rootDir, dirPath);
    const normalizedRelativeDir = normalizePath(relativeDir);
    
    // Parse patterns from the file
    const patterns = content
      .split(/\r?\n/)
      .map(line => line.trim())
      .filter(line => line && !line.startsWith('#')); // Remove comments and empty lines
    
    return {
      path: filePath,
      dirPath,
      relativeDir: normalizedRelativeDir,
      patterns,
      isRootGitignore: dirPath === rootDir
    };
  } catch (err) {
    console.error(`Error reading gitignore file ${filePath}:`, err);
    return {
      path: filePath,
      dirPath: dirname(filePath),
      patterns: [],
      error: err.message
    };
  }
}

/**
 * Consolidate patterns from multiple gitignore files
 * @param {Array<string>} gitignoreFiles - Array of paths to gitignore files
 * @param {string} rootDir - The root directory of the project
 * @returns {Promise<Array<string>>} - Consolidated list of unique patterns
 */
async function consolidateIgnorePatterns(gitignoreFiles, rootDir) {
  console.log(`Consolidating patterns from ${gitignoreFiles.length} gitignore files`);
  
  // Map to store unique patterns with their sources
  const patternMap = new Map();
  // Set to track patterns that should be negated
  const negatedPatterns = new Set();
  
  // Process each gitignore file
  for (const filePath of gitignoreFiles) {
    const gitignoreData = await readGitignoreFile(filePath, rootDir);
    const { patterns, relativeDir, isRootGitignore } = gitignoreData;
    
    if (patterns.length === 0) continue;
    
    console.log(`Processing ${patterns.length} patterns from ${filePath}`);
    
    // Process each pattern
    for (let pattern of patterns) {
      // Handle negation
      const isNegated = pattern.startsWith('!');
      if (isNegated) {
        pattern = pattern.substring(1);
      }
      
      // Normalize pattern
      let normalizedPattern = normalizePath(pattern);
      
      // For non-root gitignore files, adjust patterns to be relative to the root
      if (!isRootGitignore && relativeDir && !pattern.startsWith('/')) {
        // Don't prefix if the pattern is already absolute or explicitly specific to its directory
        if (!pattern.includes('/')) {
          // Pattern applies to any file with this name in any subdirectory
          // Keep it as is
        } else {
          // Pattern is relative to the gitignore file's directory
          normalizedPattern = path.posix.join(relativeDir, normalizedPattern);
        }
      }
      
      // Store pattern with its source for debugging
      if (isNegated) {
        negatedPatterns.add(normalizedPattern);
      } else {
        patternMap.set(normalizedPattern, {
          source: filePath,
          original: pattern
        });
      }
    }
  }
  
  // Create the final list of patterns
  const consolidatedPatterns = [];
  
  // Add non-negated patterns
  for (const [pattern, metadata] of patternMap.entries()) {
    if (!negatedPatterns.has(pattern)) {
      consolidatedPatterns.push(pattern);
    }
  }
  
  // Add negated patterns last so they take precedence
  negatedPatterns.forEach(pattern => {
    consolidatedPatterns.push(`!${pattern}`);
  });
  
  console.log(`Consolidated to ${consolidatedPatterns.length} unique patterns`);
  // Log some sample patterns for debugging
  if (consolidatedPatterns.length > 0) {
    console.log("Sample consolidated patterns:", consolidatedPatterns.slice(0, 5));
  }
  
  return consolidatedPatterns;
}

/**
 * Merge consolidated gitignore patterns with default exclusion patterns
 * @param {Array<string>} consolidatedPatterns - Patterns from gitignore files
 * @returns {Array<string>} - Final merged patterns with duplicates removed
 */
function mergeWithDefaultIgnores(consolidatedPatterns) {
  // Get the default patterns from excluded-files.js
  const defaultIgnores = defaultIgnorePatterns;
  
  // Get patterns from excluded-files.js
  const excludedFilesPatterns = Array.isArray(excludedFiles) ? [...excludedFiles] : [];
  
  // Use a Set to remove exact duplicates
  const uniquePatterns = new Set([
    ...defaultIgnores,
    ...excludedFilesPatterns,
    ...consolidatedPatterns
  ]);
  
  // Convert back to array and log some stats
  const mergedPatterns = [...uniquePatterns];
  
  console.log(`Merged patterns - Total: ${mergedPatterns.length}`);
  console.log(`- Default: ${defaultIgnores.length}`);
  console.log(`- From excluded-files.js: ${excludedFilesPatterns.length}`);
  console.log(`- From gitignore files: ${consolidatedPatterns.length}`);
  console.log(`- Unique after merging: ${mergedPatterns.length}`);
  
  return mergedPatterns;
}

// Add isValidPath function for backward compatibility
// This should be removed when we're confident everything uses the shared module
function _isValidPath(pathToCheck) {
  try {
    return isValidPath(pathToCheck);
  } catch (err) {
    return false;
  }
}

// Handle directory loading cancellation
ipcMain.on("cancel-directory-loading", (event) => {
  console.log("Directory loading cancelled by user");
  
  // Set the loading flag to false to stop any ongoing operations
  isLoadingDirectory = false;
  isHandlingGitignore = false;
  
  // Clear any loading timeout
  if (loadingTimeoutId) {
    clearTimeout(loadingTimeoutId);
    loadingTimeoutId = null;
  }
  
  // Notify the renderer that the operation was cancelled
  event.sender.send("file-processing-status", {
    status: "cancelled",
    message: "Operation cancelled by user",
  });
});

// State cleanup functions
function clearRootState(rootId) {
  console.log(`Clearing state for root: ${rootId}`);
  
  // Clear gitignore cache for this root
  const rootFolder = rootFolders.find(r => r.id === rootId);
  if (rootFolder) {
    gitignoreCache.delete(rootFolder.path);
  }
  
  // Reset processing state if this was the last root
  if (rootFolders.length <= 1) {
    resetProgressCounters();
    isLoadingDirectory = false;
    isHandlingGitignore = false;
  }
  
  // Remove from rootFolders array
  rootFolders = rootFolders.filter(root => root.id !== rootId);
}

function clearAllState() {
  console.log("Clearing all application state");
  
  // Clear all root folders
  rootFolders = [];
  
  // Clear all caches
  gitignoreCache.clear();
  
  // Reset all processing state
  resetProgressCounters();
  isLoadingDirectory = false;
  isHandlingGitignore = false;
  
  if (loadingTimeoutId) {
    clearTimeout(loadingTimeoutId);
    loadingTimeoutId = null;
  }
}

function clearCache() {
  console.log("Clearing all caches and temporary data");
  
  // Clear gitignore cache
  gitignoreCache.clear();
  
  // Clear any file system caches
  if (mainWindow) {
    mainWindow.webContents.session.clearCache();
  }
  
  // Reset processing state
  resetProgressCounters();
  isLoadingDirectory = false;
  isHandlingGitignore = false;
  
  if (loadingTimeoutId) {
    clearTimeout(loadingTimeoutId);
    loadingTimeoutId = null;
  }
}

```

File: /Users/haikalp/Documents/Code/Projects/pastemax-forked/preload.js
```js
// Preload script
const { contextBridge, ipcRenderer } = require("electron");

// Helper function to ensure data is serializable
function ensureSerializable(data) {
  if (data === null || data === undefined) {
    return data;
  }

  // Handle primitive types directly
  if (typeof data !== "object") {
    return data;
  }

  // For arrays, map each item
  if (Array.isArray(data)) {
    return data.map(ensureSerializable);
  }

  // For objects, create a new object with serializable properties
  const result = {};
  for (const key in data) {
    if (Object.prototype.hasOwnProperty.call(data, key)) {
      // Skip functions or symbols which are not serializable
      if (typeof data[key] === "function" || typeof data[key] === "symbol") {
        continue;
      }
      // Recursively process nested objects
      result[key] = ensureSerializable(data[key]);
    }
  }
  return result;
}

// Expose protected methods that allow the renderer process to use
// the ipcRenderer without exposing the entire object
contextBridge.exposeInMainWorld("electron", {
  send: (channel, data) => {
    // List of valid channels for sending messages to main process
    const validChannels = ["open-folder", "request-file-list", "debug-file-selection", "cancel-directory-loading", "theme-changed", "add-root-folder", "remove-root-folder", "remove-all-root-folders"];
    if (validChannels.includes(channel)) {
      // Ensure data is serializable before sending
      const serializedData = ensureSerializable(data);
      ipcRenderer.send(channel, serializedData);
    }
  },
  receive: (channel, func) => {
    // List of valid channels for receiving messages from main process
    const validReceiveChannels = ["folder-selected", "file-list-data", "file-processing-status", "app-error", "startup-mode", "root-folder-added", "root-folder-removed", "root-folder-error", "root-folders-all-removed"];
    if (validReceiveChannels.includes(channel)) {
      // Remove any existing listeners to avoid duplicates
      ipcRenderer.removeAllListeners(channel);
      // Add the new listener
      ipcRenderer.on(channel, (event, ...args) => func(...args));
    }
  },
  // For backward compatibility (but still ensure serialization)
  ipcRenderer: {
    send: (channel, data) => {
      const validChannels = ["open-folder", "request-file-list", "debug-file-selection", "cancel-directory-loading", "theme-changed", "add-root-folder", "remove-root-folder"];
      if (validChannels.includes(channel)) {
        const serializedData = ensureSerializable(data);
        ipcRenderer.send(channel, serializedData);
      }
    },
    on: (channel, func) => {
      const wrapper = (event, ...args) => {
        try {
          // Don't pass the event object to the callback, only pass the serialized args
          const serializedArgs = args.map(ensureSerializable);
          func(...serializedArgs); // Only pass the serialized args, not the event
        } catch (err) {
          console.error(`Error in IPC handler for channel ${channel}:`, err);
        }
      };
      ipcRenderer.on(channel, wrapper);
      // Store the wrapper function for removal later
      return wrapper;
    },
    removeListener: (channel, func) => {
      // List of valid channels for receiving messages from main process
      const validReceiveChannels = ["folder-selected", "file-list-data", "file-processing-status", "app-error", "startup-mode", "root-folder-added", "root-folder-removed", "root-folder-error", "root-folders-all-removed"];
      if (validReceiveChannels.includes(channel)) {
        ipcRenderer.removeListener(channel, func);
      }
    },
  },
});

```

File: /Users/haikalp/Documents/Code/Projects/pastemax-forked/package.json
```json
{
  "name": "pastemax",
  "version": "1.3.0",
  "main": "main.js",
  "scripts": {
    "start": "electron .",
    "dev": "vite",
    "dev:electron": "cross-env NODE_ENV=development node dev.js",
    "clean": "rimraf \"node_modules\" \"dist\" \"release-builds\"",
    "clean:dist": "rimraf \"dist\" \"release-builds\"",
    "build": "npm run clean:dist && vite build",
    "build-electron": "npm run clean:dist && cross-env NODE_ENV=production node build.js",
    "verify-build": "node scripts/verify-build.js",
    "test-build": "node scripts/test-local-build.js",
    "test-build:mac": "node scripts/test-local-build.js mac",
    "test-build:win": "node scripts/test-local-build.js win",
    "test-build:linux": "node scripts/test-local-build.js linux",
    "test-gitignore": "node scripts/test-gitignore.js",
    "test-gitignore:cross": "node scripts/test-gitignore-crossplatform.js",
    "debug-gh-release": "cross-env-shell \"git tag debug-v$(node -e \"console.log(new Date().toISOString().replace(/[:.]/g, '').split('T').join(''));\")\" && git push origin --tags",
    "package": "npm run clean:dist && cross-env NODE_ENV=production vite build && electron-builder --publish=never",
    "package:mac": "npm run clean:dist && cross-env NODE_ENV=production vite build && electron-builder --mac --publish=never",
    "package:win": "npm run clean:dist && cross-env NODE_ENV=production vite build && electron-builder --win --publish=never",
    "package:linux": "npm run clean:dist && cross-env NODE_ENV=production vite build && electron-builder --linux --publish=never",
    "package:all": "npm run clean:dist && cross-env NODE_ENV=production vite build && electron-builder -mwl --publish=never",
    "release": "npm run clean:dist && cross-env NODE_ENV=production vite build && electron-builder --publish=onTagOrDraft",
    "lint": "eslint . --ext ts,tsx --report-unused-disable-directives",
    "lint:strict": "eslint . --ext ts,tsx --report-unused-disable-directives --max-warnings 0",
    "preview": "vite preview"
  },
  "keywords": [
    "clipboard",
    "code",
    "developer-tools",
    "electron",
    "file-viewer"
  ],
  "author": {
    "name": "kleneway",
    "email": "kleneway@notreal.com"
  },
  "license": "MIT",
  "description": "A modern file viewer application for developers to easily navigate, search, and copy code from repositories.",
  "build": {
    "appId": "com.kleneway.pastemax",
    "productName": "PasteMax",
    "directories": {
      "output": "release-builds"
    },
    "files": [
      "dist/**/*",
      "main.js",
      "preload.js",
      "excluded-files.js",
      "node_modules/**/*"
    ],
    "mac": {
      "category": "public.app-category.developer-tools",
      "icon": "public/favicon.icns",
      "target": [
        "dmg",
        "zip"
      ],
      "hardenedRuntime": true,
      "gatekeeperAssess": false,
      "entitlements": "build/entitlements.mac.plist",
      "entitlementsInherit": "build/entitlements.mac.plist"
    },
    "win": {
      "target": [
        "nsis",
        "portable"
      ],
      "icon": "public/favicon.ico"
    },
    "linux": {
      "target": [
        "AppImage",
        "deb",
        "rpm"
      ],
      "category": "Development",
      "icon": "public/favicon.png"
    },
    "asarUnpack": [
      "node_modules/ignore/**",
      "node_modules/tiktoken/**",
      "node_modules/gpt-3-encoder/**"
    ],
    "asar": true,
    "afterSign": "scripts/notarize.js",
    "publish": [
      "github"
    ],
    "protocols": {
      "name": "pastemax-protocol",
      "schemes": [
        "pastemax"
      ]
    }
  },
  "devDependencies": {
    "@electron/notarize": "^2.5.0",
    "@types/node": "^20.10.5",
    "@types/react": "^18.2.43",
    "@types/react-dom": "^18.2.17",
    "@typescript-eslint/eslint-plugin": "^6.14.0",
    "@typescript-eslint/parser": "^6.14.0",
    "@vitejs/plugin-react": "^4.2.1",
    "cross-env": "^7.0.3",
    "electron": "^34.3.0",
    "electron-builder": "^24.13.3",
    "eslint": "^8.55.0",
    "eslint-plugin-react-hooks": "^4.6.0",
    "eslint-plugin-react-refresh": "^0.4.5",
    "rimraf": "^5.0.5",
    "typescript": "^5.3.3",
    "vite": "^5.0.8"
  },
  "dependencies": {
    "gpt-3-encoder": "^1.1.4",
    "ignore": "^7.0.3",
    "lucide-react": "^0.477.0",
    "react": "^18.2.0",
    "react-dom": "^18.2.0",
    "tiktoken": "^1.0.20"
  }
}

```
</file_contents>

<meta prompt 1 = "[Architect]">
You are a senior software architect specializing in code design and implementation planning. Your role is to:

1. Analyze the requested changes and break them down into clear, actionable steps
2. Create a detailed implementation plan that includes:
   - Files that need to be modified
   - Specific code sections requiring changes
   - New functions, methods, or classes to be added
   - Dependencies or imports to be updated
   - Data structure modifications
   - Interface changes
   - Configuration updates

For each change:
- Describe the exact location in the code where changes are needed
- Explain the logic and reasoning behind each modification
- Provide example signatures, parameters, and return types
- Note any potential side effects or impacts on other parts of the codebase
- Highlight critical architectural decisions that need to be made

You may include short code snippets to illustrate specific patterns, signatures, or structures, but do not implement the full solution.

Focus solely on the technical implementation plan - exclude testing, validation, and deployment considerations unless they directly impact the architecture.

Please proceed with your analysis based on the following <user instrctions>
</meta prompt 1>
<user_instructions>
Can you help me find the issue with my program? You can look into the package.json to understand dependencies it uses.
We should plan this out first, brainstorm and find issues.
</user_instructions>
