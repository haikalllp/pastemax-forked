<file_map>
E:\CODING\Projects\CODE\pastemax-priv
├── docs
│   └── update.md
├── src
│   ├── components
│   │   ├── Sidebar.tsx
│   │   ├── TreeItem.tsx
│   │   └── UserInstructions.tsx
│   ├── styles
│   │   └── index.css
│   ├── utils
│   │   └── pathUtils.ts
│   ├── App.tsx
│   └── main.tsx
├── package.json
├── preload.js
└── vite.config.ts

</file_map>



// ---- File: index.css ----

/**
 * PasteMax Application Styles
 * A comprehensive stylesheet for the PasteMax app, organized by logical sections.
 * 
 * Table of Contents:
 * 1. Variables & Theme
 * 2. Global Styles & Scrollbars
 * 3. Base Elements
 * 4. Layout Components
 * 5. Sidebar Components
 * 6. File Tree & List Components
 * 7. Content Area & Cards
 * 8. UI Controls & Buttons
 * 9. User Instructions Area
 * 10. Utilities & Animations
 */

/*--------------------------------------------------------------
1. Variables & Theme
--------------------------------------------------------------*/

/* Light Theme Variables */
:root {
  --background-primary: #ffffff;
  --background-secondary: #f8f8f8;
  --background-selected: rgba(0, 0, 0, 0.06);
  --accent-blue: #0e639c;
  --border-color: #e0e0e0;
  --hover-color: #f5f5f5;
  --text-primary: #000000;
  --text-secondary: #666666;
  --text-disabled: #cccccc;
  --icon-color: #555555;
  --success-color: #2ecc71;
  --warning-color: #f39c12;
  --error-color: #e74c3c;
  --primary-button-background: #000000;
  --primary-button-text: #ffffff;
}

/* Dark Theme Variables */
.dark-mode {
  --background-primary: #1e1e1e;
  --background-secondary: #252526;
  --background-selected: #2a2d2e;
  --accent-blue: #0e639c;
  --border-color: #3e3e42;
  --hover-color: #333333;
  --text-primary: #e8e8e8;
  --text-secondary: #bbbbbb;
  --text-disabled: #808080;
  --icon-color: #cccccc;
  --success-color: #2ecc71;
  --warning-color: #f39c12;
  --error-color: #e74c3c;
  --primary-button-background: #0e639c;
  --primary-button-text: #ffffff;
}

/*--------------------------------------------------------------
2. Global Styles & Scrollbars
--------------------------------------------------------------*/

/* Base element styling */
* {
  box-sizing: border-box;
  margin: 0;
  padding: 0;
  scrollbar-width: thin;
  scrollbar-color: var(--border-color) transparent;
}

/* Custom scrollbar styling for Webkit browsers (Chrome, Safari, Edge) */
*::-webkit-scrollbar {
  width: 8px;
  height: 8px;
}

*::-webkit-scrollbar-track {
  background: transparent;
}

*::-webkit-scrollbar-thumb {
  background-color: var(--border-color);
  border-radius: 4px;
}

*::-webkit-scrollbar-thumb:hover {
  background-color: var(--text-secondary);
}

/* Dark mode scrollbar adjustments */
.dark-mode *::-webkit-scrollbar-thumb {
  background-color: #555;
}

.dark-mode *::-webkit-scrollbar-thumb:hover {
  background-color: #777;
}

/* Body and main container elements */
body {
  font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica,
    Arial, sans-serif;
  margin: 0;
  padding: 0;
  background-color: var(--background-primary);
  color: var(--text-primary);
  line-height: 1.5;
  height: 100vh;
  overflow: hidden;
}

#root {
  height: 100vh;
  display: flex;
  flex-direction: column;
}

.app-container {
  display: flex;
  flex-direction: column;
  height: 100%;
  overflow: hidden;
}

/*--------------------------------------------------------------
3. Base Elements
--------------------------------------------------------------*/

/* Button styling */
button {
  cursor: pointer;
  font-family: inherit;
  border: 1px solid var(--border-color);
  background-color: var(--background-primary);
  font-size: 14px;
  display: inline-flex;
  align-items: center;
  justify-content: center;
  gap: 8px;
  padding: 8px 16px;
  border-radius: 4px;
  transition: all 0.2s ease;
  white-space: nowrap;
  font-weight: 500;
  color: var(--text-primary);
}

button:hover {
  background-color: var(--hover-color);
}

button:focus {
  outline: 2px solid var(--accent-blue);
  outline-offset: 1px;
}

/* Primary button styling */
button.primary {
  background-color: var(--primary-button-background);
  color: var(--primary-button-text);
  border-color: var(--primary-button-background);
}

button.primary:hover {
  background-color: var(--primary-button-background);
}

button:disabled {
  opacity: 0.5;
  cursor: not-allowed;
}

/* Form inputs styling */
input[type="text"],
input[type="search"] {
  padding: 8px 12px;
  border: 1px solid var(--border-color);
  border-radius: 4px;
  font-family: inherit;
  font-size: 14px;
  outline: none;
  width: 100%;
  background-color: var(--background-primary);
  color: var(--text-primary);
}

input[type="text"]:focus,
input[type="search"]:focus {
  border-color: var(--accent-blue);
  box-shadow: 0 0 0 1px var(--accent-blue);
}

/* Monospace text for code-related elements */
.monospace {
  font-family: Consolas, Menlo, Monaco, "Courier New", monospace;
  font-size: 13px;
  line-height: 1.5;
}

/*--------------------------------------------------------------
4. Layout Components
--------------------------------------------------------------*/

/* Main layout containers */
.app-container {
  display: flex;
  flex-direction: column;
  height: 100vh;
}

/* App header styling */
.header {
  padding: 16px 24px;
  border-bottom: 1px solid var(--border-color);
  display: flex;
  align-items: center;
  justify-content: space-between;
  background-color: var(--background-primary);
}

.header h1 {
  font-size: 20px;
  font-weight: 600;
  margin: 0;
  color: var(--text-primary);
}

/* Folder selection display */
.folder-info {
  display: flex;
  align-items: center;
  gap: 16px;
}

.selected-folder {
  padding: 6px 12px;
  border-radius: 4px;
  background-color: var(--hover-color);
  max-width: 300px;
  overflow: hidden;
  text-overflow: ellipsis;
  white-space: nowrap;
  color: var(--text-secondary);
}

.select-folder-btn {
  background-color: var(--background-primary);
  border: 1px solid var(--border-color);
  color: var(--text-primary);
  padding: 8px 16px;
  font-weight: 500;
}

.select-folder-btn:hover {
  background-color: var(--hover-color);
}

/* Main content area */
.main-content {
  display: flex;
  flex: 1;
  overflow: hidden;
  height: 100%;
}

/*--------------------------------------------------------------
5. Sidebar Components
--------------------------------------------------------------*/

/* Sidebar container */
.sidebar {
  width: 300px;
  min-width: 200px;
  max-width: 500px;
  height: 100%;
  display: flex;
  flex-direction: column;
  border-right: 1px solid var(--border-color);
  overflow: hidden;
  background-color: var(--background-secondary);
  position: relative;
  transition: width 0.1s ease;
}

/* Sidebar header */
.sidebar-header {
  padding: 16px;
  border-bottom: 1px solid var(--border-color);
  background-color: var(--background-secondary);
}

.sidebar-title {
  font-size: 18px;
  font-weight: 600;
  margin-bottom: 8px;
  color: var(--text-primary);
}

.sidebar-folder-path {
  font-size: 12px;
  color: var(--text-secondary);
  overflow: hidden;
  text-overflow: ellipsis;
  white-space: nowrap;
}

/* Sidebar search box */
.sidebar-search {
  padding: 12px 16px;
  border-bottom: 1px solid var(--border-color);
  background-color: var(--background-secondary);
}

/* Sidebar action buttons */
.sidebar-actions {
  display: flex;
  padding: 12px 16px;
  gap: 8px;
  border-bottom: 1px solid var(--border-color);
  background-color: var(--background-secondary);
}

.sidebar-action-btn {
  flex: 1;
  font-size: 13px;
  padding: 6px 12px;
  background-color: var(--background-primary);
  color: var(--text-primary);
  border: 1px solid var(--border-color);
}

/* Sidebar resize handle */
.sidebar-resize-handle {
  position: absolute;
  top: 0;
  right: -5px;
  width: 10px;
  height: 100%;
  cursor: col-resize;
  z-index: 10;
  opacity: 0;
}

.sidebar-resize-handle:hover,
.sidebar-resize-handle:active {
  opacity: 1;
  background-color: rgba(0, 0, 0, 0.1);
}

/* Selected folder display */
.selected-folder {
  font-size: 14px;
  color: var(--text-secondary);
  overflow: hidden;
  text-overflow: ellipsis;
  white-space: nowrap;
  max-width: 500px;
  display: inline-block;
}

/*--------------------------------------------------------------
6. File Tree & List Components
--------------------------------------------------------------*/

/* File tree container */
.file-tree {
  flex: 1;
  overflow-y: auto;
  padding: 8px 0;
  background-color: var(--background-secondary);
}

/* Empty tree state */
.tree-empty {
  padding: 16px;
  text-align: center;
  color: var(--text-secondary);
  font-size: 14px;
}

/* Loading state */
.tree-loading {
  display: flex;
  flex-direction: column;
  align-items: center;
  justify-content: center;
  padding: 24px 16px;
  gap: 12px;
  color: var(--text-secondary);
}

.tree-loading .spinner {
  width: 24px;
  height: 24px;
}

/* Tree item styling */
.tree-item {
  display: flex;
  align-items: center;
  padding: 6px 8px;
  margin: 2px 0;
  border-radius: 4px;
  cursor: pointer;
  user-select: none;
  position: relative;
  transition: background-color 0.1s ease;
  color: var(--text-primary);
}

.tree-item:hover {
  background-color: var(--hover-color);
}

.tree-item.selected {
  background-color: var(--background-selected);
}

.tree-item-icon {
  margin-right: 8px;
  flex-shrink: 0;
  color: var(--icon-color);
}

.tree-item-content {
  display: flex;
  align-items: center;
  flex: 1;
  min-width: 0;
  overflow: hidden;
}

/* Tree item expansion toggle */
.tree-item-toggle {
  width: 20px;
  height: 20px;
  display: flex;
  align-items: center;
  justify-content: center;
  margin-right: 4px;
  cursor: pointer;
  color: var(--icon-color);
  z-index: 2;
}

.tree-item-toggle svg {
  transition: transform 0.15s ease-in-out;
  transform: rotate(0deg);
}

.tree-item-toggle.expanded svg {
  transform: rotate(90deg);
}

.tree-item-indent {
  width: 16px;
  flex-shrink: 0;
}

.tree-item-checkbox {
  margin-right: 8px;
  cursor: pointer;
}

.tree-item-name {
  flex: 1;
  min-width: 0;
  overflow: hidden;
  text-overflow: ellipsis;
  white-space: nowrap;
  color: var(--text-primary);
}

.tree-item-tokens {
  font-size: 11px;
  color: var(--text-secondary);
  margin-left: 6px;
  white-space: nowrap;
}

.tree-item-badge {
  font-size: 10px;
  padding: 1px 5px;
  border-radius: 4px;
  background-color: var(--hover-color);
  color: var(--text-secondary);
  margin-left: 6px;
  white-space: nowrap;
}

/* Empty states */
.tree-loading,
.empty-tree,
.empty-list {
  padding: 16px;
  text-align: center;
  color: var(--text-secondary);
  font-style: italic;
}

/*--------------------------------------------------------------
7. Content Area & Cards
--------------------------------------------------------------*/

/* Main content area */
.content-area {
  flex: 1;
  display: flex;
  flex-direction: column;
  overflow: hidden;
  background-color: var(--background-primary);
  min-width: 0;
}

/* Content header */
.content-header {
  display: flex;
  justify-content: space-between;
  align-items: center;
  padding: 16px 24px;
  border-bottom: 1px solid var(--border-color);
  background-color: var(--background-primary);
}

.content-title {
  font-size: 18px;
  font-weight: 600;
  color: var(--text-primary);
}

.content-actions {
  display: flex;
  align-items: center;
  gap: 16px;
}

/* Sort dropdown component */
.sort-dropdown {
  position: relative;
}

.sort-dropdown-button {
  display: flex;
  align-items: center;
  gap: 8px;
  font-size: 14px;
  color: var(--text-primary);
}

.sort-options {
  position: absolute;
  top: calc(100% + 4px);
  right: 0;
  background-color: var(--background-primary);
  border: 1px solid var(--border-color);
  border-radius: 4px;
  box-shadow: 0 2px 10px rgba(0, 0, 0, 0.1);
  z-index: 100;
  min-width: 180px;
}

.sort-option {
  padding: 8px 16px;
  cursor: pointer;
  transition: background-color 0.2s;
  color: var(--text-primary);
}

.sort-option:hover {
  background-color: var(--hover-color);
}

.sort-option.active {
  background-color: var(--background-selected);
  font-weight: 600;
  color: var(--accent-blue);
}

/* File statistics display */
.file-stats {
  font-size: 14px;
  color: var(--text-secondary);
}

/* File list container */
.file-list-container {
  flex: 1;
  overflow: hidden;
  display: flex;
  flex-direction: column;
}

.file-list {
  flex: 1;
  overflow-y: auto;
  padding: 16px;
  display: grid;
  grid-template-columns: repeat(auto-fill, minmax(220px, 1fr));
  grid-auto-rows: max-content;
  align-content: start;
  gap: 12px;
  background-color: var(--background-primary);
}

.file-list-empty {
  display: flex;
  align-items: center;
  justify-content: center;
  height: 100%;
  color: var(--text-secondary);
  font-size: 16px;
  padding: 32px;
  text-align: center;
}

/* File card component */
.file-card {
  display: flex;
  flex-direction: column;
  padding: 10px;
  border: 1px solid var(--border-color);
  border-radius: 4px;
  position: relative;
  transition: all 0.2s ease;
  height: 80px;
  background-color: var(--background-primary);
}

.file-card:hover {
  background-color: var(--hover-color);
  box-shadow: 0 2px 8px rgba(0, 0, 0, 0.05);
}

.file-card.selected {
  border: 2px solid var(--accent-blue);
  background-color: var(--background-selected);
}

.file-card-header {
  display: flex;
  align-items: center;
  margin-bottom: 8px;
}

.file-card-icon {
  margin-right: 8px;
  color: var(--icon-color);
  flex-shrink: 0;
}

.file-card-name {
  font-weight: 500;
  flex: 1;
  overflow: hidden;
  text-overflow: ellipsis;
  white-space: nowrap;
  color: var(--text-primary);
}

.file-card-info {
  display: flex;
  flex-direction: column;
  margin-bottom: 0;
}

.file-card-tokens {
  color: var(--text-secondary);
  font-size: 13px;
}

.file-card-status {
  font-size: 13px;
  color: var(--text-secondary);
}

/* File card hover actions */
.file-card-actions {
  position: absolute;
  top: 8px;
  right: 8px;
  display: flex;
  gap: 4px;
  opacity: 0;
  transition: opacity 0.2s ease;
}

.file-card:hover .file-card-actions {
  opacity: 1;
}

.file-card-action {
  width: 24px;
  height: 24px;
  padding: 0;
  display: flex;
  align-items: center;
  justify-content: center;
  background-color: var(--background-primary);
  border: 1px solid var(--border-color);
  border-radius: 4px;
  color: var(--icon-color);
  transition: all 0.15s ease;
  box-shadow: 0 1px 3px rgba(0, 0, 0, 0.05);
}

.file-card-action:hover {
  background-color: var(--hover-color);
  color: var(--accent-blue);
  border-color: var(--accent-blue);
  transform: translateY(-1px);
  box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
}

.file-card-action:active {
  transform: translateY(0);
  box-shadow: 0 1px 2px rgba(0, 0, 0, 0.1);
}

/*--------------------------------------------------------------
8. UI Controls & Buttons
--------------------------------------------------------------*/

/* Copy button container */
.copy-button-container {
  padding: 16px 24px;
  border-top: 1px solid var(--border-color);
  display: flex;
  justify-content: center;
  align-items: center;
  background-color: var(--background-primary);
}

/* Copy button styling */
.copy-button {
  display: flex;
  align-items: center;
  justify-content: center;
  padding: 10px 16px;
  font-weight: 600;
  border-radius: 4px;
  transition: all 0.2s ease;
  gap: 8px;
  border: none;
  cursor: pointer;
  color: var(--primary-button-text);
  background-color: var(--primary-button-background);
}

.copy-button.primary {
  background-color: var(--primary-button-background);
  color: var(--primary-button-text);
  border: none;
}

.copy-button.primary:hover:not(:disabled) {
  background-color: var(--primary-button-background);
}

.copy-button.full-width {
  width: 100%;
  max-width: 400px;
}

/* Button success state */
.copy-button.copied {
  background-color: var(--success-color) !important;
  border-color: var(--success-color) !important;
  color: white !important;
  transition: all 0.2s ease;
  animation: flash-success 0.3s;
}

.copy-button-text {
  font-size: 14px;
  letter-spacing: 0.5px;
}

.copy-status {
  opacity: 0;
  transition: opacity 0.3s ease;
  color: var(--success-color);
  font-weight: 500;
}

.copy-status.visible {
  opacity: 1;
}

/* Search bar component */
.search-bar {
  position: relative;
  display: flex;
  align-items: center;
  width: 100%;
  background-color: var(--background-primary);
  border: 1px solid var(--border-color);
  border-radius: 4px;
  box-shadow: 0 1px 2px rgba(0, 0, 0, 0.05);
  transition: border-color 0.2s, box-shadow 0.2s;
}

.search-bar.focused {
  border-color: var(--accent-blue);
  box-shadow: 0 0 0 1px var(--accent-blue);
}

.search-icon {
  position: absolute;
  left: 10px;
  top: 50%;
  transform: translateY(-50%);
  color: var(--icon-color);
  display: flex;
  align-items: center;
  justify-content: center;
  pointer-events: none;
  z-index: 2;
  width: 16px;
  height: 16px;
}

.search-bar .search-input,
input[type="search"].search-input,
input[type="text"].search-input {
  width: 100%;
  padding: 8px 32px 8px 36px !important;
  border: none;
  border-radius: 4px;
  font-size: 14px;
  outline: none;
  background-color: transparent;
  color: var(--text-primary);
}

.search-bar .search-input:focus,
input[type="search"].search-input:focus,
input[type="text"].search-input:focus {
  border-color: var(--accent-blue);
  box-shadow: 0 0 0 1px var(--accent-blue);
}

.search-clear-btn {
  position: absolute;
  right: 8px;
  top: 50%;
  transform: translateY(-50%);
  background: none;
  border: none;
  padding: 4px;
  color: var(--icon-color);
  display: flex;
  align-items: center;
  justify-content: center;
  border-radius: 50%;
  cursor: pointer;
  z-index: 2;
}

.search-clear-btn:hover {
  background-color: var(--hover-color);
}

/* Theme toggle control (macOS-style segmented control) */
.theme-segmented-control {
  display: flex;
  background-color: var(--background-secondary);
  border-radius: 6px;
  padding: 2px;
  box-shadow: 0 1px 3px rgba(0, 0, 0, 0.1);
  width: fit-content;
  position: relative;
  height: 32px;
  overflow: hidden;
}

.theme-segment {
  display: flex;
  align-items: center;
  justify-content: center;
  gap: 6px;
  padding: 0 12px;
  height: 28px;
  border: none;
  background: none;
  font-size: 13px;
  font-weight: 500;
  color: var(--text-secondary);
  position: relative;
  z-index: 1;
  transition: color 0.2s ease;
  border-radius: 4px;
  cursor: pointer;
  white-space: nowrap;
  min-width: 70px;
}

.theme-segment:focus {
  outline: none;
}

.theme-segment span {
  font-size: 12px;
}

.theme-segment.active {
  color: var(--text-primary);
  background-color: var(--background-primary);
  box-shadow: 0 1px 2px rgba(0, 0, 0, 0.1);
}

/* For dark mode, adjust active segment appearance */
.dark-mode .theme-segment.active {
  background-color: rgba(255, 255, 255, 0.1);
}

/* Animation for segment transition */
.theme-segment {
  transition: background-color 0.2s ease, color 0.2s ease, box-shadow 0.2s ease;
}

.header-actions {
  display: flex;
  align-items: center;
  gap: 16px;
}

/*--------------------------------------------------------------
9. User Instructions Area
--------------------------------------------------------------*/

/* User instructions container */
.user-instructions-container {
  padding: 8px 16px 16px 16px;
  display: flex;
  flex-direction: column;
  background-color: var(--background-primary);
  border-top: 1px solid var(--border-color);
  margin-top: auto; /* Push to bottom of container */
}

.user-instructions {
  width: 100%;
}

/* User instructions textarea */
.user-instructions textarea {
  color: var(--text-primary);
  line-height: 1.5;
  font-size: 0.95rem;
  border: 1px solid var(--border-color);
  border-radius: 4px;
  padding: 10px;
  background-color: var(--background-primary);
  box-shadow: 0 1px 2px rgba(0, 0, 0, 0.05);
  transition: border-color 0.2s ease, box-shadow 0.2s ease;
  width: 100%;
  height: 100px; /* Fixed height */
}

.user-instructions textarea:focus {
  outline: none;
  border-color: var(--accent-blue);
  box-shadow: 0 0 0 2px rgba(14, 99, 156, 0.2);
}

.user-instructions textarea::placeholder {
  color: var(--text-secondary);
  opacity: 0.7;
}

/* Dark mode specific textarea styles */
.dark-mode .user-instructions textarea {
  background-color: #252526; /* Slightly darker than background-secondary */
  box-shadow: 0 1px 3px rgba(0, 0, 0, 0.2);
}

.dark-mode .user-instructions textarea:focus {
  box-shadow: 0 0 0 2px rgba(14, 99, 156, 0.3);
}

/* User instructions header */
.user-instructions-header {
  display: flex;
  justify-content: space-between;
  align-items: center;
  padding: 10px 0px 8px 0px;
  background-color: var(--background-primary);
  border-bottom: none;
}

/* User instructions description text */
.user-instructions-description {
  color: var(--text-secondary);
  font-size: 0.85rem;
  margin-bottom: 8px;
  line-height: 1.4;
}

.dark-mode .user-instructions-description {
  opacity: 0.85;
}

/*--------------------------------------------------------------
10. Utilities & Animations
--------------------------------------------------------------*/

/* Loading spinner animation */
.processing-indicator {
  display: flex;
  flex-direction: column;
  align-items: center;
  justify-content: center;
  padding: 24px;
  gap: 16px;
  height: 100%;
  color: var(--text-secondary);
}

.spinner {
  border: 3px solid rgba(0, 0, 0, 0.1);
  border-radius: 50%;
  border-top: 3px solid var(--accent-blue);
  width: 24px;
  height: 24px;
  animation: spin 1s linear infinite;
}

@keyframes spin {
  0% {
    transform: rotate(0deg);
  }
  100% {
    transform: rotate(360deg);
  }
}

/* Success flash animation */
@keyframes flash-success {
  0% {
    opacity: 0.7;
  }
  50% {
    opacity: 1;
  }
  100% {
    opacity: 0.9;
  }
}

/* Error message styling */
.error-message {
  background-color: var(--error-color);
  color: white;
  padding: 16px 24px;
  border-radius: 4px;
  margin: 24px;
  display: flex;
  align-items: center;
  gap: 8px;
}


// ---- File: App.tsx ----

import React, { useState, useEffect } from "react";
import Sidebar from "./components/Sidebar";
import FileList from "./components/FileList";
import CopyButton from "./components/CopyButton";
import UserInstructions from "./components/UserInstructions";
import { FileData } from "./types/FileTypes";
import { ThemeProvider } from "./context/ThemeContext";
import ThemeToggle from "./components/ThemeToggle";
import { generateAsciiFileTree, normalizePath, arePathsEqual } from "./utils/pathUtils";

// Access the electron API from the window object
declare global {
  interface Window {
    electron: {
      ipcRenderer: {
        send: (channel: string, data?: any) => void;
        on: (channel: string, func: (...args: any[]) => void) => void;
        removeListener: (
          channel: string,
          func: (...args: any[]) => void
        ) => void;
      };
    };
  }
}

// Keys for localStorage
const STORAGE_KEYS = {
  SELECTED_FOLDER: "pastemax-selected-folder",
  SELECTED_FILES: "pastemax-selected-files",
  SORT_ORDER: "pastemax-sort-order",
  SEARCH_TERM: "pastemax-search-term",
  EXPANDED_NODES: "pastemax-expanded-nodes",
};

const App = () => {
  // Load initial state from localStorage if available
  const savedFolder = localStorage.getItem(STORAGE_KEYS.SELECTED_FOLDER);
  const savedFiles = localStorage.getItem(STORAGE_KEYS.SELECTED_FILES);
  const savedSortOrder = localStorage.getItem(STORAGE_KEYS.SORT_ORDER);
  const savedSearchTerm = localStorage.getItem(STORAGE_KEYS.SEARCH_TERM);

  const [selectedFolder, setSelectedFolder] = useState(
    savedFolder as string | null
  );
  const [allFiles, setAllFiles] = useState([] as FileData[]);
  const [selectedFiles, setSelectedFiles] = useState(
    savedFiles ? JSON.parse(savedFiles) : ([] as string[])
  );
  const [sortOrder, setSortOrder] = useState(savedSortOrder || "tokens-desc");
  const [searchTerm, setSearchTerm] = useState(savedSearchTerm || "");
  const [expandedNodes, setExpandedNodes] = useState(
    {} as Record<string, boolean>
  );
  const [displayedFiles, setDisplayedFiles] = useState([] as FileData[]);
  const [processingStatus, setProcessingStatus] = useState({
    status: "idle",
    message: "",
  } as {
    status: "idle" | "processing" | "complete" | "error";
    message: string;
  });
  const [includeFileTree, setIncludeFileTree] = useState(false);

  // State for sort dropdown
  const [sortDropdownOpen, setSortDropdownOpen] = useState(false);

  // NEW: State for user instructions
  const [userInstructions, setUserInstructions] = useState("");

  // Check if we're running in Electron or browser environment
  const isElectron = window.electron !== undefined;

  // Load expanded nodes state from localStorage
  useEffect(() => {
    const savedExpandedNodes = localStorage.getItem(
      STORAGE_KEYS.EXPANDED_NODES
    );
    if (savedExpandedNodes) {
      try {
        setExpandedNodes(JSON.parse(savedExpandedNodes));
      } catch (error) {
        console.error("Error parsing saved expanded nodes:", error);
      }
    }
  }, []);

  // Persist selected folder when it changes
  useEffect(() => {
    if (selectedFolder) {
      localStorage.setItem(STORAGE_KEYS.SELECTED_FOLDER, selectedFolder);
    } else {
      localStorage.removeItem(STORAGE_KEYS.SELECTED_FOLDER);
    }
  }, [selectedFolder]);

  // Persist selected files when they change
  useEffect(() => {
    localStorage.setItem(
      STORAGE_KEYS.SELECTED_FILES,
      JSON.stringify(selectedFiles)
    );
  }, [selectedFiles]);

  // Persist sort order when it changes
  useEffect(() => {
    localStorage.setItem(STORAGE_KEYS.SORT_ORDER, sortOrder);
  }, [sortOrder]);

  // Persist search term when it changes
  useEffect(() => {
    localStorage.setItem(STORAGE_KEYS.SEARCH_TERM, searchTerm);
  }, [searchTerm]);

  // Load initial data from saved folder
  useEffect(() => {
    if (!isElectron || !selectedFolder) return;

    // Use a flag in sessionStorage to ensure we only load data once per session
    const hasLoadedInitialData = sessionStorage.getItem("hasLoadedInitialData");
    if (hasLoadedInitialData === "true") return;

    console.log("Loading saved folder on startup:", selectedFolder);
    setProcessingStatus({
      status: "processing",
      message: "Loading files from previously selected folder...",
    });
    window.electron.ipcRenderer.send("request-file-list", selectedFolder);

    // Mark that we've loaded the initial data
    sessionStorage.setItem("hasLoadedInitialData", "true");
  }, [isElectron, selectedFolder]);

  // Listen for folder selection from main process
  useEffect(() => {
    if (!isElectron) {
      console.warn("Not running in Electron environment");
      return;
    }

    const handleFolderSelected = (folderPath: string) => {
      // Check if folderPath is valid string
      if (typeof folderPath === "string") {
        console.log("Folder selected:", folderPath);
        setSelectedFolder(folderPath);
        // We'll select all files after they're loaded
        setSelectedFiles([]);
        setProcessingStatus({
          status: "processing",
          message: "Requesting file list...",
        });
        window.electron.ipcRenderer.send("request-file-list", folderPath);
      } else {
        console.error("Invalid folder path received:", folderPath);
        setProcessingStatus({
          status: "error",
          message: "Invalid folder path received",
        });
      }
    };

    const handleFileListData = (files: FileData[]) => {
      console.log("Received file list data:", files.length, "files");
      setAllFiles(files);
      setProcessingStatus({
        status: "complete",
        message: `Loaded ${files.length} files`,
      });

      // Apply filters and sort to the new files
      applyFiltersAndSort(files, sortOrder, searchTerm);

      // Select only files that are not binary, not skipped, and not excluded by default
      const selectablePaths = files
        .filter(
          (file: FileData) =>
            !file.isBinary && !file.isSkipped && !file.excludedByDefault // Respect the excludedByDefault flag
        )
        .map((file: FileData) => file.path);

      setSelectedFiles(selectablePaths);
    };

    const handleProcessingStatus = (status: {
      status: "idle" | "processing" | "complete" | "error";
      message: string;
    }) => {
      console.log("Processing status:", status);
      setProcessingStatus(status);
    };

    window.electron.ipcRenderer.on("folder-selected", handleFolderSelected);
    window.electron.ipcRenderer.on("file-list-data", handleFileListData);
    window.electron.ipcRenderer.on(
      "file-processing-status",
      handleProcessingStatus
    );

    return () => {
      window.electron.ipcRenderer.removeListener(
        "folder-selected",
        handleFolderSelected
      );
      window.electron.ipcRenderer.removeListener(
        "file-list-data",
        handleFileListData
      );
      window.electron.ipcRenderer.removeListener(
        "file-processing-status",
        handleProcessingStatus
      );
    };
  }, [isElectron, sortOrder, searchTerm]);

  const openFolder = () => {
    if (isElectron) {
      console.log("Opening folder dialog");
      setProcessingStatus({ status: "idle", message: "Select a folder..." });
      window.electron.ipcRenderer.send("open-folder");
    } else {
      console.warn("Folder selection not available in browser");
    }
  };

  // Apply filters and sorting to files
  const applyFiltersAndSort = (
    files: FileData[],
    sort: string,
    filter: string
  ) => {
    let filtered = files;

    // Apply filter
    if (filter) {
      const lowerFilter = filter.toLowerCase();
      filtered = files.filter(
        (file) =>
          file.name.toLowerCase().includes(lowerFilter) ||
          file.path.toLowerCase().includes(lowerFilter)
      );
    }

    // Apply sort
    const [sortKey, sortDir] = sort.split("-");
    const sorted = [...filtered].sort((a, b) => {
      let comparison = 0;

      if (sortKey === "name") {
        comparison = a.name.localeCompare(b.name);
      } else if (sortKey === "tokens") {
        comparison = a.tokenCount - b.tokenCount;
      } else if (sortKey === "size") {
        comparison = a.size - b.size;
      }

      return sortDir === "asc" ? comparison : -comparison;
    });

    setDisplayedFiles(sorted);
  };

  // Toggle file selection
  const toggleFileSelection = (filePath: string) => {
    // Normalize the incoming file path to handle cross-platform issues
    const normalizedPath = normalizePath(filePath);
    
    setSelectedFiles((prev: string[]) => {
      // Check if the file is already selected
      const isSelected = prev.some(path => arePathsEqual(path, normalizedPath));
      
      if (isSelected) {
        // Remove the file from selected files
        const newSelection = prev.filter((path: string) => !arePathsEqual(path, normalizedPath));
        return newSelection;
      } else {
        // Add the file to selected files
        const newSelection = [...prev, normalizedPath];
        return newSelection;
      }
    });
  };

  // Toggle folder selection (select/deselect all files in folder)
  const toggleFolderSelection = (folderPath: string, isSelected: boolean) => {
    // Normalize the folder path
    const normalizedFolderPath = normalizePath(folderPath);
    
    const filesInFolder = allFiles.filter(
      (file: FileData) =>
        normalizePath(file.path).startsWith(normalizedFolderPath) && 
        !file.isBinary && 
        !file.isSkipped,

    );

    if (isSelected) {
      // Add all files from this folder that aren't already selected
      const filePaths = filesInFolder.map((file: FileData) => normalizePath(file.path));
      
      setSelectedFiles((prev: string[]) => {
        const newSelection = [...prev];
        filePaths.forEach((path: string) => {
          if (!newSelection.some(p => arePathsEqual(p, path))) {
            newSelection.push(path);
          }
        });
        return newSelection;
      });
    } else {
      // Remove all files from this folder
      setSelectedFiles((prev: string[]) => {
        const newSelection = prev.filter(
          (path: string) =>

            !filesInFolder.some((file: FileData) => arePathsEqual(normalizePath(file.path), path)),
        );
        return newSelection;
      });
    }
  };

  // Handle sort change
  const handleSortChange = (newSort: string) => {
    setSortOrder(newSort);
    applyFiltersAndSort(allFiles, newSort, searchTerm);
    setSortDropdownOpen(false); // Close dropdown after selection
  };

  // Handle search change
  const handleSearchChange = (newSearch: string) => {
    setSearchTerm(newSearch);
    applyFiltersAndSort(allFiles, sortOrder, newSearch);
  };

  // Toggle sort dropdown
  const toggleSortDropdown = () => {
    setSortDropdownOpen(!sortDropdownOpen);
  };

  // Calculate total tokens from selected files
  const calculateTotalTokens = () => {
    return selectedFiles.reduce((total: number, path: string) => {
      const file = allFiles.find((f: FileData) => f.path === path);
      return total + (file ? file.tokenCount : 0);
    }, 0);
  };

  // Concatenate selected files content for copying,
  // and add user instructions (wrapped in tags) at the bottom if provided.
  const getSelectedFilesContent = () => {
    // Sort selected files according to current sort order
    const [sortKey, sortDir] = sortOrder.split("-");
    const sortedSelected = allFiles
      .filter((file: FileData) => selectedFiles.includes(file.path))
      .sort((a: FileData, b: FileData) => {
        let comparison = 0;

        if (sortKey === "name") {
          comparison = a.name.localeCompare(b.name);
        } else if (sortKey === "tokens") {
          comparison = a.tokenCount - b.tokenCount;
        } else if (sortKey === "size") {
          comparison = a.size - b.size;
        }

        return sortDir === "asc" ? comparison : -comparison;
      });

    if (sortedSelected.length === 0) {
      return "No files selected.";
    }

    let concatenatedString = "";

    // Add ASCII file tree if enabled
    if (includeFileTree && selectedFolder) {
      const asciiTree = generateAsciiFileTree(sortedSelected, selectedFolder);
      concatenatedString += `<file_map>\n${selectedFolder}\n${asciiTree}\n</file_map>\n\n`;
    }

    sortedSelected.forEach((file: FileData) => {
      concatenatedString += `\n\n// ---- File: ${file.name} ----\n\n`;
      concatenatedString += file.content;
    });

    // Wrap user instructions if any and add to the bottom
    const userInstructionsBlock = userInstructions.trim()
      ? `\n<user_instructions>\n${userInstructions}\n</user_instructions>\n\n`
      : "";
    return concatenatedString + userInstructionsBlock;
  };

  // Handle select all files
  const selectAllFiles = () => {
    const selectablePaths = displayedFiles
      .filter((file: FileData) => !file.isBinary && !file.isSkipped)
      .map((file: FileData) => file.path);

    setSelectedFiles((prev: string[]) => {
      const newSelection = [...prev];
      selectablePaths.forEach((path: string) => {
        if (!newSelection.includes(path)) {
          newSelection.push(path);
        }
      });
      return newSelection;
    });
  };

  // Handle deselect all files
  const deselectAllFiles = () => {
    const displayedPaths = displayedFiles.map((file: FileData) => file.path);
    setSelectedFiles((prev: string[]) =>
      prev.filter((path: string) => !displayedPaths.includes(path))
    );
  };

  // Sort options for the dropdown
  const sortOptions = [
    { value: "tokens-desc", label: "Tokens: High to Low" },
    { value: "tokens-asc", label: "Tokens: Low to High" },
    { value: "name-asc", label: "Name: A to Z" },
    { value: "name-desc", label: "Name: Z to A" },
  ];

  // Handle expand/collapse state changes
  const toggleExpanded = (nodeId: string) => {
    setExpandedNodes((prev: Record<string, boolean>) => {
      const newState = {
        ...prev,
        [nodeId]: prev[nodeId] === undefined ? false : !prev[nodeId],
      };

      // Save to localStorage
      localStorage.setItem(
        STORAGE_KEYS.EXPANDED_NODES,
        JSON.stringify(newState)
      );

      return newState;
    });
  };

  return (
    <ThemeProvider>
      <div className="app-container">
        <header className="header">
          <h1>PasteMax</h1>
          <div className="header-actions">
            <ThemeToggle />
            <div className="folder-info">
              {selectedFolder ? (
                <div className="selected-folder">{selectedFolder}</div>
              ) : (
                <span>No folder selected</span>
              )}
              <button
                className="select-folder-btn"
                onClick={openFolder}
                disabled={processingStatus.status === "processing"}
              >
                Select Folder
              </button>
            </div>
          </div>
        </header>

        {processingStatus.status === "processing" && (
          <div className="processing-indicator">
            <div className="spinner"></div>
            <span>{processingStatus.message}</span>
          </div>
        )}

        {processingStatus.status === "error" && (
          <div className="error-message">Error: {processingStatus.message}</div>
        )}

        {selectedFolder && (
          <div className="main-content">
            <Sidebar
              selectedFolder={selectedFolder}
              openFolder={openFolder}
              allFiles={allFiles}
              selectedFiles={selectedFiles}
              toggleFileSelection={toggleFileSelection}
              toggleFolderSelection={toggleFolderSelection}
              searchTerm={searchTerm}
              onSearchChange={handleSearchChange}
              selectAllFiles={selectAllFiles}
              deselectAllFiles={deselectAllFiles}
              expandedNodes={expandedNodes}
              toggleExpanded={toggleExpanded}
            />
            <div className="content-area">
              <div className="content-header">
                <div className="content-title">Selected Files</div>
                <div className="content-actions">
                  <div className="sort-dropdown">
                    <button
                      className="sort-dropdown-button"
                      onClick={toggleSortDropdown}
                    >
                      Sort:{" "}
                      {sortOptions.find((opt) => opt.value === sortOrder)
                        ?.label || sortOrder}
                    </button>
                    {sortDropdownOpen && (
                      <div className="sort-options">
                        {sortOptions.map((option) => (
                          <div
                            key={option.value}
                            className={`sort-option ${
                              sortOrder === option.value ? "active" : ""
                            }`}
                            onClick={() => handleSortChange(option.value)}
                          >
                            {option.label}
                          </div>
                        ))}
                      </div>
                    )}
                  </div>
                  <div className="file-stats">
                    {selectedFiles.length} files | ~
                    {calculateTotalTokens().toLocaleString()} tokens
                  </div>
                </div>
              </div>

              <FileList
                files={displayedFiles}
                selectedFiles={selectedFiles}
                toggleFileSelection={toggleFileSelection}
              />

              {/* Render the user instructions textbox */}
              <div className="user-instructions-container">
                <UserInstructions
                  instructions={userInstructions}
                  setInstructions={setUserInstructions}
                />
              </div>

              <div className="copy-button-container">
                <div
                  style={{
                    display: "flex",
                    flexDirection: "column",
                    alignItems: "center",
                    gap: "12px",
                    width: "100%",
                    maxWidth: "400px",
                  }}
                >
                  <label
                    style={{
                      display: "flex",
                      alignItems: "center",
                      gap: "8px",
                      cursor: "pointer",
                    }}
                  >
                    <input
                      type="checkbox"
                      checked={includeFileTree}
                      onChange={() => setIncludeFileTree(!includeFileTree)}
                    />
                    <span>Include File Tree</span>
                  </label>
                  <CopyButton
                    text={getSelectedFilesContent()}
                    className="primary full-width"
                  >
                    <span>
                      COPY ALL SELECTED ({selectedFiles.length} files)
                    </span>
                  </CopyButton>
                </div>
              </div>
            </div>
          </div>
        )}
      </div>
    </ThemeProvider>
  );
};

export default App;


// ---- File: Sidebar.tsx ----

import React, { useState, useEffect } from "react";
import { SidebarProps, TreeNode } from "../types/FileTypes";
import SearchBar from "./SearchBar";
import TreeItem from "./TreeItem";

const Sidebar = ({
  selectedFolder,
  openFolder,
  allFiles,
  selectedFiles,
  toggleFileSelection,
  toggleFolderSelection,
  searchTerm,
  onSearchChange,
  selectAllFiles,
  deselectAllFiles,
  expandedNodes,
  toggleExpanded,
}: SidebarProps) => {
  const [fileTree, setFileTree] = useState<TreeNode[]>([]);
  const [isTreeBuildingComplete, setIsTreeBuildingComplete] = useState(false);
  const [sidebarWidth, setSidebarWidth] = useState(300);
  const [isResizing, setIsResizing] = useState(false);

  // Min and max width constraints
  const MIN_SIDEBAR_WIDTH = 200;
  const MAX_SIDEBAR_WIDTH = 500;

  // Handle mouse down for resizing
  const handleResizeStart = (e: React.MouseEvent<HTMLDivElement>) => {
    e.preventDefault();
    setIsResizing(true);
  };

  // Handle resize effect
  useEffect(() => {
    const handleResize = (e: globalThis.MouseEvent) => {
      if (isResizing) {
        const newWidth = e.clientX;
        if (newWidth >= MIN_SIDEBAR_WIDTH && newWidth <= MAX_SIDEBAR_WIDTH) {
          setSidebarWidth(newWidth);
        }
      }
    };

    const handleResizeEnd = () => {
      setIsResizing(false);
    };

    document.addEventListener("mousemove", handleResize);
    document.addEventListener("mouseup", handleResizeEnd);

    return () => {
      document.removeEventListener("mousemove", handleResize);
      document.removeEventListener("mouseup", handleResizeEnd);
    };
  }, [isResizing]);

  // Build file tree structure from flat list of files
  useEffect(() => {
    if (allFiles.length === 0) {
      setFileTree([]);
      setIsTreeBuildingComplete(false);
      return;
    }

    const buildTree = () => {
      console.log("Building file tree from", allFiles.length, "files");
      setIsTreeBuildingComplete(false);

      try {
        // Create a structured representation using nested objects first
        const fileMap: Record<string, any> = {};

        // First pass: create directories and files
        allFiles.forEach((file) => {
          if (!file.path) return;

          const relativePath =
            selectedFolder && file.path.startsWith(selectedFolder)
              ? file.path
                  .substring(selectedFolder.length)
                  .replace(/^\/|^\\/, "")
              : file.path;

          const parts = relativePath.split(/[/\\]/);
          let currentPath = "";
          let current = fileMap;

          // Build the path in the tree
          for (let i = 0; i < parts.length; i++) {
            const part = parts[i];
            if (!part) continue;

            currentPath = currentPath ? `${currentPath}/${part}` : part;
            
            // Use the original file.path for files to avoid path duplication
            const fullPath = i === parts.length - 1 
              ? file.path // For files, use the original path
              : (selectedFolder 
                  ? `${selectedFolder}/${currentPath}` 
                  : currentPath); // For directories

            if (i === parts.length - 1) {
              // This is a file
              current[part] = {
                id: `node-${fullPath}`,
                name: part,
                path: file.path, // Use the original file path
                type: "file",
                level: i,
                fileData: file,
              };
            } else {
              // This is a directory
              if (!current[part]) {
                current[part] = {
                  id: `node-${fullPath}`,
                  name: part,
                  path: fullPath,
                  type: "directory",
                  level: i,
                  children: {},
                };
              }
              current = current[part].children;
            }
          }
        });

        // Convert the nested object structure to the TreeNode array format
        const convertToTreeNodes = (
          node: Record<string, any>,
          level = 0,
        ): TreeNode[] => {
          return Object.keys(node).map((key) => {
            const item = node[key];

            if (item.type === "file") {
              return item as TreeNode;
            } else {
              const children = convertToTreeNodes(item.children, level + 1);
              const isExpanded =
                expandedNodes[item.id] !== undefined
                  ? expandedNodes[item.id]
                  : true; // Default to expanded if not in state

              return {
                ...item,
                children: children.sort((a, b) => {
                  // Sort directories first
                  if (a.type === "directory" && b.type === "file") return -1;
                  if (a.type === "file" && b.type === "directory") return 1;

                  // Sort files by token count (largest first)
                  if (a.type === "file" && b.type === "file") {
                    const aTokens = a.fileData?.tokenCount || 0;
                    const bTokens = b.fileData?.tokenCount || 0;
                    return bTokens - aTokens;
                  }

                  // Default to alphabetical
                  return a.name.localeCompare(b.name);
                }),
                isExpanded,
              };
            }
          });
        };

        // Convert to proper tree structure
        const treeRoots = convertToTreeNodes(fileMap);

        // Sort the top level (directories first, then by name)
        const sortedTree = treeRoots.sort((a, b) => {
          if (a.type === "directory" && b.type === "file") return -1;
          if (a.type === "file" && b.type === "directory") return 1;

          // Sort files by token count (largest first)
          if (a.type === "file" && b.type === "file") {
            const aTokens = a.fileData?.tokenCount || 0;
            const bTokens = b.fileData?.tokenCount || 0;
            return bTokens - aTokens;
          }

          return a.name.localeCompare(b.name);
        });

        setFileTree(sortedTree);
        setIsTreeBuildingComplete(true);
      } catch (err) {
        console.error("Error building file tree:", err);
        setFileTree([]);
        setIsTreeBuildingComplete(true);
      }
    };

    // Use a timeout to not block UI
    const buildTreeTimeoutId = setTimeout(buildTree, 0);
    return () => clearTimeout(buildTreeTimeoutId);
  }, [allFiles, selectedFolder, expandedNodes]);

  // Apply expanded state as a separate operation when expandedNodes change
  useEffect(() => {
    if (fileTree.length === 0) return;

    // Function to apply expanded state to nodes
    const applyExpandedState = (nodes: TreeNode[]): TreeNode[] => {
      return nodes.map((node: TreeNode): TreeNode => {
        if (node.type === "directory") {
          const isExpanded =
            expandedNodes[node.id] !== undefined
              ? expandedNodes[node.id]
              : true; // Default to expanded if not in state

          return {
            ...node,
            isExpanded,
            children: node.children ? applyExpandedState(node.children) : [],
          };
        }
        return node;
      });
    };

    setFileTree((prevTree: TreeNode[]) => applyExpandedState(prevTree));
  }, [expandedNodes]);

  // Flatten the tree for rendering with proper indentation
  const flattenTree = (nodes: TreeNode[]): TreeNode[] => {
    let result: TreeNode[] = [];

    nodes.forEach((node) => {
      // Add the current node
      result.push(node);

      // If it's a directory and it's expanded, add its children
      if (node.type === "directory" && node.isExpanded && node.children) {
        result = [...result, ...flattenTree(node.children)];
      }
    });

    return result;
  };

  // Filter the tree based on search term
  const filterTree = (nodes: TreeNode[], term: string): TreeNode[] => {
    if (!term) return nodes;

    const lowerTerm = term.toLowerCase();

    // Function to check if a node or any of its children match the search
    const nodeMatches = (node: TreeNode): boolean => {
      // Check if the node name matches
      if (node.name.toLowerCase().includes(lowerTerm)) return true;

      // If it's a file, we're done
      if (node.type === "file") return false;

      // For directories, check if any children match
      if (node.children) {
        return node.children.some(nodeMatches);
      }

      return false;
    };

    // Filter the nodes
    return nodes.filter(nodeMatches).map((node) => {
      // If it's a directory, also filter its children
      if (node.type === "directory" && node.children) {
        return {
          ...node,
          children: filterTree(node.children, term),
          isExpanded: true, // Auto-expand directories when searching
        };
      }
      return node;
    });
  };

  // The final tree to render, filtered and flattened
  const visibleTree = flattenTree(filterTree(fileTree, searchTerm));

  return (
    <div className="sidebar" style={{ width: `${sidebarWidth}px` }}>
      <div className="sidebar-header">
        <div className="sidebar-title">Files</div>
        <div className="sidebar-folder-path">{selectedFolder}</div>
      </div>

      <div className="sidebar-search">
        <SearchBar
          searchTerm={searchTerm}
          onSearchChange={onSearchChange}
          placeholder="Search files..."
        />
      </div>

      <div className="sidebar-actions">
        <button className="sidebar-action-btn" onClick={selectAllFiles}>
          Select All
        </button>
        <button className="sidebar-action-btn" onClick={deselectAllFiles}>
          Deselect All
        </button>
      </div>

      {allFiles.length > 0 ? (
        isTreeBuildingComplete ? (
          <div className="file-tree">
            {visibleTree.length > 0 ? (
              visibleTree.map((node) => (
                <TreeItem
                  key={node.id}
                  node={node}
                  selectedFiles={selectedFiles}
                  toggleFileSelection={toggleFileSelection}
                  toggleFolderSelection={toggleFolderSelection}
                  toggleExpanded={toggleExpanded}
                />
              ))
            ) : (
              <div className="tree-empty">No files match your search.</div>
            )}
          </div>
        ) : (
          <div className="tree-loading">
            <div className="spinner"></div>
            <span>Building file tree...</span>
          </div>
        )
      ) : (
        <div className="tree-empty">No files found in this folder.</div>
      )}

      <div
        className="sidebar-resize-handle"
        onMouseDown={handleResizeStart}
        title="Drag to resize sidebar"
      ></div>
    </div>
  );
};

export default Sidebar;


// ---- File: pathUtils.ts ----

/**
 * Browser-compatible path utilities to replace Node.js path module
 */

/**
 * Normalizes a file path to use forward slashes regardless of operating system
 * This helps with path comparison across different platforms
 * 
 * @param filePath The file path to normalize
 * @returns The normalized path with forward slashes
 */
export function normalizePath(filePath: string): string {
  if (!filePath) return filePath;
  
  // Replace backslashes with forward slashes
  return filePath.replace(/\\/g, '/');
}

/**
 * Detects the operating system
 * 
 * @returns The detected operating system ('windows', 'mac', 'linux', or 'unknown')
 */
export function detectOS(): 'windows' | 'mac' | 'linux' | 'unknown' {
  if (typeof window !== 'undefined' && window.navigator) {
    const platform = window.navigator.platform.toLowerCase();
    
    if (platform.includes('win')) {
      return 'windows';
    } else if (platform.includes('mac')) {
      return 'mac';
    } else if (platform.includes('linux')) {
      return 'linux';
    }
  }
  
  return 'unknown';
}

/**
 * Compares two paths for equality, handling different OS path separators
 * 
 * @param path1 First path to compare
 * @param path2 Second path to compare
 * @returns True if the paths are equivalent, false otherwise
 */
export function arePathsEqual(path1: string, path2: string): boolean {
  return normalizePath(path1) === normalizePath(path2);
}

/**
 * Extract the basename from a path string
 * @param path The path to extract the basename from
 * @returns The basename (last part of the path)
 */
export function basename(path: string | null | undefined): string {
  if (!path) return "";

  // Ensure path is a string
  const pathStr = String(path);

  // Handle both forward and backslashes
  const normalizedPath = pathStr.replace(/\\/g, "/");
  // Remove trailing slashes
  const trimmedPath = normalizedPath.endsWith("/")
    ? normalizedPath.slice(0, -1)
    : normalizedPath;
  // Get the last part after the final slash
  const parts = trimmedPath.split("/");
  return parts[parts.length - 1] || "";
}

/**
 * Extract the directory name from a path string
 * @param path The path to extract the directory from
 * @returns The directory (everything except the last part)
 */
export function dirname(path: string | null | undefined): string {
  if (!path) return ".";

  // Ensure path is a string
  const pathStr = String(path);

  // Handle both forward and backslashes
  const normalizedPath = pathStr.replace(/\\/g, "/");
  // Remove trailing slashes
  const trimmedPath = normalizedPath.endsWith("/")
    ? normalizedPath.slice(0, -1)
    : normalizedPath;
  // Get everything before the final slash
  const lastSlashIndex = trimmedPath.lastIndexOf("/");
  return lastSlashIndex === -1 ? "." : trimmedPath.slice(0, lastSlashIndex);
}

/**
 * Join path segments together
 * @param segments The path segments to join
 * @returns The joined path
 */
export function join(...segments: (string | null | undefined)[]): string {
  return segments
    .filter(Boolean)
    .map((seg) => String(seg))
    .join("/")
    .replace(/\/+/g, "/"); // Replace multiple slashes with a single one
}

/**
 * Get the file extension
 * @param path The path to get the extension from
 * @returns The file extension including the dot
 */
export function extname(path: string | null | undefined): string {
  if (!path) return "";

  const basenameValue = basename(path);
  const dotIndex = basenameValue.lastIndexOf(".");
  return dotIndex === -1 || dotIndex === 0 ? "" : basenameValue.slice(dotIndex);
}

/**
 * Generate an ASCII representation of the file tree for the selected files
 * @param files Array of selected FileData objects
 * @param rootPath The root directory path
 * @returns ASCII string representing the file tree
 */
export function generateAsciiFileTree(files: { path: string }[], rootPath: string): string {
  if (!files.length) return "No files selected.";

  // Normalize the root path for consistent path handling
  const normalizedRoot = rootPath.replace(/\\/g, "/").replace(/\/$/, "");
  
  // Create a tree structure from the file paths
  interface TreeNode {
    name: string;
    isFile: boolean;
    children: Record<string, TreeNode>;
  }
  
  const root: TreeNode = { name: basename(normalizedRoot), isFile: false, children: {} };
  
  // Insert a file path into the tree
  const insertPath = (filePath: string, node: TreeNode) => {
    const normalizedPath = filePath.replace(/\\/g, "/");
    if (!normalizedPath.startsWith(normalizedRoot)) return;
    
    const relativePath = normalizedPath.substring(normalizedRoot.length).replace(/^\//, "");
    if (!relativePath) return;
    
    const pathParts = relativePath.split("/");
    let currentNode = node;
    
    for (let i = 0; i < pathParts.length; i++) {
      const part = pathParts[i];
      const isFile = i === pathParts.length - 1;
      
      if (!currentNode.children[part]) {
        currentNode.children[part] = {
          name: part,
          isFile,
          children: {}
        };
      }
      
      currentNode = currentNode.children[part];
    }
  };
  
  // Insert all files into the tree
  files.forEach(file => insertPath(file.path, root));
  
  // Generate ASCII representation
  const generateAscii = (node: TreeNode, prefix = "", isLast = true, isRoot = true): string => {
    if (!isRoot) {
      let result = prefix;
      result += isLast ? "└── " : "├── ";
      result += node.name;
      result += "\n";
      prefix += isLast ? "    " : "│   ";
      
      const children = Object.values(node.children).sort((a, b) => {
        // Sort by type (directories first) then by name
        if (a.isFile !== b.isFile) {
          return a.isFile ? 1 : -1;
        }
        return a.name.localeCompare(b.name);
      });
      
      return result + children
        .map((child, index) =>
          generateAscii(child, prefix, index === children.length - 1, false)
        )
        .join("");
    } else {
      // Root node special handling
      const children = Object.values(node.children).sort((a, b) => {
        // Sort by type (directories first) then by name
        if (a.isFile !== b.isFile) {
          return a.isFile ? 1 : -1;
        }
        return a.name.localeCompare(b.name);
      });
      
      return children
        .map((child, index) =>
          generateAscii(child, prefix, index === children.length - 1, false)
        )
        .join("");
    }
  };
  
  return generateAscii(root);
}

// ---- File: TreeItem.tsx ----

import React, {
  useRef,
  useEffect,
} from "react";
import { TreeItemProps, TreeNode } from "../types/FileTypes";
import { ChevronRight, File, Folder } from "lucide-react";
import { arePathsEqual } from "../utils/pathUtils";

const TreeItem = ({
  node,
  selectedFiles,
  toggleFileSelection,
  toggleFolderSelection,
  toggleExpanded,
}: TreeItemProps) => {
  const { id, name, path, type, level, isExpanded, fileData } = node;
  const checkboxRef = useRef<HTMLInputElement>(null);

  const isSelected = type === "file" && selectedFiles.some(selectedPath => 
    arePathsEqual(selectedPath, path)
  );

  // For directories, check if all children are selected
  const isDirectorySelected =
    type === "directory" && node.children
      ? node.children.every((child: TreeNode) => {
          if (child.type === "file") {
            return selectedFiles.some(selectedPath => 
              arePathsEqual(selectedPath, child.path)
            );
          } else if (child.type === "directory" && child.children) {
            // Check recursively if this directory's children are all selected
            return child.children.every((grandchild: TreeNode) => {
              return (
                grandchild.type === "file" &&
                selectedFiles.some(selectedPath => 
                  arePathsEqual(selectedPath, grandchild.path)
                )
              );
            });
          }
          return false;
        })
      : false;

  // Check if some but not all files in this directory are selected
  const isDirectoryPartiallySelected =
    type === "directory" && node.children
      ? node.children.some((child: TreeNode) => {
          if (child.type === "file") {
            return selectedFiles.some(selectedPath => 
              arePathsEqual(selectedPath, child.path)
            );
          } else if (child.type === "directory" && child.children) {
            return child.children.some((grandchild: TreeNode) => {
              return (
                grandchild.type === "file" &&
                selectedFiles.some(selectedPath => 
                  arePathsEqual(selectedPath, grandchild.path)
                )
              );
            });
          }
          return false;
        }) && !isDirectorySelected
      : false;

  // Update the indeterminate state manually whenever it changes
  useEffect(() => {
    if (checkboxRef.current) {
      checkboxRef.current.indeterminate = isDirectoryPartiallySelected;
    }
  }, [isDirectoryPartiallySelected]);

  const handleToggle = (e: React.MouseEvent) => {
    e.stopPropagation();
    toggleExpanded(id);
  };

  const handleItemClick = (e: React.MouseEvent) => {
    if (type === "directory") {
      toggleExpanded(id);
    } else if (type === "file" && !isDisabled) {
      toggleFileSelection(path);
    }
  };

  const handleCheckboxChange = (e: React.ChangeEvent<HTMLInputElement>) => {
    e.stopPropagation();
    if (type === "file") {
      toggleFileSelection(path);
    } else if (type === "directory") {
      toggleFolderSelection(path, e.target.checked);
    }
  };

  // Check if file is binary or otherwise unselectable
  const isDisabled = fileData ? fileData.isBinary || fileData.isSkipped : false;

  // Check if the file is excluded by default (but still selectable)
  const isExcludedByDefault = fileData?.excludedByDefault || false;

  return (
    <div
      className={`tree-item ${isSelected ? "selected" : ""} ${
        isExcludedByDefault ? "excluded-by-default" : ""
      }`}
      style={{ marginLeft: `${level * 16}px` }}
      onClick={handleItemClick}
    >
      {type === "directory" && (
        <div
          className={`tree-item-toggle ${isExpanded ? "expanded" : ""}`}
          onClick={handleToggle}
          aria-label={isExpanded ? "Collapse folder" : "Expand folder"}
        >
          <ChevronRight size={16} />
        </div>
      )}

      {type === "file" && <div className="tree-item-indent"></div>}

      <input
        type="checkbox"
        className="tree-item-checkbox"
        checked={type === "file" ? isSelected : isDirectorySelected}
        ref={checkboxRef}
        onChange={handleCheckboxChange}
        disabled={isDisabled}
        onClick={(e) => e.stopPropagation()}
      />

      <div className="tree-item-content">
        <div className="tree-item-icon">
          {type === "directory" ? <Folder size={16} /> : <File size={16} />}
        </div>

        <div className="tree-item-name">{name}</div>

        {fileData && fileData.tokenCount > 0 && (
          <span className="tree-item-tokens">
            (~{fileData.tokenCount.toLocaleString()})
          </span>
        )}

        {isDisabled && fileData && (
          <span className="tree-item-badge">
            {fileData.isBinary ? "Binary" : "Skipped"}
          </span>
        )}

        {!isDisabled && isExcludedByDefault && (
          <span className="tree-item-badge excluded">Excluded</span>
        )}
      </div>
    </div>
  );
};

export default TreeItem;


// ---- File: package.json ----

{
  "name": "pastemax",
  "version": "1.0.0",
  "main": "main.js",
  "scripts": {
    "start": "electron .",
    "dev": "vite",
    "dev:electron": "node dev.js",
    "build": "vite build",
    "build-electron": "node build.js",
    "verify-build": "node scripts/verify-build.js",
    "test-build": "node scripts/test-local-build.js",
    "test-build:mac": "node scripts/test-local-build.js mac",
    "test-build:win": "node scripts/test-local-build.js win",
    "test-build:linux": "node scripts/test-local-build.js linux",
    "debug-gh-release": "git tag debug-v$(date +'%Y%m%d%H%M%S') && git push origin --tags",
    "package": "vite build && electron-builder --publish=never",
    "package:mac": "vite build && electron-builder --mac --publish=never",
    "package:win": "vite build && electron-builder --win --publish=never",
    "package:linux": "vite build && electron-builder --linux --publish=never",
    "package:all": "vite build && electron-builder -mwl --publish=never",
    "release": "vite build && electron-builder --publish=onTagOrDraft",
    "lint": "eslint . --ext ts,tsx --report-unused-disable-directives",
    "lint:strict": "eslint . --ext ts,tsx --report-unused-disable-directives --max-warnings 0",
    "preview": "vite preview"
  },
  "keywords": [
    "clipboard",
    "code",
    "developer-tools",
    "electron",
    "file-viewer"
  ],
  "author": {
    "name": "kleneway",
    "email": "kleneway@notreal.com"
  },
  "license": "MIT",
  "description": "A modern file viewer application for developers to easily navigate, search, and copy code from repositories.",
  "build": {
    "appId": "com.kleneway.pastemax",
    "productName": "PasteMax",
    "directories": {
      "output": "release-builds"
    },
    "files": [
      "dist/**/*",
      "main.js",
      "preload.js",
      "excluded-files.js",
      "node_modules/**/*"
    ],
    "mac": {
      "category": "public.app-category.developer-tools",
      "icon": "public/favicon.icns",
      "target": [
        "dmg",
        "zip"
      ],
      "hardenedRuntime": false
    },
    "win": {
      "target": [
        "nsis",
        "portable"
      ],
      "icon": "public/favicon.ico"
    },
    "linux": {
      "target": [
        "AppImage",
        "deb",
        "rpm"
      ],
      "category": "Development",
      "icon": "public/favicon.png"
    },
    "asarUnpack": [
      "node_modules/ignore/**",
      "node_modules/tiktoken/**",
      "node_modules/gpt-3-encoder/**"
    ],
    "asar": true,
    "afterSign": "scripts/notarize.js",
    "publish": [
      "github"
    ]
  },
  "devDependencies": {
    "@electron/notarize": "^2.5.0",
    "@types/node": "^20.10.5",
    "@types/react": "^18.2.43",
    "@types/react-dom": "^18.2.17",
    "@typescript-eslint/eslint-plugin": "^6.14.0",
    "@typescript-eslint/parser": "^6.14.0",
    "@vitejs/plugin-react": "^4.2.1",
    "electron": "^34.3.0",
    "electron-builder": "^24.13.3",
    "eslint": "^8.55.0",
    "eslint-plugin-react-hooks": "^4.6.0",
    "eslint-plugin-react-refresh": "^0.4.5",
    "typescript": "^5.3.3",
    "vite": "^5.0.8"
  },
  "dependencies": {
    "gpt-3-encoder": "^1.1.4",
    "ignore": "^7.0.3",
    "lucide-react": "^0.477.0",
    "react": "^18.2.0",
    "react-dom": "^18.2.0",
    "tiktoken": "^1.0.20"
  }
}

// ---- File: update.md ----

# PasteMax Updates

## Overview
This document outlines the improvements and fixes made to the PasteMax application to enhance functionality, cross-platform compatibility, and user experience.

## 1. Development Environment Fixes

### Port Configuration Issue Resolution
- Fixed a port mismatch issue where Electron was trying to connect to port 3000 while Vite was running on port 5173
- Updated `vite.config.ts` to explicitly set the server port to 3000 with `strictPort: true` to match Electron's expectations
- Enhanced error handling for port conflicts

### Content Security Policy (CSP) Implementation
- Added proper Content-Security-Policy headers to address Electron security warnings
- Created separate CSP configurations for development and production environments
- Used crypto module to generate random nonces for script tags in production mode
- Added cross-origin permissions for Google Fonts and external resources
- Added WebSocket connection permissions for hot module reloading

### Cross-Platform Compatibility
- Improved path handling using Node's built-in `path.sep` instead of platform-specific checks
- Added app path information to ensure consistent file path resolution across platforms
- Enhanced shell compatibility for spawned processes
- Fixed scrollbar styling to work consistently across operating systems and browsers

## 2. UI Improvements

### User Instructions Area Enhancements
- Redesigned the user instructions area for a cleaner, less cluttered interface
- Added proper dark mode styling for the textarea and container
- Fixed scrollbar styling to match the theme
- Added a concise description text: "Custom instructions included with selected files"
- Set a fixed height for the textarea (100px) and improved spacing
- Pushed the instructions area to the bottom with `margin-top: auto`

### Dark Mode Improvements
- Added specific background color (#252526) for textarea in dark mode
- Implemented custom scrollbar colors for dark mode
- Adjusted opacity and contrast for better readability
- Fine-tuned focus states for better visibility in dark mode

### DevTools Configuration
- Modified DevTools to open in the same window instead of a detached window
- Improved console log display and integration with the main application window

## 3. Code Quality and Documentation

### CSS Reorganization and Documentation
- Completely reorganized CSS with a comprehensive table of contents
- Divided styles into 10 logical sections with clear headers
- Added descriptive comments for each component
- Grouped related styles together for better maintainability
- Added explanatory comments for non-obvious CSS properties
- Created a dedicated section for animations and utilities

### Improved Development Documentation
- Added detailed comments in `main.js` explaining the CSP implementation
- Documented the rationale for using the crypto module
- Added comprehensive comments in `dev.js` explaining the development environment setup
- Added documentation to `vite.config.ts` explaining configuration choices
- Improved code organization to make it more approachable for new developers

## 4. Security Enhancements

- Implemented a more secure Content Security Policy following Electron best practices
- Added nonce-based script validation for production
- Removed unsafe-eval and unsafe-inline directives where possible
- Added proper CORS settings for external resources
- Improved error handling and security-related logging

## Next Steps
- Continue refining the UI for better usability
- Consider implementing automated tests for the development environment
- Further optimize cross-platform performance
- Review and enhance accessibility features


// ---- File: preload.js ----

// Preload script
const { contextBridge, ipcRenderer } = require("electron");

// Helper function to ensure data is serializable
function ensureSerializable(data) {
  if (data === null || data === undefined) {
    return data;
  }

  // Handle primitive types directly
  if (typeof data !== "object") {
    return data;
  }

  // For arrays, map each item
  if (Array.isArray(data)) {
    return data.map(ensureSerializable);
  }

  // For objects, create a new object with serializable properties
  const result = {};
  for (const key in data) {
    if (Object.prototype.hasOwnProperty.call(data, key)) {
      // Skip functions or symbols which are not serializable
      if (typeof data[key] === "function" || typeof data[key] === "symbol") {
        continue;
      }
      // Recursively process nested objects
      result[key] = ensureSerializable(data[key]);
    }
  }
  return result;
}

// Expose protected methods that allow the renderer process to use
// the ipcRenderer without exposing the entire object
contextBridge.exposeInMainWorld("electron", {
  send: (channel, data) => {
    // whitelist channels
    const validChannels = ["open-folder", "request-file-list"];
    if (validChannels.includes(channel)) {
      // Ensure data is serializable before sending
      const serializedData = ensureSerializable(data);
      ipcRenderer.send(channel, serializedData);
    }
  },
  receive: (channel, func) => {
    const validChannels = [
      "folder-selected",
      "file-list-data",
      "file-processing-status",
    ];
    if (validChannels.includes(channel)) {
      // Deliberately strip event as it includes `sender`
      ipcRenderer.on(channel, (event, ...args) => {
        // Convert args to serializable form
        const serializedArgs = args.map(ensureSerializable);
        func(...serializedArgs);
      });
    }
  },
  // For backward compatibility (but still ensure serialization)
  ipcRenderer: {
    send: (channel, data) => {
      const serializedData = ensureSerializable(data);
      ipcRenderer.send(channel, serializedData);
    },
    on: (channel, func) => {
      const wrapper = (event, ...args) => {
        try {
          // Don't pass the event object to the callback, only pass the serialized args
          const serializedArgs = args.map(ensureSerializable);
          func(...serializedArgs); // Only pass the serialized args, not the event
        } catch (err) {
          console.error(`Error in IPC handler for channel ${channel}:`, err);
        }
      };
      ipcRenderer.on(channel, wrapper);
      // Store the wrapper function for removal later
      return wrapper;
    },
    removeListener: (channel, func) => {
      try {
        ipcRenderer.removeListener(channel, func);
      } catch (err) {
        console.error(`Error removing listener for channel ${channel}:`, err);
      }
    },
  },
});


// ---- File: vite.config.ts ----

import { defineConfig } from "vite";
import react from "@vitejs/plugin-react";
import path from "path";

/**
 * Vite Configuration
 * 
 * This configuration file sets up Vite for development and production builds.
 * 
 * Key settings:
 * - Port 3000: Used for development server to match Electron's expectations
 * - strictPort: Ensures the app fails clearly if port 3000 is already in use
 * - Base path: Using relative paths for better cross-platform compatibility
 * - Sourcemaps: Enabled for better debugging in production
 * - Path aliases: Setup for cleaner imports
 */
export default defineConfig({
  plugins: [react()],
  base: "./", // Relative base path for assets - better for cross-platform builds
  server: {
    port: 3000,
    strictPort: true, // Fail if port is already in use - prevents silent port mismatch issues
  },
  build: {
    outDir: "dist",
    emptyOutDir: true,
    sourcemap: true, // Enable sourcemaps for debugging in production
  },
  resolve: {
    alias: {
      "@": path.resolve(__dirname, "./src"),
    },
  },
});


// ---- File: UserInstructions.tsx ----

import React from "react";

interface UserInstructionsProps {
  instructions: string;
  setInstructions: (value: string) => void;
}

const UserInstructions = ({
  instructions,
  setInstructions,
}: UserInstructionsProps): JSX.Element => {
  return (
    <>
      <div className="user-instructions-header">
        <label className="content-title" htmlFor="userInstructionsInput">
          User Instructions
        </label>
      </div>
      <div className="user-instructions-container">
        <div className="user-instructions-description">
          Add custom instructions that will be included with your selected files.
        </div>
        <div className="user-instructions">
          <textarea
            id="userInstructionsInput"
            value={instructions}
            onChange={(e) => setInstructions(e.target.value)}
            placeholder="Enter your instructions here..."
            style={{
              width: "100%",
              resize: "none",
            }}
          />
        </div>
      </div>
    </>
  );
};

export default UserInstructions;


// ---- File: main.tsx ----

import React from "react";
import ReactDOM from "react-dom/client";
import App from "./App";
import "./styles/index.css";

ReactDOM.createRoot(document.getElementById("root")!).render(
  <React.StrictMode>
    <App />
  </React.StrictMode>,
);


// ---- File: build.yml ----
name: Build and Release

on:
  push:
    tags:
      - "v*"

jobs:
  release:
    runs-on: ${{ matrix.os }}

    strategy:
      matrix:
        os: [macos-latest, ubuntu-latest, windows-latest]

    steps:
      - name: Check out Git repository
        uses: actions/checkout@v3

      - name: Set up Node.js
        uses: actions/setup-node@v3
        with:
          node-version: 18
          cache: "npm"

      - name: Debug - Environment info
        run: |
          echo "OS: ${{ runner.os }}"
          echo "Node: $(node -v)"
          echo "NPM: $(npm -v)"
          echo "Working directory: $(pwd)"
          echo "Repository: ${{ github.repository }}"
          echo "Ref: ${{ github.ref }}"

      - name: Install dependencies
        run: npm ci

      - name: List installed packages
        run: npm list --depth=0

      - name: Cache electron-builder cache
        uses: actions/cache@v3
        with:
          path: |
            ~/.cache/electron
            ~/.cache/electron-builder
          key: ${{ runner.os }}-electron-cache-${{ hashFiles('**/package-lock.json') }}
          restore-keys: |
            ${{ runner.os }}-electron-cache-

      - name: Debug - Project structure before build
        run: |
          echo "Project structure:"
          find . -type f -name "package.json" | xargs ls -la
          cat package.json | grep -A 50 "\"build\":"
          ls -la

      - name: Build Vite app
        run: npm run build

      - name: Debug - Check dist directory after Vite build
        run: |
          echo "Dist directory contents:"
          ls -la dist || echo "No dist directory found"

      - name: Build and package macOS app with debug
        if: matrix.os == 'macos-latest'
        run: |
          echo "Running macOS packaging..."
          npm run package:mac --verbose
          echo "Package result:"
          ls -la release-builds || echo "No release-builds directory found"
          find release-builds -type f -name "*.dmg" -o -name "*.zip" || echo "No macOS packages found"
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          DEBUG: electron-builder

      - name: Build and package Windows app with debug
        if: matrix.os == 'windows-latest'
        run: |
          echo "Running Windows packaging..."
          npm run package:win --verbose
          echo "Package result:"
          dir release-builds || echo "No release-builds directory found"
          dir /s /b release-builds\*.exe release-builds\*.msi || echo "No Windows packages found"
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          DEBUG: electron-builder

      - name: Build and package Linux app with debug
        if: matrix.os == 'ubuntu-latest'
        run: |
          echo "Running Linux packaging..."
          npm run package:linux --verbose
          echo "Package result:"
          ls -la release-builds || echo "No release-builds directory found"
          find release-builds -type f -name "*.AppImage" -o -name "*.deb" -o -name "*.rpm" || echo "No Linux packages found"
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          DEBUG: electron-builder

      - name: Debug - List all output files
        run: |
          echo "All potential release files:"
          find . -type f -path "*/release-builds/*" || echo "No files found in release-builds"

      - name: Upload macOS artifacts
        if: matrix.os == 'macos-latest'
        uses: actions/upload-artifact@v3
        with:
          name: macos-artifacts
          path: release-builds/*.{dmg,zip}
          if-no-files-found: warn

      - name: Upload Windows artifacts
        if: matrix.os == 'windows-latest'
        uses: actions/upload-artifact@v3
        with:
          name: windows-artifacts
          path: release-builds/*.{exe,msi}
          if-no-files-found: warn

      - name: Upload Linux artifacts
        if: matrix.os == 'ubuntu-latest'
        uses: actions/upload-artifact@v3
        with:
          name: linux-artifacts
          path: release-builds/*.{AppImage,deb,rpm}
          if-no-files-found: warn

      - name: Debug - Before release
        run: |
          echo "Current directory before release:"
          pwd
          echo "Files that will be included in release:"
          ls -la release-builds || echo "No release-builds directory found"

      - name: Release
        uses: softprops/action-gh-release@v1
        if: startsWith(github.ref, 'refs/tags/')
        with:
          files: release-builds/**
          draft: true
          generate_release_notes: true
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

// ---- File: debug-build.yml ----
name: Debug Build Process

on:
  workflow_dispatch: # Allow manual triggering
  push:
    tags:
      - "debug-v*" # Special tag prefix for debugging

jobs:
  debug_build:
    name: Debug ${{ matrix.os }} Build
    runs-on: ${{ matrix.os }}

    strategy:
      matrix:
        os: [macos-latest] # Start with just macOS for debugging
        # os: [macos-latest, ubuntu-latest, windows-latest] # Uncomment for all platforms

    steps:
      - name: Check out Git repository
        uses: actions/checkout@v3
        with:
          fetch-depth: 0 # Fetch all history for potential debugging needs

      - name: System Information
        run: |
          echo "==== SYSTEM INFO ===="
          echo "OS: ${{ runner.os }}"
          echo "Github ref: ${{ github.ref }}"
          echo "Github SHA: ${{ github.sha }}"
          echo "Architecture: $(uname -m)"
          echo "Python: $(python3 --version || echo 'not installed')"
          echo "Disk space:"
          df -h

      - name: Set up Node.js
        uses: actions/setup-node@v3
        with:
          node-version: 18
          cache: "npm"

      - name: Node.js & NPM Info
        run: |
          echo "==== NODE INFO ===="
          node --version
          npm --version
          npm config list || echo "Cannot list npm config"
          echo "NODE_PATH: $NODE_PATH"
          echo "Path:"
          echo $PATH

      - name: Install dependencies
        run: |
          echo "==== INSTALLING DEPENDENCIES ===="
          npm ci --verbose

      - name: Debug project structure
        run: |
          echo "==== PROJECT STRUCTURE ===="
          find . -type f -not -path "*/node_modules/*" -not -path "*/\.*" | sort

          echo "==== PACKAGE.JSON CONTENT ===="
          cat package.json

      - name: Build step
        run: |
          echo "==== BUILDING APPLICATION ===="
          npm run build

          echo "==== BUILD OUTPUT ===="
          ls -la dist || echo "dist directory not found!"
          find dist -type f | wc -l || echo "No files in dist"

      - name: Debug main.js
        run: |
          echo "==== MAIN.JS CONTENT ===="
          cat main.js || echo "main.js not found!"

      - name: Create directories
        run: |
          echo "==== ENSURING DIRECTORIES ===="
          mkdir -p release-builds
          ls -la release-builds

      - name: Run electron-builder directly
        run: |
          echo "==== RUNNING ELECTRON-BUILDER DIRECTLY ===="
          if [[ "${{ runner.os }}" == "macOS" ]]; then
            npx electron-builder --mac --publish=never --debug
          elif [[ "${{ runner.os }}" == "Linux" ]]; then
            npx electron-builder --linux --publish=never --debug
          elif [[ "${{ runner.os }}" == "Windows" ]]; then
            npx electron-builder --win --publish=never --debug
          fi

      - name: Check output
        run: |
          echo "==== CHECKING OUTPUT ===="
          find . -name "*.dmg" -o -name "*.exe" -o -name "*.AppImage" -o -name "*.zip"

          echo "==== RELEASE BUILDS DIRECTORY ===="
          ls -la release-builds || echo "release-builds directory not found after packaging!"

          echo "==== DEEP LIST OF OUTPUT ===="
          find release-builds -type f || echo "No files in release-builds"

      - name: Upload debug artifacts
        uses: actions/upload-artifact@v3
        with:
          name: debug-${{ runner.os }}-logs
          path: |
            package.json
            main.js
            release-builds/**
            dist/**
            ~/.electron-builder/**
          if-no-files-found: warn

      - name: Create debug release
        uses: softprops/action-gh-release@v1
        if: startsWith(github.ref, 'refs/tags/debug-v')
        with:
          files: release-builds/**/*
          draft: true
          prerelease: true
          name: "Debug Build ${{ github.ref_name }}"
          body: |
            This is a debug build created by the debug-build workflow.
            OS: ${{ runner.os }}
            Node: $(node -v)
            Date: $(date)
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

