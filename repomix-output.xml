This file is a merged representation of the entire codebase, combined into a single document by Repomix.

<file_summary>
This section contains a summary of this file.

<purpose>
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.
</purpose>

<file_format>
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files, each consisting of:
  - File path as an attribute
  - Full contents of the file
</file_format>

<usage_guidelines>
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.
</usage_guidelines>

<notes>
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
- Files are sorted by Git change count (files with more changes are at the bottom)
</notes>

<additional_info>

</additional_info>

</file_summary>

<directory_structure>
.eslintrc.cjs
.gitignore
build.js
CHANGELOG.md
dev.js
docker-compose.yml
Dockerfile
excluded-files.js
index.html
main.js
package.json
paster-instruction.xml
preload.js
renderer.js
scripts/fix-dependencies.js
scripts/notarize.js
scripts/test-local-build.js
scripts/verify-build.js
src/App.tsx
src/assets/favicon.svg
src/components/CopyButton.tsx
src/components/FileCard.tsx
src/components/FileList.tsx
src/components/SearchBar.tsx
src/components/Sidebar.tsx
src/components/ThemeToggle.tsx
src/components/TreeItem.tsx
src/components/UserInstructions.tsx
src/context/ThemeContext.tsx
src/declarations.d.ts
src/index.html
src/main.tsx
src/react-app-env.d.ts
src/styles/index.css
src/types/FileTypes.ts
src/utils/pathUtils.ts
tsconfig.json
tsconfig.node.json
vite.config.ts
</directory_structure>

<files>
This section contains the contents of the repository's files.

<file path="build.js">
/* eslint-disable @typescript-eslint/no-var-requires */
const { execSync } = require("child_process");
const fs = require("fs");
const path = require("path");

async function main() {
  try {
    console.log("üì¶ Building React app with Vite...");
    execSync("npm run build", { stdio: "inherit" });
    console.log("‚úÖ React build completed successfully!");

    // Fix the paths in index.html for Electron compatibility
    const indexHtmlPath = path.join(__dirname, "dist", "index.html");
    if (fs.existsSync(indexHtmlPath)) {
      let content = fs.readFileSync(indexHtmlPath, "utf8");

      // Fix asset paths for Electron's file:// protocol
      content = content.replace(/\/assets\//g, "./assets/");
      content = content.replace(/(src|href)=["']\//g, '$1="./');
      content = content.replace(
        /(src|href)=["']\.\.\/assets\//g,
        '$1="./assets/',
      );

      fs.writeFileSync(indexHtmlPath, content);
      console.log(
        "üîÑ Updated asset paths in index.html for Electron compatibility",
      );
    }

    console.log(
      "üöÄ Build process completed! The app is ready to run with Electron.",
    );

    // Package the app
    console.log("üì¶ Packaging application...");
    execSync("npm run package", { stdio: "inherit" });
    console.log("‚úÖ Packaging completed!");
  } catch (error) {
    console.error("‚ùå Build failed:", error.message);
    process.exit(1);
  }
}

main();
</file>

<file path="docker-compose.yml">
version: '3'

services:
  pastemax-dev:
    build: .
    volumes:
      - .:/app
    working_dir: /app
    tty: true
    stdin_open: true
    command: bash
</file>

<file path="Dockerfile">
FROM node:22

WORKDIR /app

# Install dependencies
RUN apt-get update && apt-get install -y \
    libgtk-3-0 \
    libnotify-dev \
    libgconf-2-4 \
    libnss3 \
    libxss1 \
    libasound2 \
    libxtst6 \
    xvfb \
    wine64 \
    --no-install-recommends \
    && rm -rf /var/lib/apt/lists/*

# We'll mount the project directory as a volume
# This allows for the build artifacts to be accessible from the host

CMD ["bash"]
</file>

<file path="excluded-files.js">
// List of common files to exclude by default
// Users can still manually select these files if needed
// Paths can include glob patterns (*, **, etc.)

module.exports = {
  // Files to always exclude by default when a folder is first loaded
  excludedFiles: [
    // NPM/Yarn/Node related
    "package-lock.json",
    "yarn.lock",
    "npm-debug.log*",
    "yarn-debug.log*",
    "yarn-error.log*",
    "pnpm-lock.yaml",
    ".npmrc",
    ".yarnrc",
    ".nvmrc",
    "node_modules/**",

    // JavaScript/TypeScript related
    ".eslintrc*",
    ".prettierrc*",
    "tsconfig*.json",
    "*.d.ts",
    "*.min.js",
    "*.map",

    // Python related
    "__pycache__/**",
    "*.pyc",
    "*.pyo",
    "*.pyd",
    ".pytest_cache/**",
    ".coverage",
    ".python-version",
    "venv/**",
    ".venv/**",
    "*.egg-info/**",
    "pip-log.txt",
    "pip-delete-this-directory.txt",

    // Go related
    "go.sum",
    "go.mod",
    "vendor/**",

    // Java related
    "*.class",
    "*.jar",
    "target/**",
    ".gradle/**",

    // Ruby related
    "Gemfile.lock",
    ".bundle/**",

    // PHP related
    "composer.lock",
    "vendor/**",

    // Rust related
    "Cargo.lock",
    "target/**",

    // .NET related
    "bin/**",
    "obj/**",
    "*.suo",
    "*.user",

    // Binary and image files
    "*.jpg",
    "*.jpeg",
    "*.png",
    "*.gif",
    "*.ico",
    "*.webp",
    "*.svg",
    "*.pdf",
    "*.zip",
    "*.tar.gz",
    "*.tgz",
    "*.rar",

    // IDE and editor files
    ".idea/**",
    ".vscode/**",
    "*.swp",
    "*.swo",
    ".DS_Store",

    // Build output
    "dist/**",
    "build/**",
    "out/**",
    ".next/**",

    // Log files
    "logs/**",
    "*.log",

    // Database files
    "*.sqlite",
    "*.db",

    // Environment and secrets
    ".env*",
    ".aws/**",
    "*.pem",
    "*.key",

    // Docker related
    "docker-compose.override.yml",

    // Misc
    ".git/**",
    ".github/**",
    ".gitlab/**",
  ],

  // File extensions to always mark as binary/unselectable
  // The app already has binary detection, but this ensures specific types
  // are always treated as binary regardless of content detection
  binaryExtensions: [
    // Images (including .svg which might not be detected as binary)
    ".svg",
    ".jpg",
    ".jpeg",
    ".png",
    ".gif",
    ".bmp",
    ".tiff",
    ".ico",
    ".webp",

    // Other binary formats
    ".pdf",
    ".doc",
    ".docx",
    ".xls",
    ".xlsx",
    ".ppt",
    ".pptx",
  ],
};
</file>

<file path="index.html">
<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <link rel="icon" type="image/svg+xml" href="/favicon.svg" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>PasteMax</title>
    <link
      href="https://fonts.googleapis.com/css2?family=Roboto:wght@300;400;500;700&display=swap"
      rel="stylesheet"
    />
  </head>
  <body>
    <div id="root"></div>
    <script type="module" src="/src/main.tsx"></script>
  </body>
</html>
</file>

<file path="paster-instruction.xml">
<Instructions>
  <ToolUse>
    <Formatting><![CDATA[
Tool use is formatted using XML-style tags. The tool name is enclosed in opening and closing tags, and each parameter is similarly enclosed within its own set of tags. Here's the structure:

<tool_name>
<parameter1_name>value1</parameter1_name>
<parameter2_name>value2</parameter2_name>
...
</tool_name>

For example:

<read_file>
<path>src/main.js</path>
</read_file>

Always adhere to this format for the tool use to ensure proper parsing and execution.
    ]]></Formatting>
  </ToolUse>
  <Tools>
    <Tool name="read_file">
      <Description><![CDATA[
Request to read the contents of a file at the specified path. Use this to examine the contents of an existing file, such as to analyze code, review text files, or extract information from configuration files. The output includes line numbers prefixed to each line (e.g., "1 | const x = 1"), aiding in referencing specific lines. By specifying `start_line` and `end_line`, you can read specific portions of large files efficiently. Automatically extracts raw text from PDF and DOCX files but may not suit other binary files, returning raw content as a string.
      ]]></Description>
      <Parameters>
        <Parameter name="path" required="true"><![CDATA[The path of the file to read (relative to the current working directory)]]></Parameter>
        <Parameter name="start_line" required="false"><![CDATA[Starting line number to read from (1-based). Defaults to the beginning if not provided.]]></Parameter>
        <Parameter name="end_line" required="false"><![CDATA[Ending line number to read to (1-based, inclusive). Defaults to the end if not provided.]]></Parameter>
      </Parameters>
      <Usage><![CDATA[
<read_file>
<path>path/to/file</path>
<start_line>starting line number (optional)</start_line>
<end_line>ending line number (optional)</end_line>
</read_file>
      ]]></Usage>
      <Examples>
        <Example>
          <Description><![CDATA[Reading an entire file]]></Description>
          <Code><![CDATA[
<read_file>
<path>config.json</path>
</read_file>
          ]]></Code>
        </Example>
        <Example>
          <Description><![CDATA[Reading the first 1000 lines of a log file]]></Description>
          <Code><![CDATA[
<read_file>
<path>logs/application.log</path>
<end_line>1000</end_line>
</read_file>
          ]]></Code>
        </Example>
        <Example>
          <Description><![CDATA[Reading lines 500-1000 of a CSV file]]></Description>
          <Code><![CDATA[
<read_file>
<path>data/large-dataset.csv</path>
<start_line>500</start_line>
<end_line>1000</end_line>
</read_file>
          ]]></Code>
        </Example>
        <Example>
          <Description><![CDATA[Reading a specific function in a source file]]></Description>
          <Code><![CDATA[
<read_file>
<path>src/app.ts</path>
<start_line>46</start_line>
<end_line>68</end_line>
</read_file>
          ]]></Code>
        </Example>
      </Examples>
      <Note><![CDATA[
When both `start_line` and `end_line` are provided, this tool streams only the requested lines, making it suitable for large files like logs or datasets without memory issues.
      ]]></Note>
    </Tool>
    <Tool name="search_files">
      <Description><![CDATA[
Perform a regex search across files in a specified directory, providing context-rich results with surrounding lines. Useful for finding code patterns or specific content across multiple files.
      ]]></Description>
      <Parameters>
        <Parameter name="path" required="true"><![CDATA[The directory path to search (relative to the current working directory). Searched recursively.]]></Parameter>
        <Parameter name="regex" required="true"><![CDATA[The regular expression pattern to search for (Rust regex syntax).]]></Parameter>
        <Parameter name="file_pattern" required="false"><![CDATA[Glob pattern to filter files (e.g., '*.ts' for TypeScript files). Defaults to all files (*) if not provided.]]></Parameter>
      </Parameters>
      <Usage><![CDATA[
<search_files>
<path>directory/path</path>
<regex>your regex pattern</regex>
<file_pattern>file pattern (optional)</file_pattern>
</search_files>
      ]]></Usage>
      <Examples>
        <Example>
          <Description><![CDATA[Search for all .ts files in the current directory]]></Description>
          <Code><![CDATA[
<search_files>
<path>.</path>
<regex>.*</regex>
<file_pattern>*.ts</file_pattern>
</search_files>
          ]]></Code>
        </Example>
      </Examples>
    </Tool>
    <Tool name="list_files">
      <Description><![CDATA[
List files and directories within a specified directory. If `recursive` is true, lists all contents recursively; otherwise, lists only top-level contents. Do not use to confirm file creation‚Äîrely on user feedback for that.
      ]]></Description>
      <Parameters>
        <Parameter name="path" required="true"><![CDATA[The directory path to list (relative to the current working directory)]]></Parameter>
        <Parameter name="recursive" required="false"><![CDATA[Whether to list files recursively. Use 'true' for recursive, 'false' or omit for top-level only.]]></Parameter>
      </Parameters>
      <Usage><![CDATA[
<list_files>
<path>directory/path</path>
<recursive>true or false (optional)</recursive>
</list_files>
      ]]></Usage>
      <Examples>
        <Example>
          <Description><![CDATA[List all files in the current directory]]></Description>
          <Code><![CDATA[
<list_files>
<path>.</path>
<recursive>false</recursive>
</list_files>
          ]]></Code>
        </Example>
      </Examples>
    </Tool>
    <Tool name="list_code_definition_names">
      <Description><![CDATA[
List definition names (classes, functions, methods, etc.) in source code files at the top level of a specified directory. Provides insights into codebase structure and relationships.
      ]]></Description>
      <Parameters>
        <Parameter name="path" required="true"><![CDATA[The directory path to list definitions for (relative to the current working directory)]]></Parameter>
      </Parameters>
      <Usage><![CDATA[
<list_code_definition_names>
<path>directory/path</path>
</list_code_definition_names>
      ]]></Usage>
      <Examples>
        <Example>
          <Description><![CDATA[List all top-level source code definitions in the current directory]]></Description>
          <Code><![CDATA[
<list_code_definition_names>
<path>.</path>
</list_code_definition_names>
          ]]></Code>
        </Example>
      </Examples>
    </Tool>
    <Tool name="apply_diff">
      <Description><![CDATA[
Replace existing code using a search and replace block. Allows precise changes while maintaining indentation and formatting. Only one operation per use. The SEARCH section must exactly match existing content, including whitespace. Use `read_file` first if unsure of content. Update affected syntax (e.g., closing brackets) as needed.
      ]]></Description>
      <Parameters>
        <Parameter name="path" required="true"><![CDATA[The file path to modify (relative to the current working directory)]]></Parameter>
        <Parameter name="diff" required="true"><![CDATA[The search/replace block defining changes.]]></Parameter>
      </Parameters>
      <Usage><![CDATA[
<apply_diff>
<path>path/to/file</path>
<diff>
Your search/replace content here
</diff>
</apply_diff>
      ]]></Usage>
      <Examples>
        <Example>
          <Description><![CDATA[Replace a function with a new implementation]]></Description>
          <Code><![CDATA[
<apply_diff>
<path>path/to/file</path>
<diff>
<<<<<<< SEARCH
:start_line:1
:end_line:5
-------
def calculate_total(items):
    total = 0
    for item in items:
        total += item
    return total
=======
def calculate_total(items):
    """Calculate total with 10% markup"""
    return sum(item * 1.1 for item in items)
>>>>>>> REPLACE
</diff>
</apply_diff>
          ]]></Code>
        </Example>
      </Examples>
    </Tool>
    <Tool name="write_to_file">
      <Description><![CDATA[
Write full content to a file at the specified path. Overwrites existing files or creates new ones, automatically creating necessary directories.
      ]]></Description>
      <Parameters>
        <Parameter name="path" required="true"><![CDATA[The file path to write to (relative to the current working directory)]]></Parameter>
        <Parameter name="content" required="true"><![CDATA[The complete file content. Must include all parts, even unmodified sections, without line numbers.]]></Parameter>
        <Parameter name="line_count" required="true"><![CDATA[Total number of lines in the content, including empty lines.]]></Parameter>
      </Parameters>
      <Usage><![CDATA[
<write_to_file>
<path>path/to/file</path>
<content>
Your file content here
</content>
<line_count>total number of lines</line_count>
</write_to_file>
      ]]></Usage>
      <Examples>
        <Example>
          <Description><![CDATA[Write to config.json]]></Description>
          <Code><![CDATA[
<write_to_file>
<path>config.json</path>
<content>
{
  "apiEndpoint": "https://api.example.com",
  "theme": {
    "primaryColor": "#007bff",
    "secondaryColor": "#6c757d",
    "fontFamily": "Arial, sans-serif"
  },
  "features": {
    "darkMode": true,
    "notifications": true,
    "analytics": false
  },
  "version": "1.0.0"
}
</content>
<line_count>14</line_count>
</write_to_file>
          ]]></Code>
        </Example>
      </Examples>
    </Tool>
    <Tool name="insert_content">
      <Description><![CDATA[
Insert content at specific line positions in a file. Ideal for adding new code (e.g., functions, imports) without overwriting existing content. Uses line-based insertion for precision.
      ]]></Description>
      <Parameters>
        <Parameter name="path" required="true"><![CDATA[The file path to insert into (relative to the current working directory)]]></Parameter>
        <Parameter name="operations" required="true"><![CDATA[A JSON array of insertion operations, each with `start_line` and `content`.]]></Parameter>
      </Parameters>
      <Usage><![CDATA[
<insert_content>
<path>path/to/file</path>
<operations>[{
  "start_line": 10,
  "content": "Your content here"
}]</operations>
</insert_content>
      ]]></Usage>
      <Examples>
        <Example>
          <Description><![CDATA[Insert a new function and import statement]]></Description>
          <Code><![CDATA[
<insert_content>
<path>path/to/file</path>
<operations>[{
  "start_line": 1,
  "content": "import { sum } from './utils';"
}, {
  "start_line": 10,
  "content": "function calculateTotal(items: number[]): number {\n  return items.reduce((sum, item) => sum + item, 0);\n}"
}]</operations>
</insert_content>
          ]]></Code>
        </Example>
      </Examples>
    </Tool>
    <Tool name="search_and_replace">
      <Description><![CDATA[
Perform search and replace operations on a file. Supports string or regex patterns, with optional line range restrictions. Shows a diff preview before applying changes.
      ]]></Description>
      <Parameters>
        <Parameter name="path" required="true"><![CDATA[The file path to modify (relative to the current working directory)]]></Parameter>
        <Parameter name="operations" required="true"><![CDATA[A JSON array of search/replace operations.]]></Parameter>
      </Parameters>
      <Usage><![CDATA[
<search_and_replace>
<path>path/to/file</path>
<operations>[{
  "search": "text to find",
  "replace": "replacement text",
  "start_line": 1,
  "end_line": 10
}]</operations>
</search_and_replace>
      ]]></Usage>
      <Examples>
        <Example>
          <Description><![CDATA[Replace "foo" with "bar" in lines 1-10]]></Description>
          <Code><![CDATA[
<search_and_replace>
<path>example.ts</path>
<operations>[{
  "search": "foo",
  "replace": "bar",
  "start_line": 1,
  "end_line": 10
}]</operations>
</search_and_replace>
          ]]></Code>
        </Example>
      </Examples>
    </Tool>
    <Tool name="browser_action">
      <Description><![CDATA[
Interact with a Puppeteer-controlled browser. Each action (except `close`) returns a screenshot and console logs. Use one action per message, starting with `launch` and ending with `close`. Only use this tool while the browser is active.
      ]]></Description>
      <Parameters>
        <Parameter name="action" required="true"><![CDATA[One of: `launch`, `click`, `type`, `scroll_down`, `scroll_up`, `close`]]></Parameter>
        <Parameter name="url" required="false"><![CDATA[URL for `launch` (e.g., `http://localhost:3000`)]]></Parameter>
        <Parameter name="coordinate" required="false"><![CDATA[X,Y coordinates for `click` (within 900x600 resolution)]]></Parameter>
        <Parameter name="text" required="false"><![CDATA[Text for `type`]]></Parameter>
      </Parameters>
      <Usage><![CDATA[
<browser_action>
<action>action to perform</action>
<url>URL (optional)</url>
<coordinate>x,y coordinates (optional)</coordinate>
<text>text to type (optional)</text>
</browser_action>
      ]]></Usage>
      <Examples>
        <Example>
          <Description><![CDATA[Launch a browser at https://example.com]]></Description>
          <Code><![CDATA[
<browser_action>
<action>launch</action>
<url>https://example.com</url>
</browser_action>
          ]]></Code>
        </Example>
      </Examples>
    </Tool>
    <Tool name="execute_command">
      <Description><![CDATA[
Execute a CLI command on the system. Tailor commands to the user's environment and explain their purpose. Prefer complex commands over scripts.
      ]]></Description>
      <Parameters>
        <Parameter name="command" required="true"><![CDATA[The CLI command to execute]]></Parameter>
        <Parameter name="cwd" required="false"><![CDATA[Working directory for the command (default: project base directory)]]></Parameter>
      </Parameters>
      <Usage><![CDATA[
<execute_command>
<command>your command here</command>
<cwd>working directory path (optional)</cwd>
</execute_command>
      ]]></Usage>
      <Examples>
        <Example>
          <Description><![CDATA[Execute npm run dev]]></Description>
          <Code><![CDATA[
<execute_command>
<command>npm run dev</command>
</execute_command>
          ]]></Code>
        </Example>
      </Examples>
    </Tool>
    <Tool name="ask_followup_question">
      <Description><![CDATA[
Ask the user for additional information when needed. Provide 2-4 specific, actionable suggested answers.
      ]]></Description>
      <Parameters>
        <Parameter name="question" required="true"><![CDATA[A clear, specific question]]></Parameter>
        <Parameter name="follow_up" required="true"><![CDATA[2-4 suggested answers in `<suggest>` tags]]></Parameter>
      </Parameters>
      <Usage><![CDATA[
<ask_followup_question>
<question>your question here</question>
<follow_up>
<suggest>your suggested answer here</suggest>
</follow_up>
</ask_followup_question>
      ]]></Usage>
      <Examples>
        <Example>
          <Description><![CDATA[Ask for the path to config.json]]></Description>
          <Code><![CDATA[
<ask_followup_question>
<question>What is the path to the config.json file?</question>
<follow_up>
<suggest>./src/config.json</suggest>
<suggest>./config/config.json</suggest>
<suggest>./config.json</suggest>
</follow_up>
</ask_followup_question>
          ]]></Code>
        </Example>
      </Examples>
    </Tool>
    <Tool name="attempt_completion">
      <Description><![CDATA[
Present the task result to the user after confirming all prior tool uses succeeded. Do not use until success is confirmed.
      ]]></Description>
      <Parameters>
        <Parameter name="result" required="true"><![CDATA[Final task result (no questions or further requests)]]></Parameter>
        <Parameter name="command" required="false"><![CDATA[CLI command to demo the result (e.g., `open index.html`)]]></Parameter>
      </Parameters>
      <Usage><![CDATA[
<attempt_completion>
<result>
your final result description here
</result>
<command>command to demonstrate result (optional)</command>
</attempt_completion>
      ]]></Usage>
      <Examples>
        <Example>
          <Description><![CDATA[Attempt completion with result and command]]></Description>
          <Code><![CDATA[
<attempt_completion>
<result>
I've updated the CSS
</result>
<command>open index.html</command>
</attempt_completion>
          ]]></Code>
        </Example>
      </Examples>
    </Tool>
    <Tool name="switch_mode">
      <Description><![CDATA[
Request to switch to a different mode, pending user approval.
      ]]></Description>
      <Parameters>
        <Parameter name="mode_slug" required="true"><![CDATA[The mode slug (e.g., "code")]]></Parameter>
        <Parameter name="reason" required="false"><![CDATA[Reason for switching]]></Parameter>
      </Parameters>
      <Usage><![CDATA[
<switch_mode>
<mode_slug>mode slug here</mode_slug>
<reason>reason for switching here</reason>
</switch_mode>
      ]]></Usage>
      <Examples>
        <Example>
          <Description><![CDATA[Switch to code mode]]></Description>
          <Code><![CDATA[
<switch_mode>
<mode_slug>code</mode_slug>
<reason>Need to make code changes</reason>
</switch_mode>
          ]]></Code>
        </Example>
      </Examples>
    </Tool>
    <Tool name="new_task">
      <Description><![CDATA[
Create a new task with a specified mode and initial message.
      ]]></Description>
      <Parameters>
        <Parameter name="mode" required="true"><![CDATA[The mode slug (e.g., "code")]]></Parameter>
        <Parameter name="message" required="true"><![CDATA[Initial instructions for the new task]]></Parameter>
      </Parameters>
      <Usage><![CDATA[
<new_task>
<mode>your-mode-slug-here</mode>
<message>your initial instructions here</message>
</new_task>
      ]]></Usage>
      <Examples>
        <Example>
          <Description><![CDATA[Create a new task in code mode]]></Description>
          <Code><![CDATA[
<new_task>
<mode>code</mode>
<message>Implement a new feature for the application.</message>
</new_task>
          ]]></Code>
        </Example>
      </Examples>
    </Tool>
  </Tools>
  <Capabilities>
    <Capability><![CDATA[
You have tools to execute CLI commands, list files, view code definitions, perform regex searches, use the browser, read/write files, and ask follow-up questions, enabling tasks like coding, editing, and system operations.
    ]]></Capability>
    <Capability><![CDATA[
Initial tasks include a recursive file list in `environment_details` for project overview. Use `list_files` to explore further directories.
    ]]></Capability>
    <Capability><![CDATA[
Use `search_files` for regex searches across files, `list_code_definition_names` for code overviews, `execute_command` for system commands, and `browser_action` for web interactions.
    ]]></Capability>
  </Capabilities>
  <Modes>
    <Mode slug="code">
      <Name><![CDATA[Code]]></Name>
      <RoleDefinition><![CDATA[
You are Roo, a highly skilled software engineer with extensive knowledge in many programming languages, frameworks, design patterns, and best practices
      ]]></RoleDefinition>
    </Mode>
    <Mode slug="architect">
      <Name><![CDATA[Architect]]></Name>
      <RoleDefinition><![CDATA[
You are Roo, an experienced technical leader who is inquisitive and an excellent planner
      ]]></RoleDefinition>
    </Mode>
    <Mode slug="ask">
      <Name><![CDATA[Ask]]></Name>
      <RoleDefinition><![CDATA[
You are Roo, a knowledgeable technical assistant focused on answering questions and providing information about software development, technology, and related topics
      ]]></RoleDefinition>
    </Mode>
    <Mode slug="debug">
      <Name><![CDATA[Debug]]></Name>
      <RoleDefinition><![CDATA[
You are Roo, an expert software debugger specializing in systematic problem diagnosis and resolution
      ]]></RoleDefinition>
    </Mode>
  </Modes>
  <Rules>
    <Rule><![CDATA[
All file paths are relative to the project base directory. Respect terminal working directories from `<execute_command>` responses.
    ]]></Rule>
    <Rule><![CDATA[
Cannot `cd` to other directories; use correct `path` parameters.
    ]]></Rule>
    <Rule><![CDATA[
Tailor `execute_command` to the user's system, prepending `cd` if needed.
    ]]></Rule>
    <Rule><![CDATA[
Craft `search_files` regex patterns carefully, analyzing context with other tools.
    ]]></Rule>
    <Rule><![CDATA[
Organize new projects logically within a dedicated directory unless specified otherwise.
    ]]></Rule>
    <Rule><![CDATA[
Use `apply_diff`, `write_to_file`, `insert_content`, or `search_and_replace` for file edits. Prefer others over `write_to_file` for existing files due to speed.
    ]]></Rule>
    <Rule><![CDATA[
Provide complete file content with `write_to_file`. Partial updates are forbidden.
    ]]></Rule>
    <Rule><![CDATA[
Some modes restrict editable files; violations trigger a `FileRestrictionError`.
    ]]></Rule>
    <Rule><![CDATA[
Consider project type and context for changes, adhering to coding standards.
    ]]></Rule>
    <Rule><![CDATA[
Minimize questions, using tools efficiently. Use `attempt_completion` when done.
    ]]></Rule>
    <Rule><![CDATA[
Ask questions only via `ask_followup_question` with 2-4 suggestions.
    ]]></Rule>
    <Rule><![CDATA[
Assume command success if output is missing; request output via `ask_followup_question` if needed.
    ]]></Rule>
    <Rule><![CDATA[
Do not re-read provided file contents with `read_file`.
    ]]></Rule>
    <Rule><![CDATA[
Focus on task completion, not conversation.
    ]]></Rule>
    <Rule><![CDATA[
Use `browser_action` for non-development tasks if suitable.
    ]]></Rule>
    <Rule><![CDATA[
End `attempt_completion` results definitively, without questions.
    ]]></Rule>
    <Rule><![CDATA[
Avoid conversational starters (e.g., "Great"). Be direct and technical.
    ]]></Rule>
    <Rule><![CDATA[
Analyze images with vision capabilities for task insights.
    ]]></Rule>
    <Rule><![CDATA[
Use `environment_details` for context, not as user input, explaining actions clearly.
    ]]></Rule>
    <Rule><![CDATA[
Check "Actively Running Terminals" in `environment_details` before commands.
    ]]></Rule>
    <Rule><![CDATA[
Wait for user confirmation after each tool use before proceeding.
    ]]></Rule>
  </Rules>
  <Objective>
    <Step><![CDATA[
1. Analyze and set clear goals in logical order.
    ]]></Step>
    <Step><![CDATA[
2. Work sequentially, using one tool at a time, informed by prior results.
    ]]></Step>
    <Step><![CDATA[
3. Analyze in `<thinking>` tags: assess `environment_details`, choose tools, verify parameters, and proceed or ask for missing info.
    ]]></Step>
    <Step><![CDATA[
4. Use `attempt_completion` with a demo command when done.
    ]]></Step>
    <Step><![CDATA[
5. Use feedback to improve, avoiding unnecessary conversation.
    ]]></Step>
  </Objective>
  <UserCustomInstructions>
    <LanguagePreference><![CDATA[
Use English unless instructed otherwise.
    ]]></LanguagePreference>
    <GlobalInstructions><![CDATA[
Provide XML tool responses as copyable.
    ]]></GlobalInstructions>
    <ModeSpecificInstructions><![CDATA[
Provide XML tool responses as copyable.
    ]]></ModeSpecificInstructions>
  </UserCustomInstructions>
</Instructions>
</file>

<file path="renderer.js">
// Use the exposed electron API instead of direct require
// const { ipcRenderer } = require("electron");

// Track selected files
let selectedFiles = [];
let allFiles = []; // Store all file data
let displayedFiles = []; // Files after filtering and sorting
let currentSort = "name-asc"; // Default sort
let currentFilter = ""; // Current filter text

const openFolderButton = document.getElementById("open-folder-button");
const selectAllButton = document.getElementById("select-all-button");
const deselectAllButton = document.getElementById("deselect-all-button");
const sortDropdown = document.getElementById("sort-dropdown");
const filterInput = document.getElementById("filter-input");
const copyButton = document.getElementById("copy-button");
const copyStatus = document.getElementById("copy-status");

openFolderButton.addEventListener("click", () => {
  // Use the exposed IPC method from preload.js
  window.electron.send("open-folder");
});

// Set up the IPC listeners using the exposed API
window.electron.receive("folder-selected", (selectedPath) => {
  // Store or display the selected path
  const selectedFolderDisplay = document.getElementById(
    "selected-folder-display",
  );
  selectedFolderDisplay.textContent = `Selected Folder: ${selectedPath}`;

  // Reset selected files when a new folder is selected
  selectedFiles = [];
  allFiles = [];
  displayedFiles = [];

  // Reset filter input
  filterInput.value = "";
  currentFilter = "";

  // Request file list data
  window.electron.send("request-file-list", selectedPath);
});

// Also update the file-list-data listener
window.electron.receive("file-list-data", (files) => {
  // Handle received files data
  allFiles = files;
  applyFiltersAndSort();
});

// Sort the files based on the selected sort option
function sortFiles(files, sortValue) {
  const [sortKey, sortDir] = sortValue.split("-"); // e.g. 'name', 'asc'

  return [...files].sort((a, b) => {
    let comparison = 0;

    if (sortKey === "name") {
      comparison = a.name.localeCompare(b.name);
    } else if (sortKey === "tokens") {
      comparison = a.tokenCount - b.tokenCount;
    } else if (sortKey === "size") {
      comparison = a.size - b.size;
    }

    return sortDir === "asc" ? comparison : -comparison;
  });
}

// Sort dropdown change handler
sortDropdown.addEventListener("change", () => {
  currentSort = sortDropdown.value;
  applyFiltersAndSort();
});

// Filter function to filter files by name or path
function filterFiles(files, filterText) {
  if (!filterText) {
    return files;
  }

  const lowerFilter = filterText.toLowerCase();
  return files.filter((file) => {
    return (
      file.name.toLowerCase().includes(lowerFilter) ||
      file.path.toLowerCase().includes(lowerFilter)
    );
  });
}

// Filter input event handler
filterInput.addEventListener("input", () => {
  currentFilter = filterInput.value;
  applyFiltersAndSort();
});

// Apply both filtering and sorting
function applyFiltersAndSort() {
  // First filter
  displayedFiles = filterFiles(allFiles, currentFilter);
  // Then sort
  displayedFiles = sortFiles(displayedFiles, currentSort);
  // Render the list
  renderFileList(displayedFiles);
}

// Calculate total tokens from selected files
function calculateTotalTokens() {
  let total = 0;

  selectedFiles.forEach((selectedPath) => {
    const fileData = allFiles.find((f) => f.path === selectedPath);
    if (fileData) {
      total += fileData.tokenCount;
    }
  });

  return total;
}

// Update the total tokens display
function updateTotalTokens() {
  const totalTokens = calculateTotalTokens();
  document.getElementById(
    "total-tokens",
  ).textContent = `Total Tokens: ${totalTokens.toLocaleString()}`;
}

// Handle checkbox changes
function handleCheckboxChange(event) {
  const filePath = event.target.value;
  if (event.target.checked) {
    if (!selectedFiles.includes(filePath)) {
      selectedFiles.push(filePath);
    }
  } else {
    selectedFiles = selectedFiles.filter((path) => path !== filePath);
  }
  updateTotalTokens();
  console.log("Selected files:", selectedFiles.length);
}

// Select All button functionality
selectAllButton.addEventListener("click", () => {
  const checkboxes = document.querySelectorAll(
    '#file-list input[type="checkbox"]',
  );

  // Get the paths of all currently displayed files
  const displayedPaths = displayedFiles.map((file) => file.path);

  // Remove any previously selected files that are no longer displayed
  selectedFiles = selectedFiles.filter((path) => displayedPaths.includes(path));

  // Add all currently displayed files
  checkboxes.forEach((checkbox) => {
    checkbox.checked = true;
    const filePath = checkbox.value;
    if (!selectedFiles.includes(filePath)) {
      selectedFiles.push(filePath);
    }
  });

  updateTotalTokens();
  console.log("Selected all displayed files:", selectedFiles.length);
});

// Deselect All button functionality
deselectAllButton.addEventListener("click", () => {
  const checkboxes = document.querySelectorAll(
    '#file-list input[type="checkbox"]',
  );

  // Get the paths of all currently displayed files
  const displayedPaths = displayedFiles.map((file) => file.path);

  // Remove currently displayed files from selection
  selectedFiles = selectedFiles.filter(
    (path) => !displayedPaths.includes(path),
  );

  // Uncheck all displayed checkboxes
  checkboxes.forEach((checkbox) => {
    checkbox.checked = false;
  });

  updateTotalTokens();
  console.log("Deselected all displayed files");
});

// Format file size to be human-readable
function formatFileSize(bytes) {
  if (bytes === 0) return "0 B";

  const units = ["B", "KB", "MB", "GB", "TB"];
  const i = Math.floor(Math.log(bytes) / Math.log(1024));

  return parseFloat((bytes / Math.pow(1024, i)).toFixed(2)) + " " + units[i];
}

// Concatenate selected files
function concatenateSelectedFiles() {
  // Get sorted files (both displayed and not displayed)
  const sortedFiles = sortFiles(allFiles, currentSort);

  // Filter to only include selected files
  const sortedSelectedFiles = sortedFiles.filter((file) =>
    selectedFiles.includes(file.path),
  );

  if (sortedSelectedFiles.length === 0) {
    return "No files selected.";
  }

  let concatenatedString = "";

  sortedSelectedFiles.forEach((file) => {
    concatenatedString += `\n\n// ---- File: ${file.name} ----\n\n`;
    concatenatedString += file.content;
  });

  return concatenatedString;
}

// Copy to clipboard functionality
copyButton.addEventListener("click", async () => {
  const content = concatenateSelectedFiles();

  try {
    await navigator.clipboard.writeText(content);

    // Show the "Copied!" status
    copyStatus.classList.add("visible");

    // Hide the status after 2 seconds
    setTimeout(() => {
      copyStatus.classList.remove("visible");
    }, 2000);

    console.log("Content copied to clipboard");
  } catch (err) {
    console.error("Could not copy content: ", err);
    alert("Failed to copy to clipboard");
  }
});

// Render the file list with the current data and sorting
function renderFileList(files) {
  const fileList = document.getElementById("file-list");
  // Clear existing list
  fileList.innerHTML = "";

  files.forEach((file) => {
    const li = document.createElement("li");

    // Create checkbox
    const checkbox = document.createElement("input");
    checkbox.type = "checkbox";
    checkbox.value = file.path;

    // Don't allow selecting binary or skipped files
    if (file.isBinary || file.isSkipped) {
      checkbox.disabled = true;
    } else {
      checkbox.addEventListener("change", handleCheckboxChange);
      // If this file is in selectedFiles, check the box
      if (selectedFiles.includes(file.path)) {
        checkbox.checked = true;
      }
    }

    // Create label for the filename
    const label = document.createElement("span");
    label.textContent = file.name;

    // Apply styling for binary and skipped files
    if (file.isBinary) {
      li.classList.add("binary-file");
      label.innerHTML = `${file.name} <span class="file-badge binary-badge">${file.fileType}</span>`;
    } else if (file.isSkipped) {
      li.classList.add("skipped-file");
      label.innerHTML = `${file.name} <span class="file-badge error-badge">${file.error}</span>`;
    }

    // Create token count display
    const tokenCountSpan = document.createElement("span");
    if (file.isBinary || file.isSkipped) {
      tokenCountSpan.textContent = " (Tokens: N/A)";
    } else {
      tokenCountSpan.textContent = ` (Tokens: ${file.tokenCount.toLocaleString()})`;
    }
    tokenCountSpan.style.color = "#666";
    tokenCountSpan.style.marginLeft = "10px";

    // Create file size display
    const fileSizeSpan = document.createElement("span");
    fileSizeSpan.textContent = ` (Size: ${formatFileSize(file.size)})`;
    fileSizeSpan.style.color = "#666";
    fileSizeSpan.style.marginLeft = "5px";

    // Add the checkbox and labels to the list item
    li.appendChild(checkbox);
    li.appendChild(label);
    li.appendChild(tokenCountSpan);
    li.appendChild(fileSizeSpan);

    fileList.appendChild(li);
  });
}
</file>

<file path="scripts/fix-dependencies.js">
#!/usr/bin/env node

/**
 * This script helps fix dependency issues in the packaged Electron app
 * by ensuring all required modules are properly copied to the application directory.
 */

const { execSync } = require("child_process");
const fs = require("fs");
const path = require("path");

console.log("üîß PasteMax Dependency Fixer");
console.log("============================");

// Define the dependencies we need to ensure are installed
const criticalDependencies = ["ignore", "tiktoken", "gpt-3-encoder"];

// Get the application path (platform-dependent)
function getAppResourcesPath() {
  const platform = process.platform;
  let appPath;

  try {
    if (platform === "darwin") {
      // macOS
      const homeDir = process.env.HOME;
      const appDir =
        "/Applications/PasteMax.app/Contents/Resources/app.asar.unpacked";
      appPath = path.join(appDir, "node_modules");
    } else if (platform === "win32") {
      // Windows
      const programFiles = process.env["ProgramFiles"];
      appPath = path.join(
        programFiles,
        "PasteMax",
        "resources",
        "app.asar.unpacked",
        "node_modules",
      );
    } else {
      // Linux
      appPath = "/usr/lib/pastemax/resources/app.asar.unpacked/node_modules";
    }

    return appPath;
  } catch (err) {
    console.error("‚ùå Could not determine application path:", err.message);
    return null;
  }
}

// Ensure dependencies are installed properly
function fixDependencies() {
  try {
    // First, check if we're in the right directory
    if (!fs.existsSync("./package.json")) {
      console.error(
        "‚ùå Error: package.json not found! Please run this script from the PasteMax source directory.",
      );
      process.exit(1);
    }

    // Install required dependencies
    console.log("üì¶ Installing dependencies locally...");
    execSync("npm install ignore tiktoken gpt-3-encoder --no-save", {
      stdio: "inherit",
    });

    // Build the app with the asar.unpacked option
    console.log("üîÑ Updating package.json build configuration...");

    // Read package.json
    const packageJson = JSON.parse(fs.readFileSync("./package.json", "utf8"));

    // Update build configuration
    if (!packageJson.build) {
      packageJson.build = {};
    }

    packageJson.build.asarUnpack = [
      "node_modules/ignore/**",
      "node_modules/tiktoken/**",
      "node_modules/gpt-3-encoder/**",
    ];

    // Write updated package.json
    fs.writeFileSync("./package.json", JSON.stringify(packageJson, null, 2));

    console.log("‚úÖ package.json updated with asarUnpack configuration");
    console.log("");
    console.log("üöÄ Build your app with:");
    console.log("npm run build-electron && npm run dist");
    console.log("");
    console.log(
      "This will create a distributable that correctly includes the critical dependencies.",
    );
  } catch (err) {
    console.error("‚ùå Error fixing dependencies:", err.message);
  }
}

// Run the main function
fixDependencies();
</file>

<file path="scripts/notarize.js">
/* eslint-disable @typescript-eslint/no-var-requires */
const { notarize } = require("@electron/notarize");
const fs = require("fs");
const path = require("path");

// This script is called by electron-builder after signing the app
// It's used for notarizing macOS applications

module.exports = async function (params) {
  // Only notarize the app on macOS and when publishing (not during development)
  if (process.platform !== "darwin" || !process.env.NOTARIZE) {
    console.log(
      "Skipping notarization: Not on macOS or NOTARIZE env var not set",
    );
    return;
  }

  console.log("Notarizing macOS application...");

  // Get necessary app information from package.json
  const pkg = JSON.parse(
    fs.readFileSync(path.join(__dirname, "..", "package.json"), "utf8"),
  );
  const appId = pkg.build.appId;

  // Path to the packaged app
  const appPath = path.join(
    params.appOutDir,
    `${params.packager.appInfo.productFilename}.app`,
  );

  if (!fs.existsSync(appPath)) {
    console.error(`Cannot find application at: ${appPath}`);
    return;
  }

  try {
    // Check for required environment variables
    if (!process.env.APPLE_ID || !process.env.APPLE_APP_SPECIFIC_PASSWORD) {
      console.error("Missing required environment variables for notarization:");
      console.error("- APPLE_ID: Your Apple ID");
      console.error("- APPLE_APP_SPECIFIC_PASSWORD: An app-specific password");
      console.error("- TEAM_ID: Your Apple Developer Team ID");
      console.error("Please set these environment variables and try again.");
      return;
    }

    // Notarize the app
    await notarize({
      appBundleId: appId,
      appPath: appPath,
      appleId: process.env.APPLE_ID,
      appleIdPassword: process.env.APPLE_APP_SPECIFIC_PASSWORD,
      teamId: process.env.TEAM_ID,
    });

    console.log(`Successfully notarized ${appPath}`);
  } catch (error) {
    console.error(`Notarization failed: ${error.message}`);
    throw error;
  }
};
</file>

<file path="scripts/test-local-build.js">
/**
 * Script to test local Electron builds
 * This helps verify that electron-builder is working correctly on your machine
 */

const { execSync } = require("child_process");
const fs = require("fs");
const path = require("path");
const os = require("os");

const platform = process.platform;
const buildType = process.argv[2] || platform;

console.log("üß™ Testing local Electron build");
console.log("System:", os.platform(), os.release(), os.arch());
console.log("Build type:", buildType);

// Clean previous builds
try {
  console.log("üßπ Cleaning previous builds...");
  if (fs.existsSync(path.join(__dirname, "../release-builds"))) {
    if (platform === "win32") {
      execSync("rmdir /s /q release-builds", { stdio: "inherit" });
    } else {
      execSync("rm -rf release-builds", { stdio: "inherit" });
    }
  }
  console.log("‚úÖ Clean complete");
} catch (err) {
  console.log("‚ö†Ô∏è Clean failed, but continuing...");
}

// Run build
try {
  console.log("üî® Building Vite app...");
  execSync("npm run build", { stdio: "inherit" });
  console.log("‚úÖ Build complete");
} catch (err) {
  console.error("‚ùå Build failed:");
  console.error(err.message);
  process.exit(1);
}

// Run packaging
console.log("üì¶ Packaging Electron app...");
try {
  let command;

  switch (buildType) {
    case "darwin":
    case "mac":
      command = "npm run package:mac";
      break;
    case "win32":
    case "windows":
    case "win":
      command = "npm run package:win";
      break;
    case "linux":
      command = "npm run package:linux";
      break;
    case "all":
      command = "npm run package:all";
      break;
    default:
      console.log(`Unknown build type: ${buildType}, using current platform`);
      command = `npm run package:${
        platform === "win32" ? "win" : platform === "darwin" ? "mac" : "linux"
      }`;
  }

  console.log(`Running command: ${command}`);
  execSync(command, { stdio: "inherit" });
  console.log("‚úÖ Packaging complete");
} catch (err) {
  console.error("‚ùå Packaging failed:");
  console.error(err.message);
  process.exit(1);
}

// Check for output files
console.log("üîç Checking for output files...");
if (!fs.existsSync(path.join(__dirname, "../release-builds"))) {
  console.error("‚ùå No release-builds directory found");
  process.exit(1);
}

let files;
try {
  files = fs.readdirSync(path.join(__dirname, "../release-builds"));
} catch (err) {
  console.error("‚ùå Failed to read release-builds directory:");
  console.error(err.message);
  process.exit(1);
}

if (files.length === 0) {
  console.error("‚ùå No files found in release-builds directory");
  process.exit(1);
}

console.log("üìÉ Files in release-builds directory:");
files.forEach((file) => {
  const stats = fs.statSync(path.join(__dirname, "../release-builds", file));
  const size = stats.size / (1024 * 1024); // Convert to MB
  console.log(`- ${file} (${size.toFixed(2)} MB)`);
});

console.log(
  "\n‚úÖ Build test complete! Your electron-builder setup appears to be working correctly.",
);
console.log("You can find your build files in the release-builds directory.");

// Print helpful instructions
console.log("\nüìù Next steps:");
if (platform === "darwin") {
  console.log("- To test the macOS app: open release-builds/PasteMax.app");
  console.log("- To create a GitHub release, tag your commit and push:");
  console.log("  git tag v1.0.0");
  console.log("  git push origin v1.0.0");
} else if (platform === "win32") {
  console.log("- To test the Windows app: run release-builds\\PasteMax.exe");
  console.log("- To create a GitHub release, tag your commit and push:");
  console.log("  git tag v1.0.0");
  console.log("  git push origin v1.0.0");
} else {
  console.log("- To test the Linux app: run the AppImage in release-builds/");
  console.log("- To create a GitHub release, tag your commit and push:");
  console.log("  git tag v1.0.0");
  console.log("  git push origin v1.0.0");
}
</file>

<file path="scripts/verify-build.js">
/**
 * Script to verify electron-builder configuration and ensure it can create proper builds
 */

const fs = require("fs");
const path = require("path");
const { execSync } = require("child_process");

console.log("üîç Verifying build configuration...");

// Check that package.json exists and has the correct build configuration
try {
  const packageJson = JSON.parse(
    fs.readFileSync(path.join(__dirname, "../package.json"), "utf8"),
  );

  console.log("üì¶ Package name:", packageJson.name);
  console.log("üî¢ Version:", packageJson.version);

  if (!packageJson.build) {
    console.error('‚ùå No "build" configuration found in package.json');
    process.exit(1);
  }

  console.log('‚úÖ "build" configuration exists');

  // Check output directory
  const outputDir = packageJson.build.directories?.output || "dist";
  console.log("üìÇ Output directory:", outputDir);

  // Check files configuration
  if (!packageJson.build.files || packageJson.build.files.length === 0) {
    console.warn('‚ö†Ô∏è No "files" configuration found in build config');
  } else {
    console.log(
      '‚úÖ "files" configuration exists with',
      packageJson.build.files.length,
      "entries",
    );
  }

  // Check main file
  if (!packageJson.main) {
    console.error('‚ùå No "main" field found in package.json');
    process.exit(1);
  }

  console.log("‚úÖ Main file:", packageJson.main);
  if (!fs.existsSync(path.join(__dirname, "..", packageJson.main))) {
    console.error(`‚ùå Main file "${packageJson.main}" does not exist`);
    process.exit(1);
  }

  console.log("‚úÖ Main file exists");

  // Check if Vite dist directory exists
  if (!fs.existsSync(path.join(__dirname, "../dist"))) {
    console.log('‚ö†Ô∏è "dist" directory does not exist. Running build...');
    execSync("npm run build", { stdio: "inherit" });

    if (!fs.existsSync(path.join(__dirname, "../dist"))) {
      console.error("‚ùå Failed to build the Vite app");
      process.exit(1);
    }

    console.log("‚úÖ Vite build completed successfully");
  } else {
    console.log('‚úÖ "dist" directory exists');
  }

  // Print electron-builder version
  try {
    const version = execSync("npx electron-builder --version", {
      encoding: "utf8",
    }).trim();
    console.log("üèóÔ∏è electron-builder version:", version);
  } catch (err) {
    console.error("‚ùå Failed to get electron-builder version");
    console.error(err);
  }

  console.log("\nüöÄ Ready to build! Try running one of these commands:");
  console.log("  npm run package:mac    # Build for macOS");
  console.log("  npm run package:win    # Build for Windows");
  console.log("  npm run package:linux  # Build for Linux");
  console.log(
    "  npm run package:all    # Build for all platforms (requires proper setup)",
  );
} catch (err) {
  console.error("‚ùå Error while verifying build configuration:");
  console.error(err);
  process.exit(1);
}
</file>

<file path="src/assets/favicon.svg">
<svg xmlns="http://www.w3.org/2000/svg" width="512" height="512" viewBox="0 0 512 512">
  <rect width="512" height="512" rx="50" fill="#4a86e8" />
  <rect x="100" y="150" width="312" height="50" rx="10" fill="white" />
  <rect x="100" y="230" width="312" height="50" rx="10" fill="white" />
  <rect x="100" y="310" width="312" height="50" rx="10" fill="white" />
  <circle cx="140" cy="175" r="15" fill="#ff9900" />
  <circle cx="140" cy="255" r="15" fill="#ff9900" />
  <circle cx="140" cy="335" r="15" fill="#ff9900" />
</svg>
</file>

<file path="src/components/CopyButton.tsx">
import React, { useState } from "react";
import { Copy, Check } from "lucide-react";

interface CopyButtonProps {
  text: string;
  className?: string;
  children?: JSX.Element | string;
}

const CopyButton = ({ text, className = "", children }: CopyButtonProps) => {
  const [copied, setCopied] = useState(false);

  const handleCopy = async () => {
    try {
      await navigator.clipboard.writeText(text);
      setCopied(true);

      // Reset the copied state after 2 seconds
      setTimeout(() => {
        setCopied(false);
      }, 2000);
    } catch (err) {
      console.error("Failed to copy:", err);
    }
  };

  // Add inline styles to ensure no focus outline appears
  const buttonStyle = {
    outline: "none",
  };

  return (
    <button
      type="button"
      className={`${className}`}
      onClick={handleCopy}
      title={copied ? "Copied!" : "Copy to clipboard"}
      style={buttonStyle}
    >
      {copied ? <Check size={16} /> : <Copy size={16} />}
      {children}
    </button>
  );
};

export default CopyButton;
</file>

<file path="src/components/FileCard.tsx">
import React from "react";
import { FileCardProps } from "../types/FileTypes";
import { Plus, X, FileText } from "lucide-react";
import CopyButton from "./CopyButton";

interface FileCardComponentProps {
  file: {
    name: string;
    path: string;
    tokenCount: number;
    content: string;
  };
  isSelected: boolean;
  toggleSelection: (path: string) => void;
}

const FileCard = ({
  file,
  isSelected,
  toggleSelection,
}: FileCardComponentProps) => {
  const { name, path: filePath, tokenCount } = file;

  // Format token count for display
  const formattedTokens = tokenCount.toLocaleString();

  return (
    <div className={`file-card ${isSelected ? "selected" : ""}`}>
      <div className="file-card-header">
        <div className="file-card-icon">
          <FileText size={16} />
        </div>
        <div className="file-card-name monospace">{name}</div>
      </div>
      <div className="file-card-info">
        <div className="file-card-tokens">~{formattedTokens} tokens</div>
      </div>

      <div className="file-card-actions">
        <button
          className="file-card-action"
          onClick={() => toggleSelection(filePath)}
          title={isSelected ? "Remove from selection" : "Add to selection"}
        >
          {isSelected ? <X size={16} /> : <Plus size={16} />}
        </button>
        <CopyButton text={file.content} className="file-card-action">
          {""}
        </CopyButton>
      </div>
    </div>
  );
};

export default FileCard;
</file>

<file path="src/components/SearchBar.tsx">
import React, { useState } from "react";
import { Search, X } from "lucide-react";

interface SearchBarProps {
  searchTerm: string;
  onSearchChange: (term: string) => void;
  placeholder?: string;
}

const SearchBar = ({
  searchTerm,
  onSearchChange,
  placeholder = "Search...",
}: SearchBarProps) => {
  const [isFocused, setIsFocused] = useState(false);

  return (
    <div className={`search-bar ${isFocused ? "focused" : ""}`}>
      <div className="search-icon">
        <Search size={16} />
      </div>
      <input
        type="text"
        className="search-input"
        placeholder={placeholder}
        value={searchTerm}
        onChange={(e) => onSearchChange(e.target.value)}
        onFocus={() => setIsFocused(true)}
        onBlur={() => setIsFocused(false)}
      />
      {searchTerm && (
        <button
          className="search-clear-btn"
          onClick={() => onSearchChange("")}
          aria-label="Clear search"
        >
          <X size={14} />
        </button>
      )}
    </div>
  );
};

export default SearchBar;
</file>

<file path="src/components/ThemeToggle.tsx">
import React from "react";
import { useTheme } from "../context/ThemeContext";
import { Sun, Moon, Monitor } from "lucide-react";

const ThemeToggle = (): JSX.Element => {
  const { theme, setTheme } = useTheme();
  
  return (
    <div className="theme-segmented-control">
      <button
        className={`theme-segment ${theme === "light" ? "active" : ""}`}
        onClick={() => setTheme("light")}
        title="Light Mode"
      >
        <Sun size={16} />
        <span>Light</span>
      </button>
      <button
        className={`theme-segment ${theme === "dark" ? "active" : ""}`}
        onClick={() => setTheme("dark")}
        title="Dark Mode"
      >
        <Moon size={16} />
        <span>Dark</span>
      </button>
      <button
        className={`theme-segment ${theme === "system" ? "active" : ""}`}
        onClick={() => setTheme("system")}
        title="Use System Settings"
      >
        <Monitor size={16} />
        <span>Auto</span>
      </button>
    </div>
  );
};

export default ThemeToggle;
</file>

<file path="src/context/ThemeContext.tsx">
import React, { createContext, useState, useEffect, useContext } from "react";

type ThemeType = "light" | "dark" | "system";

interface ThemeContextType {
  theme: ThemeType;
  currentTheme: "light" | "dark"; // The actual applied theme
  setTheme: (theme: ThemeType) => void;
}

// Create context with proper typing
const defaultThemeContext: ThemeContextType = {
  theme: "system",
  currentTheme: "light",
  setTheme: () => {},
};

const ThemeContext = createContext(defaultThemeContext);

type ThemeProviderProps = { children: JSX.Element | JSX.Element[] };

export const ThemeProvider = ({ children }: ThemeProviderProps): JSX.Element => {
  // Initialize theme from localStorage or default to "system"
  const [theme, setThemeState] = useState(() => {
    const savedTheme = localStorage.getItem("theme") as ThemeType;
    return savedTheme && ["light", "dark", "system"].includes(savedTheme) ? savedTheme : "system";
  });
  
  const [currentTheme, setCurrentTheme] = useState("light");

  // Function to set theme and save to localStorage
  const setTheme = (newTheme: ThemeType) => {
    setThemeState(newTheme);
    localStorage.setItem("theme", newTheme);
  };

  // Effect to apply the correct theme based on selection or system preference
  useEffect(() => {
    const applyTheme = (themeName: "light" | "dark") => {
      setCurrentTheme(themeName);
      
      if (themeName === "dark") {
        document.body.classList.add("dark-mode");
      } else {
        document.body.classList.remove("dark-mode");
      }
    };
    
    // Check for system preference
    const prefersDark = window.matchMedia("(prefers-color-scheme: dark)").matches;
    
    // Apply theme based on selection or system preference
    if (theme === "system") {
      applyTheme(prefersDark ? "dark" : "light");
    } else {
      applyTheme(theme as "light" | "dark");
    }
    
    // Listen for system preference changes if in auto mode
    const mediaQuery = window.matchMedia("(prefers-color-scheme: dark)");
    
    const handleSystemThemeChange = (e: MediaQueryListEvent) => {
      if (theme === "system") {
        applyTheme(e.matches ? "dark" : "light");
      }
    };
    
    mediaQuery.addEventListener("change", handleSystemThemeChange);
    
    return () => mediaQuery.removeEventListener("change", handleSystemThemeChange);
  }, [theme]);

  return (
    <ThemeContext.Provider value={{ theme, currentTheme, setTheme }}>
      {children}
    </ThemeContext.Provider>
  );
};

// Custom hook to use the theme context
export const useTheme = () => {
  const context = useContext(ThemeContext);
  if (context === undefined) {
    throw new Error("useTheme must be used within a ThemeProvider");
  }
  return context;
};
</file>

<file path="src/declarations.d.ts">
// Type declarations for external modules
declare module "react";
declare module "react-dom/client";
declare module "react/jsx-runtime";
declare module "electron";
declare module "tiktoken";
declare module "ignore";
declare module "gpt-3-encoder";

// Allow importing CSS files
declare module "*.css" {
  const content: { [className: string]: string };
  export default content;
}

// Allow importing various file types
declare module "*.svg" {
  const content: string;
  export default content;
}

declare module "*.png" {
  const content: string;
  export default content;
}

declare module "*.jpg" {
  const content: string;
  export default content;
}
</file>

<file path="src/index.html">
<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <link rel="icon" type="image/svg+xml" href="/favicon.svg" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Repo String</title>
    <link
      href="https://fonts.googleapis.com/css2?family=Roboto:wght@300;400;500;700&display=swap"
      rel="stylesheet"
    />
  </head>
  <body>
    <div id="root"></div>
    <script type="module" src="/src/main.tsx"></script>
  </body>
</html>
</file>

<file path="src/react-app-env.d.ts">
/// <reference types="react" />
/// <reference types="react-dom" />

// Add missing TypeScript definitions
declare namespace React {
  interface MouseEvent<T = Element> extends globalThis.MouseEvent {}
  interface ChangeEvent<T = Element> extends Event {}
}
</file>

<file path="tsconfig.json">
{
  "compilerOptions": {
    "target": "ES2020",
    "useDefineForClassFields": true,
    "lib": ["ES2020", "DOM", "DOM.Iterable"],
    "module": "ESNext",
    "skipLibCheck": true,

    /* Bundler mode */
    "moduleResolution": "bundler",
    "allowImportingTsExtensions": true,
    "resolveJsonModule": true,
    "isolatedModules": true,
    "noEmit": true,
    "jsx": "react-jsx",

    /* Linting */
    "strict": true,
    "noUnusedLocals": false,
    "noUnusedParameters": false,
    "noFallthroughCasesInSwitch": true,

    /* Additional Options */
    "esModuleInterop": true,
    "allowSyntheticDefaultImports": true,
    "forceConsistentCasingInFileNames": true
  },
  "include": ["src", "src/declarations.d.ts"],
  "references": [{ "path": "./tsconfig.node.json" }]
}
</file>

<file path="tsconfig.node.json">
{
  "compilerOptions": {
    "composite": true,
    "skipLibCheck": true,
    "module": "ESNext",
    "moduleResolution": "bundler",
    "allowSyntheticDefaultImports": true
  },
  "include": ["vite.config.ts"]
}
</file>

<file path=".eslintrc.cjs">
module.exports = {
  root: true,
  env: { browser: true, es2020: true, node: true },
  extends: [
    "eslint:recommended",
    "plugin:@typescript-eslint/recommended",
    "plugin:react-hooks/recommended",
  ],
  ignorePatterns: ["dist", ".eslintrc.cjs"],
  parser: "@typescript-eslint/parser",
  plugins: ["react-refresh"],
  rules: {
    "react-refresh/only-export-components": [
      "warn",
      { allowConstantExport: true },
    ],
    "@typescript-eslint/no-explicit-any": "off", // During development, allow 'any' type
    "@typescript-eslint/no-var-requires": "off", // Hide error for require()
    "@typescript-eslint/no-unused-vars": "warn",
  },
  settings: {
    react: {
      version: "detect",
    },
  },
};
</file>

<file path="dev.js">
// Check for required dependencies
try {
  // Test loading key dependencies
  require("ignore");
  require("tiktoken");
  require("gpt-3-encoder");
} catch (err) {
  console.error(`\n‚ùå Missing dependency: ${err.message}`);
  console.error("Please run: npm install\n");
  process.exit(1);
}

const { spawn } = require("child_process");
const { platform } = require("os");

console.log("üöÄ Starting development environment...");

// Set environment variable for development mode
process.env.NODE_ENV = "development";

// Default port - updated to match vite.config.ts
let vitePort = 5173;

// Start Vite dev server
console.log("üì¶ Starting Vite dev server...");
const viteProcess = spawn("npm", ["run", "dev"], {
  stdio: ["inherit", "pipe", "inherit"], // Pipe stdout to capture the port
  shell: platform() === "win32", // Use shell on Windows
});

// Flag to track if Vite has started
let viteStarted = false;

// Listen for Vite server ready message
viteProcess.stdout?.on("data", (data) => {
  const output = data.toString();
  console.log(output); // Echo output to console

  // Extract port from the output (e.g., "Local: http://localhost:3001/")
  const portMatch = output.match(/Local:\s+http:\/\/localhost:(\d+)/);
  if (portMatch && portMatch[1]) {
    vitePort = parseInt(portMatch[1], 10);
    console.log(`üîç Detected Vite server running on port ${vitePort}`);
  }

  if (output.includes("Local:") && !viteStarted) {
    viteStarted = true;
    startElectron();
  }
});

// Listen for errors that might indicate port conflicts
viteProcess.stderr?.on("data", (data) => {
  const output = data.toString();
  console.error(output); // Echo error output to console

  if (output.includes("Port 3000 is already in use")) {
    console.error(
      "\n‚ùå Port 3000 is already in use. Try one of the following:",
    );
    console.error(
      "  1. Kill the process using port 3000: 'lsof -i :3000 | grep LISTEN' then 'kill -9 [PID]'",
    );
    console.error("  2. Change the Vite port in vite.config.ts");
    console.error("  3. Restart your computer if the issue persists\n");
  } else if (output.includes("Port 5173 is already in use")) {
    console.error(
      "\n‚ùå Port 5173 is already in use. Try one of the following:",
    );
    console.error(
      "  1. Kill the process using port 5173: 'lsof -i :5173 | grep LISTEN' then 'kill -9 [PID]'",
    );
    console.error("  2. Change the Vite port in vite.config.ts");
    console.error("  3. Restart your computer if the issue persists\n");
  }
});

// Start Electron after a delay if Vite hasn't reported ready
setTimeout(() => {
  if (!viteStarted) {
    console.log(
      "‚ö†Ô∏è Vite server might not be ready yet, but starting Electron anyway...",
    );
    startElectron();
  }
}, 5000); // Wait 5 seconds before attempting to start Electron

function startElectron() {
  console.log(
    `üîå Starting Electron app with Vite server at port ${vitePort}...`,
  );
  const electronProcess = spawn("npm", ["start"], {
    stdio: "inherit",
    shell: platform() === "win32", // Use shell on Windows
    env: {
      ...process.env,
      NODE_ENV: "development",
      ELECTRON_START_URL: `http://localhost:${vitePort}`,
    },
  });

  electronProcess.on("close", (code) => {
    console.log(`Electron process exited with code ${code}`);
    viteProcess.kill();
    process.exit(code);
  });
}

// Handle process termination
process.on("SIGINT", () => {
  viteProcess.kill();
  process.exit(0);
});

viteProcess.on("close", (code) => {
  console.log(`Vite process exited with code ${code}`);
  process.exit(code);
});
</file>

<file path="preload.js">
// Preload script
const { contextBridge, ipcRenderer } = require("electron");

// Helper function to ensure data is serializable
function ensureSerializable(data) {
  if (data === null || data === undefined) {
    return data;
  }

  // Handle primitive types directly
  if (typeof data !== "object") {
    return data;
  }

  // For arrays, map each item
  if (Array.isArray(data)) {
    return data.map(ensureSerializable);
  }

  // For objects, create a new object with serializable properties
  const result = {};
  for (const key in data) {
    if (Object.prototype.hasOwnProperty.call(data, key)) {
      // Skip functions or symbols which are not serializable
      if (typeof data[key] === "function" || typeof data[key] === "symbol") {
        continue;
      }
      // Recursively process nested objects
      result[key] = ensureSerializable(data[key]);
    }
  }
  return result;
}

// Expose protected methods that allow the renderer process to use
// the ipcRenderer without exposing the entire object
contextBridge.exposeInMainWorld("electron", {
  send: (channel, data) => {
    // whitelist channels
    const validChannels = ["open-folder", "request-file-list", "debug-file-selection", "cancel-directory-loading"];
    if (validChannels.includes(channel)) {
      // Ensure data is serializable before sending
      const serializedData = ensureSerializable(data);
      ipcRenderer.send(channel, serializedData);
    }
  },
  receive: (channel, func) => {
    const validChannels = [
      "folder-selected",
      "file-list-data",
      "file-processing-status",
      "startup-mode"
    ];
    if (validChannels.includes(channel)) {
      // Remove any existing listeners to avoid duplicates
      ipcRenderer.removeAllListeners(channel);
      // Add the new listener
      ipcRenderer.on(channel, (event, ...args) => func(...args));
    }
  },
  // For backward compatibility (but still ensure serialization)
  ipcRenderer: {
    send: (channel, data) => {
      const serializedData = ensureSerializable(data);
      ipcRenderer.send(channel, serializedData);
    },
    on: (channel, func) => {
      const wrapper = (event, ...args) => {
        try {
          // Don't pass the event object to the callback, only pass the serialized args
          const serializedArgs = args.map(ensureSerializable);
          func(...serializedArgs); // Only pass the serialized args, not the event
        } catch (err) {
          console.error(`Error in IPC handler for channel ${channel}:`, err);
        }
      };
      ipcRenderer.on(channel, wrapper);
      // Store the wrapper function for removal later
      return wrapper;
    },
    removeListener: (channel, func) => {
      const validChannels = [
        "folder-selected",
        "file-list-data",
        "file-processing-status",
        "startup-mode"
      ];
      if (validChannels.includes(channel)) {
        ipcRenderer.removeListener(channel, (event, ...args) => func(...args));
      }
    },
  },
});
</file>

<file path="src/components/FileList.tsx">
import React from "react";
import { FileListProps, FileData } from "../types/FileTypes";
import FileCard from "./FileCard";
import { arePathsEqual } from "../utils/pathUtils";

const FileList = ({
  files,
  selectedFiles,
  toggleFileSelection,
}: FileListProps) => {
  // Only show files that are in the selectedFiles array and not binary/skipped/excluded/directories
  const displayableFiles = files.filter(
    (file: FileData) =>
      selectedFiles.some(selectedPath => arePathsEqual(selectedPath, file.path)) && 
      !file.isBinary && 
      !file.isSkipped &&
      !file.excludedByDefault &&
      !file.isDirectory
  );

  return (
    <div className="file-list-container">
      {displayableFiles.length > 0 ? (
        <div className="file-list">
          {displayableFiles.map((file: FileData) => (
            <FileCard
              key={file.path}
              file={file}
              isSelected={true} // All displayed files are selected
              toggleSelection={toggleFileSelection}
            />
          ))}
        </div>
      ) : (
        <div className="file-list-empty">
          {files.length > 0
            ? "No files selected. Select files from the sidebar."
            : "Select a folder to view files"}
        </div>
      )}
    </div>
  );
};

export default FileList;
</file>

<file path="src/components/UserInstructions.tsx">
import React from "react";

interface UserInstructionsProps {
  instructions: string;
  setInstructions: (value: string) => void;
}

const UserInstructions = ({
  instructions,
  setInstructions,
}: UserInstructionsProps): JSX.Element => {
  return (
    <>
      <div className="user-instructions-header">
        <label className="content-title" htmlFor="userInstructionsInput">
          User Instructions
        </label>
      </div>
      <div className="user-instructions-container">
        <div className="user-instructions-description">
          Add custom instructions that will be included with your selected files.
        </div>
        <div className="user-instructions">
          <textarea
            id="userInstructionsInput"
            value={instructions}
            onChange={(e) => setInstructions(e.target.value)}
            placeholder="Enter your instructions here..."
            style={{
              width: "100%",
              resize: "none",
            }}
          />
        </div>
      </div>
    </>
  );
};

export default UserInstructions;
</file>

<file path="src/main.tsx">
/**
 * Application entry point that sets up React with strict mode.
 * This ensures better development-time checks and warnings.
 */
import React from "react";
import ReactDOM from "react-dom/client";
import App from "./App";
import "./styles/index.css";

ReactDOM.createRoot(document.getElementById("root")!).render(
  <React.StrictMode>
    <App />
  </React.StrictMode>,
);
</file>

<file path="vite.config.ts">
import { defineConfig } from "vite";
import react from "@vitejs/plugin-react";
import path from "path";

// https://vitejs.dev/config/
export default defineConfig({
  plugins: [react()],
  base: "./", // Relative base path for assets
  build: {
    outDir: "dist",
    emptyOutDir: true,
    sourcemap: true,
  },
  server: {
    port: 5173, // Explicitly set port to match what Electron is looking for
    hmr: {
      overlay: false, // Disable HMR overlay to avoid CSP issues
    },
  },
  optimizeDeps: {
    exclude: ['electron'], // Prevent Vite from trying to bundle Electron
  },
  resolve: {
    alias: {
      "@": path.resolve(__dirname, "./src"),
    },
  },
});
</file>

<file path=".gitignore">
# Logs
logs
*.log
npm-debug.log*
yarn-debug.log*
yarn-error.log*
pnpm-debug.log*
lerna-debug.log*
electron-debug.log*

# Dependencies
node_modules
.pnp
.pnp.js

# Build outputs
dist
dist-ssr
*.local
build/*

# Electron-builder output
out/
release/

# Editor directories and files
.vscode/*
!.vscode/extensions.json
.idea
.DS_Store
*.suo
*.ntvs*
*.njsproj
*.sln
*.sw?

# Environment variables
.env
.env.local
.env.development.local
.env.test.local
.env.production.local

# OS specific files
.DS_Store
.DS_Store?
._*
.Spotlight-V100
.Trashes
ehthumbs.db
Thumbs.db

# IDE specific files
.idea/
.vscode/
*.swp
*.swo

# Release builds
release-builds/
dist/

# Repomix
repomix-output.xml
repomix.config.json
.repomixignore
</file>

<file path="CHANGELOG.md">
# Changelog

All notable changes to this project will be documented in this file.

# PasteMax Updates

## v1.2.0 | 2024-03-21

### Added
- Added enhanced logging for file selection and deselection actions.
- Expanded the ignore list to include additional binary file types.

### Fixed
- Fixed app reloading issue caused by testing configuration being merged into main.
- Fixed issue where Windows paths were duplicated, making folders unrecognizable.

### Improved
- Improved folder selection to automatically select/deselect all files within the folder.
- Optimized repository and project loading for better performance.
- Improved path normalization for better cross-platform compatibility.

### Added
- Enhanced cross-platform path handling system
  - New utility functions for consistent path operations:
    - `normalizePath()`: Ensures consistent path separators across platforms
    - `ensureAbsolutePath()`: Guarantees absolute path resolution
    - `safePathJoin()`: Platform-safe path joining
    - `safeRelativePath()`: Safe relative path calculation
    - `isValidPath()`: Path string validation
  - Special handling for Windows UNC paths and network shares
  - Case-insensitive path handling for Windows systems
  - Improved .gitignore pattern normalization
  - Platform-specific file system restrictions handling

### Fixed
- "Path Should Be a Relative String" error in file processing
  - Now properly handles path conversions between absolute and relative formats
  - Maintains both full path and relative path properties for each file
  - Correctly processes ignore patterns across different platforms
- Directory containment checks in folder selection
  - Improved path comparison logic for nested directories
  - Fixed issues with path separators in directory tree traversal
- File selection state preservation across platform differences
  - Consistent path normalization in selection tracking
  - Fixed path comparison issues in tree view

### Improved
- Cross-platform compatibility
  - Added support for Windows network paths (UNC)
  - Better handling of Windows drive letter case-sensitivity
  - Improved symlink and file permission handling for Unix/Mac
  - Enhanced path separator normalization
  - Added platform-specific file ignores:
    - Windows: Thumbs.db, desktop.ini, system files (CON, PRN, etc.)
    - macOS: .DS_Store, .Spotlight, .Trashes, .fseventsd
    - Linux: /proc, /sys, /dev directories
    - Common: .git, node_modules, IDE folders
- File system access
  - Better error handling for inaccessible files and directories
  - Improved permission handling across different OS security models
  - More informative error messages for file system issues

### Security
- Added validation for file paths to prevent directory traversal
- Improved handling of inaccessible directories and files
- Better error handling for file system operations
- Platform-specific security checks:
  - Windows: System file and directory restrictions
  - Unix/Linux: Permission and ownership validation
  - macOS: System integrity protection awareness

### Performance
- Optimized path normalization operations
  - Reduced redundant path conversions
  - Improved caching of normalized paths
- Improved memory usage in path handling
  - Better string manipulation for path operations
  - Reduced duplicate path storage
- Better handling of large directory structures
  - Optimized directory traversal
  - Improved file filtering performance
- Enhanced error recovery and graceful degradation

### Added
- Initial release
- Basic file system operations
- File selection and copying
- Directory tree view
- Search and sort functionality


# PasteMax Updates

## v1.3.0 | 2024-03-21

## Overview
This document outlines the application hardening and security improvements made to the PasteMax application, with a focus on production-ready builds and cross-platform security.

## 1. Application Security Hardening

### Production-Specific Content Security Policy (CSP)
- Implemented a comprehensive Content Security Policy with different configurations for development and production
- Added dynamic nonce generation using the crypto module for script-src directives in production
- Production CSP now features:
  - Strict default-src policy limiting resources to same origin ('self')
  - Nonce-based script-src validation to prevent XSS attacks
  - Restricted connect-src to prevent data exfiltration
  - object-src 'none' to prevent plugin-based attacks
  - base-uri and form-action restrictions to prevent redirects
  - frame-ancestors 'self' to prevent clickjacking
  - Automatic HTTP to HTTPS upgrades with upgrade-insecure-requests
- Added enhanced security headers:
  - X-Content-Type-Options: nosniff
  - X-XSS-Protection: 1; mode=block
  - X-Frame-Options: SAMEORIGIN

### Browser Window Security Enhancements
- Implemented environment-specific security settings:
  - Disabled DevTools in production builds
  - Enabled sandbox mode in production for renderer process isolation
  - Enforced same-origin policy with webSecurity: true
- Added proper window navigation protection:
  - Blocked navigation to non-local content
  - Implemented window open handler to control external links
  - Forced external URLs to open in the default browser

### Runtime Security Controls
- Added protection against malicious navigation:
  - Monitoring and blocking of will-navigate events to external sites
  - Strict protocol checking for allowed destinations
  - Proper external URL handling through electron.shell.openExternal
- Implemented proper event unregistration to prevent memory leaks
- Added comprehensive error logging for security-relevant events

## 2. macOS Build Hardening

### Build Directory Structure and Purpose
- Created dedicated `build` directory to house platform-specific build configuration files
- Purpose of the directory:
  - Centralized location for build-time configuration files
  - Separation of build concerns from application code
  - Storage for platform-specific security requirements
  - Integration point with electron-builder packaging system
- Configuration is automatically detected and used by electron-builder during packaging
- Directory is excluded from tokenization and file processing through ignoreFilter

### Entitlements for macOS Security
- Created build/entitlements.mac.plist for proper App Store compliance and security
- Implemented sandboxing with com.apple.security.app-sandbox
- Configured file access permissions:
  - Limited read-only access to user-selected files
  - Controlled read-write access to specific user-selected files
- Added hardened runtime entitlements:
  - JIT compilation support with appropriate restrictions
  - Controlled executable memory permissions
  - Inheritance of security settings from parent process

### Configuration for Production Builds
- Set up production environment flags to enable security features automatically
- Added conditional security settings based on NODE_ENV=production
- Enhanced error handling and reporting for production environments
- Implemented graceful degradation for improved reliability

## 3. Development Environment Improvements

### Development Mode Configurations
- Created specific development CSP that allows:
  - HMR (Hot Module Replacement) functionality with websocket connections
  - Vite development server connections
  - Appropriate 'unsafe-eval' permissions only in development
- Added clear console logging to distinguish between development and production mode
- Implemented automatic suppression of development-specific warnings

### Cross-Platform Path Handling
- Enhanced path normalization for consistent behavior across platforms
- Improved handling of Windows UNC paths and drive letters
- Added safe path joining functions to prevent path traversal issues
- Implemented better relative path calculation for cross-platform compatibility

## 4. Build Process Security

### Safe Module Loading
- Added robust error handling for module loading failures
- Implemented fallbacks for critical dependencies
- Added comprehensive logging of module loading status
- Created defensive coding patterns to handle missing or incompatible modules

### File Handling Security
- Added validation of file paths before processing
- Implemented size limits for file reading to prevent DoS attacks
- Added proper binary file detection and handling
- Enhanced directory traversal protection with path validation

## 5. CSS and Styling Improvements

### Enhanced CSS Documentation
- Completely restructured CSS documentation with standardized section headers
- Added a detailed table of contents with hierarchical organization:
  - 10 main sections with clear subsection breakdowns
  - Each component type grouped under appropriate categories
- Added extensive inline documentation:
  - Purpose description for every component
  - Explanation of property choices and behavior
  - Cross-browser compatibility notes
  - Theme-specific variations
- Enhanced code organization:
  - Logically grouped related styles together
  - Standardized comment format for better navigation
  - Added visual separator blocks for major sections
  - Documented relationships between interacting components

### Theme System Improvements
- Added detailed documentation for theme variables:
  - Organized variables into logical categories (backgrounds, typography, feedback colors)
  - Added descriptive comments for each color variable explaining its purpose
  - Documented specific color choices for design consistency
- Enhanced dark mode implementation:
  - Added explicit dark mode documentation
  - Improved contrast ratios for better accessibility
  - Documented component-specific dark mode adjustments

### Component Styling Consistency
- Standardized styling patterns across similar components:
  - Consistent spacing and sizing
  - Uniform hover and focus states
  - Standardized animation timings
- Documented reusable utility classes and patterns
- Added explicit browser support notes for cross-platform features

## Next Steps
- Consider implementing ASAR archive encryption for additional protection
- Investigate Electron's contextBridge for more secure IPC
- Review and enhance application auto-update security
- Conduct a comprehensive security audit of all application components
</file>

<file path="src/styles/index.css">
/**
 * PasteMax Application Styles
 * A comprehensive stylesheet for the PasteMax application, organized by logical sections
 * with enhanced documentation for better maintainability and easier navigation.
 * 
 * TABLE OF CONTENTS:
 * =================
 * 1. Theme Variables & Color Schemes
 *    - Light Theme Variables
 *    - Dark Theme Variables
 * 
 * 2. Global Styles & Resets
 *    - Box Model Reset
 *    - Scrollbar Customization
 *    - Typography Base
 * 
 * 3. Layout Framework
 *    - App Container
 *    - Main Content Areas
 *    - Header Structure
 *    - Sidebar Layout
 * 
 * 4. Form Controls & Interactive Elements
 *    - Buttons & Button Variants
 *    - Input Fields
 *    - Checkboxes & Toggle Controls
 * 
 * 5. Sidebar Components
 *    - Sidebar Header
 *    - Search Functionality
 *    - Resize Handle
 * 
 * 6. File Tree & Navigation
 *    - Tree Structure
 *    - Tree Items
 *    - Nested & Indentation Logic
 *    - Selection States
 * 
 * 7. Content Display Area
 *    - Content Header
 *    - File Cards
 *    - Sorting Controls
 *    - Empty States
 * 
 * 8. User Interface Controls
 *    - Copy Button
 *    - Theme Switcher
 *    - Action Buttons
 * 
 * 9. User Instructions Area
 *    - Container
 *    - Textarea
 *    - Header & Description
 * 
 * 10. Utilities & Animations
 *     - Loading Indicators
 *     - Status Messages
 *     - Keyframe Animations
 *     - Helper Classes
 */

/*==============================================================================
 1. THEME VARIABLES & COLOR SCHEMES
==============================================================================*/

/* Light Theme Variables
 * Default color scheme with neutral light backgrounds and dark text
 * Used when .dark-mode class is NOT applied to the document
 */
:root {
  /* Background & Surface Colors */
  --background-primary: #ffffff;    /* Main app background */
  --background-secondary: #f8f8f8;  /* Secondary surfaces like sidebar */
  --background-selected: rgba(0, 0, 0, 0.06);  /* Selected item highlight */
  --hover-color: #f5f5f5;           /* Hover state background */
  
  /* Accent & UI Colors */
  --accent-blue: #0e639c;           /* Primary accent for focus/active states */
  --border-color: #e0e0e0;          /* Borders, dividers, and separators */
  
  /* Typography Colors */
  --text-primary: #000000;          /* Main text color */
  --text-secondary: #666666;        /* Secondary text for labels, captions */
  --text-disabled: #cccccc;         /* Disabled text elements */
  --icon-color: #555555;            /* Icon fill color */
  
  /* Feedback Colors */
  --success-color: #2ecc71;         /* Success states and confirmations */
  --warning-color: #f39c12;         /* Warning states and alerts */
  --error-color: #e74c3c;           /* Error states and critical alerts */
  
  /* Button Colors */
  --primary-button-background: #000000;  /* Primary action button background */
  --primary-button-text: #ffffff;        /* Primary action button text */
}

/* Dark Theme Variables
 * Applies when .dark-mode class is added to a parent element
 * Optimized for reduced eye strain in low-light environments
 */
.dark-mode {
  /* Background & Surface Colors - Dark variants */
  --background-primary: #1e1e1e;    /* Main dark background (VS Code inspired) */
  --background-secondary: #252526;  /* Secondary dark surfaces */
  --background-selected: #2a2d2e;   /* Selected item highlight in dark mode */
  --hover-color: #333333;           /* Hover state in dark mode */
  
  /* Accent & UI Colors - Adjusted for dark mode */
  --accent-blue: #0e639c;           /* Same accent color for consistency */
  --border-color: #3e3e42;          /* Darker borders for separation */
  
  /* Typography Colors - Higher contrast for readability */
  --text-primary: #e8e8e8;          /* Main text - light gray for contrast */
  --text-secondary: #bbbbbb;        /* Secondary text - softer gray */
  --text-disabled: #808080;         /* Disabled text - mid gray */
  --icon-color: #cccccc;            /* Icon color - light gray */
  
  /* Feedback Colors - Same as light for clear signaling */
  --success-color: #2ecc71;
  --warning-color: #f39c12;
  --error-color: #e74c3c;
  
  /* Button Colors - Adjusted for dark mode */
  --primary-button-background: #0e639c;  /* Blue buttons in dark mode */
  --primary-button-text: #ffffff;
}

/*==============================================================================
 2. GLOBAL STYLES & RESETS
==============================================================================*/

/* Base Element Reset
 * Applies consistent box-sizing and removes default margins
 * Also sets up consistent scrollbar styling across elements
 */
* {
  box-sizing: border-box;
  margin: 0;
  padding: 0;
  scrollbar-width: thin;  /* Firefox scrollbar styling */
  scrollbar-color: var(--border-color) transparent;
}

/* Scrollbars - WebKit Browsers (Chrome, Safari, Edge)
 * Creates thin, subtle scrollbars that match the application theme
 */
*::-webkit-scrollbar {
  width: 8px;    /* Vertical scrollbar width */
  height: 8px;   /* Horizontal scrollbar height */
}

*::-webkit-scrollbar-track {
  background: transparent;  /* Transparent track for cleaner look */
}

*::-webkit-scrollbar-thumb {
  background-color: var(--border-color);
  border-radius: 4px;  /* Rounded corners */
}

*::-webkit-scrollbar-thumb:hover {
  background-color: var(--text-secondary);  /* Darker on hover */
}

/* Dark Mode Scrollbar Adjustments
 * Makes scrollbars more visible against dark backgrounds
 */
.dark-mode *::-webkit-scrollbar-thumb {
  background-color: #555;  /* Slightly lighter for contrast */
}

.dark-mode *::-webkit-scrollbar-thumb:hover {
  background-color: #777;  /* Even lighter on hover for visibility */
}

/* Body & Document Root
 * Sets up the base typography and ensures full viewport usage
 */
body {
  font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica,
    Arial, sans-serif;  /* System font stack for native look */
  margin: 0;
  padding: 0;
  background-color: var(--background-primary);
  color: var(--text-primary);
  line-height: 1.5;
  height: 100vh;
  overflow: hidden;  /* Prevents document-level scrolling */
}

/* React Root Element
 * Ensures React takes up full viewport height and preserves flexbox layout
 */
#root {
  height: 100vh;
  display: flex;
  flex-direction: column;
}

.app-container {
  display: flex;
  flex-direction: column;
  height: 100%;
  overflow: hidden;
}

button {
  cursor: pointer;
  font-family: inherit;
  border: 1px solid var(--border-color);
  background-color: var(--background-primary);
  font-size: 14px;
  display: inline-flex;
  align-items: center;
  justify-content: center;
  gap: 8px;
  padding: 8px 16px;
  border-radius: 4px;
  transition: all 0.2s ease;
  white-space: nowrap;
  font-weight: 500;
  color: var(--text-primary);
}

button:hover {
  background-color: var(--hover-color);
}

button:focus {
  outline: 2px solid var(--accent-blue);
  outline-offset: 1px;
}

button.primary {
  background-color: var(--primary-button-background);
  color: var(--primary-button-text);
  border-color: var(--primary-button-background);
}

button.primary:hover {
  background-color: var(--primary-button-background);
}

button:disabled {
  opacity: 0.5;
  cursor: not-allowed;
}

input[type="text"],
input[type="search"] {
  padding: 8px 12px;
  border: 1px solid var(--border-color);
  border-radius: 4px;
  font-family: inherit;
  font-size: 14px;
  outline: none;
  width: 100%;
  background-color: var(--background-primary);
  color: var(--text-primary);
}

input[type="text"]:focus,
input[type="search"]:focus {
  border-color: var(--accent-blue);
  box-shadow: 0 0 0 1px var(--accent-blue);
}

.monospace {
  font-family: Consolas, Menlo, Monaco, "Courier New", monospace;
  font-size: 13px;
  line-height: 1.5;
}

/* Main layout structure */
.app-container {
  display: flex;
  flex-direction: column;
  height: 100vh;
}

.header {
  padding: 16px 24px;
  border-bottom: 1px solid var(--border-color);
  display: flex;
  align-items: center;
  justify-content: space-between;
  background-color: var(--background-primary);
}

.header h1 {
  font-size: 20px;
  font-weight: 600;
  margin: 0;
  color: var(--text-primary);
}

.folder-info {
  display: flex;
  align-items: center;
  gap: 16px;
}

.selected-folder {
  padding: 6px 12px;
  border-radius: 4px;
  background-color: var(--hover-color);
  max-width: 300px;
  overflow: hidden;
  text-overflow: ellipsis;
  white-space: nowrap;
  color: var(--text-secondary);
}

.select-folder-btn {
  background-color: var(--background-primary);
  border: 1px solid var(--border-color);
  color: var(--text-primary);
  padding: 8px 16px;
  font-weight: 500;
}

.select-folder-btn:hover {
  background-color: var(--hover-color);
}

.main-content {
  display: flex;
  flex: 1;
  overflow: hidden;
  height: 100%;
}

.sidebar {
  width: 300px;
  min-width: 200px;
  max-width: 500px;
  height: 100%;
  display: flex;
  flex-direction: column;
  border-right: 1px solid var(--border-color);
  overflow: hidden;
  background-color: var(--background-secondary);
  position: relative;
  transition: width 0.1s ease;
}

.sidebar-header {
  padding: 16px;
  border-bottom: 1px solid var(--border-color);
  background-color: var(--background-secondary);
}

.sidebar-title {
  font-size: 18px;
  font-weight: 600;
  margin-bottom: 8px;
  color: var(--text-primary);
}

.sidebar-folder-path {
  font-size: 12px;
  color: var(--text-secondary);
  overflow: hidden;
  text-overflow: ellipsis;
  white-space: nowrap;
}

.sidebar-search {
  padding: 12px 16px;
  border-bottom: 1px solid var(--border-color);
  background-color: var(--background-secondary);
}

.sidebar-actions {
  display: flex;
  padding: 12px 16px;
  gap: 8px;
  border-bottom: 1px solid var(--border-color);
  background-color: var(--background-secondary);
}

.sidebar-action-btn {
  flex: 1;
  font-size: 13px;
  padding: 6px 12px;
  background-color: var(--background-primary);
  color: var(--text-primary);
  border: 1px solid var(--border-color);
}

.file-tree {
  flex: 1;
  overflow-y: auto;
  padding: 8px 0;
  background-color: var(--background-secondary);
}

.tree-empty {
  padding: 16px;
  text-align: center;
  color: var(--text-secondary);
  font-size: 14px;
}

.tree-loading {
  display: flex;
  flex-direction: column;
  align-items: center;
  justify-content: center;
  padding: 24px 16px;
  gap: 12px;
  color: var(--text-secondary);
}

.tree-loading .spinner {
  width: 24px;
  height: 24px;
}

.tree-item {
  display: flex;
  align-items: center;
  padding: 6px 8px;
  margin: 2px 0;
  border-radius: 4px;
  cursor: pointer;
  user-select: none;
  position: relative;
  transition: background-color 0.1s ease;
  color: var(--text-primary);
}

.tree-item:hover {
  background-color: var(--hover-color);
}

.tree-item.selected {
  background-color: var(--background-selected);
}

.tree-item-icon {
  margin-right: 8px;
  flex-shrink: 0;
  color: var(--icon-color);
}

.tree-item-content {
  display: flex;
  align-items: center;
  flex: 1;
  min-width: 0;
  overflow: hidden;
}

.tree-item-toggle {
  width: 20px;
  height: 20px;
  display: flex;
  align-items: center;
  justify-content: center;
  margin-right: 4px;
  cursor: pointer;
  color: var(--icon-color);
  z-index: 2;
}

.tree-item-toggle svg {
  transition: transform 0.15s ease-in-out;
  transform: rotate(0deg);
}

.tree-item-toggle.expanded svg {
  transform: rotate(90deg);
}

.tree-item-indent {
  width: 16px;
  flex-shrink: 0;
}

.tree-item-checkbox {
  margin-right: 8px;
  cursor: pointer;
}

.tree-item-name {
  flex: 1;
  min-width: 0;
  overflow: hidden;
  text-overflow: ellipsis;
  white-space: nowrap;
  color: var(--text-primary);
}

.tree-item-tokens {
  font-size: 11px;
  color: var(--text-secondary);
  margin-left: 6px;
  white-space: nowrap;
}

.tree-item-badge {
  font-size: 10px;
  padding: 1px 5px;
  border-radius: 4px;
  background-color: var(--hover-color);
  color: var(--text-secondary);
  margin-left: 6px;
  white-space: nowrap;
}

.content-area {
  flex: 1;
  display: flex;
  flex-direction: column;
  overflow: hidden;
  background-color: var(--background-primary);
  min-width: 0;
}

.content-header {
  display: flex;
  justify-content: space-between;
  align-items: center;
  padding: 16px 24px;
  border-bottom: 1px solid var(--border-color);
  background-color: var(--background-primary);
}

.content-title {
  font-size: 18px;
  font-weight: 600;
  color: var(--text-primary);
}

.content-actions {
  display: flex;
  align-items: center;
  gap: 16px;
}

.sort-dropdown {
  position: relative;
}

.sort-dropdown-button {
  display: flex;
  align-items: center;
  gap: 8px;
  font-size: 14px;
  color: var(--text-primary);
}

.sort-options {
  position: absolute;
  top: calc(100% + 4px);
  right: 0;
  background-color: var(--background-primary);
  border: 1px solid var(--border-color);
  border-radius: 4px;
  box-shadow: 0 2px 10px rgba(0, 0, 0, 0.1);
  z-index: 100;
  min-width: 180px;
}

.sort-option {
  padding: 8px 16px;
  cursor: pointer;
  transition: background-color 0.2s;
  color: var(--text-primary);
}

.sort-option:hover {
  background-color: var(--hover-color);
}

.sort-option.active {
  background-color: var(--background-selected);
  font-weight: 600;
  color: var(--accent-blue);
}

.file-stats {
  font-size: 14px;
  color: var(--text-secondary);
}

.file-list-container {
  flex: 1;
  overflow: hidden;
  display: flex;
  flex-direction: column;
}

.file-list {
  flex: 1;
  overflow-y: auto;
  padding: 16px;
  display: grid;
  grid-template-columns: repeat(auto-fill, minmax(220px, 1fr));
  grid-auto-rows: max-content;
  align-content: start;
  gap: 12px;
  background-color: var(--background-primary);
}

.file-list-empty {
  display: flex;
  align-items: center;
  justify-content: center;
  height: 100%;
  color: var(--text-secondary);
  font-size: 16px;
  padding: 32px;
  text-align: center;
}

.file-card {
  display: flex;
  flex-direction: column;
  padding: 10px;
  border: 1px solid var(--border-color);
  border-radius: 4px;
  position: relative;
  transition: all 0.2s ease;
  height: 80px;
  background-color: var(--background-primary);
}

.file-card:hover {
  background-color: var(--hover-color);
  box-shadow: 0 2px 8px rgba(0, 0, 0, 0.05);
}

.file-card.selected {
  border: 2px solid var(--accent-blue);
  background-color: var(--background-selected);
}

.file-card-header {
  display: flex;
  align-items: center;
  margin-bottom: 8px;
}

.file-card-icon {
  margin-right: 8px;
  color: var(--icon-color);
  flex-shrink: 0;
}

.file-card-name {
  font-weight: 500;
  flex: 1;
  overflow: hidden;
  text-overflow: ellipsis;
  white-space: nowrap;
  color: var(--text-primary);
}

.file-card-info {
  display: flex;
  flex-direction: column;
  margin-bottom: 0;
}

.file-card-tokens {
  color: var(--text-secondary);
  font-size: 13px;
}

.file-card-status {
  font-size: 13px;
  color: var(--text-secondary);
}

.file-card-actions {
  position: absolute;
  top: 8px;
  right: 8px;
  display: flex;
  gap: 4px;
  opacity: 0;
  transition: opacity 0.2s ease;
}

.file-card:hover .file-card-actions {
  opacity: 1;
}

.file-card-action {
  width: 24px;
  height: 24px;
  padding: 0;
  display: flex;
  align-items: center;
  justify-content: center;
  background-color: var(--background-primary);
  border: 1px solid var(--border-color);
  border-radius: 4px;
  color: var(--icon-color);
  transition: all 0.15s ease;
  box-shadow: 0 1px 3px rgba(0, 0, 0, 0.05);
}

.file-card-action:hover {
  background-color: var(--hover-color);
  color: var(--accent-blue);
  border-color: var(--accent-blue);
  transform: translateY(-1px);
  box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
}

.file-card-action:active {
  transform: translateY(0);
  box-shadow: 0 1px 2px rgba(0, 0, 0, 0.1);
}

.copy-button-container {
  padding: 16px 24px;
  border-top: 1px solid var(--border-color);
  display: flex;
  justify-content: center;
  align-items: center;
  background-color: var(--background-primary);
}

.copy-button {
  display: flex;
  align-items: center;
  justify-content: center;
  padding: 10px 16px;
  font-weight: 600;
  border-radius: 4px;
  transition: all 0.2s ease;
  gap: 8px;
  border: none;
  cursor: pointer;
  color: var(--primary-button-text);
  background-color: var(--primary-button-background);
}

.copy-button.primary {
  background-color: var(--primary-button-background);
  color: var(--primary-button-text);
  border: none;
}

.copy-button.primary:hover:not(:disabled) {
  background-color: var(--primary-button-background);
}

.copy-button.full-width {
  width: 100%;
  max-width: 400px;
}

.copy-button.copied {
  background-color: var(--success-color) !important;
  border-color: var(--success-color) !important;
  color: white !important;
  transition: all 0.2s ease;
  animation: flash-success 0.3s;
}

@keyframes flash-success {
  0% {
    opacity: 0.7;
  }
  50% {
    opacity: 1;
  }
  100% {
    opacity: 0.9;
  }
}

.copy-button-text {
  font-size: 14px;
  letter-spacing: 0.5px;
}

.copy-status {
  opacity: 0;
  transition: opacity 0.3s ease;
  color: var(--success-color);
  font-weight: 500;
}

.copy-status.visible {
  opacity: 1;
}

.processing-indicator {
  display: flex;
  align-items: center;
  justify-content: center;
  gap: 12px;
  padding: 12px;
  background-color: var(--background-secondary);
  border-bottom: 1px solid var(--border-color);
}

.spinner {
  width: 20px;
  height: 20px;
  border: 2px solid var(--text-secondary);
  border-top-color: transparent;
  border-radius: 50%;
  animation: spin 1s linear infinite;
}

@keyframes spin {
  to {
    transform: rotate(360deg);
  }
}

.cancel-btn {
  padding: 4px 12px;
  font-size: 13px;
  background-color: var(--error-color);
  color: white;
  border: none;
  border-radius: 4px;
  cursor: pointer;
  transition: opacity 0.2s ease;
}

.cancel-btn:hover {
  opacity: 0.9;
}

.error-message {
  background-color: var(--error-color);
  color: white;
  padding: 16px 24px;
  border-radius: 4px;
  margin: 24px;
  display: flex;
  align-items: center;
  gap: 8px;
}

.tree-loading,
.empty-tree,
.empty-list {
  padding: 16px;
  text-align: center;
  color: var(--text-secondary);
  font-style: italic;
}

.search-bar {
  position: relative;
  display: flex;
  align-items: center;
  width: 100%;
  background-color: var(--background-primary);
  border: 1px solid var(--border-color);
  border-radius: 4px;
  box-shadow: 0 1px 2px rgba(0, 0, 0, 0.05);
  transition: border-color 0.2s, box-shadow 0.2s;
}

.search-bar.focused {
  border-color: var(--accent-blue);
  box-shadow: 0 0 0 1px var(--accent-blue);
}

.search-icon {
  position: absolute;
  left: 10px;
  top: 50%;
  transform: translateY(-50%);
  color: var(--icon-color);
  display: flex;
  align-items: center;
  justify-content: center;
  pointer-events: none;
  z-index: 2;
  width: 16px;
  height: 16px;
}

.search-bar .search-input,
input[type="search"].search-input,
input[type="text"].search-input {
  width: 100%;
  padding: 8px 32px 8px 36px !important;
  border: none;
  border-radius: 4px;
  font-size: 14px;
  outline: none;
  background-color: transparent;
  color: var(--text-primary);
}

.search-bar .search-input:focus,
input[type="search"].search-input:focus,
input[type="text"].search-input:focus {
  border-color: var(--accent-blue);
  box-shadow: 0 0 0 1px var(--accent-blue);
}

.search-clear-btn {
  position: absolute;
  right: 8px;
  top: 50%;
  transform: translateY(-50%);
  background: none;
  border: none;
  padding: 4px;
  color: var(--icon-color);
  display: flex;
  align-items: center;
  justify-content: center;
  border-radius: 50%;
  cursor: pointer;
  z-index: 2;
}

.search-clear-btn:hover {
  background-color: var(--hover-color);
}

.sidebar-resize-handle {
  position: absolute;
  top: 0;
  right: -5px;
  width: 10px;
  height: 100%;
  cursor: col-resize;
  z-index: 10;
  opacity: 0;
}

.sidebar-resize-handle:hover,
.sidebar-resize-handle:active {
  opacity: 1;
  background-color: rgba(0, 0, 0, 0.1);
}

.selected-folder {
  font-size: 14px;
  color: var(--text-secondary);
  overflow: hidden;
  text-overflow: ellipsis;
  white-space: nowrap;
  max-width: 500px;
  display: inline-block;
}

/* macOS-style segmented control for theme toggle */
.theme-segmented-control {
  display: flex;
  background-color: var(--background-secondary);
  border-radius: 6px;
  padding: 2px;
  box-shadow: 0 1px 3px rgba(0, 0, 0, 0.1);
  width: fit-content;
  position: relative;
  height: 32px;
  overflow: hidden;
}

.theme-segment {
  display: flex;
  align-items: center;
  justify-content: center;
  gap: 6px;
  padding: 0 12px;
  height: 28px;
  border: none;
  background: none;
  font-size: 13px;
  font-weight: 500;
  color: var(--text-secondary);
  position: relative;
  z-index: 1;
  transition: color 0.2s ease;
  border-radius: 4px;
  cursor: pointer;
  white-space: nowrap;
  min-width: 70px;
}

.theme-segment:focus {
  outline: none;
}

.theme-segment span {
  font-size: 12px;
}

.theme-segment.active {
  color: var(--text-primary);
  background-color: var(--background-primary);
  box-shadow: 0 1px 2px rgba(0, 0, 0, 0.1);
}

/* For dark mode, adjust active segment appearance */
.dark-mode .theme-segment.active {
  background-color: rgba(255, 255, 255, 0.1);
}

/* Animation for segment transition */
.theme-segment {
  transition: background-color 0.2s ease, color 0.2s ease, box-shadow 0.2s ease;
}

.header-actions {
  display: flex;
  align-items: center;
  gap: 16px;
}

.tree-item.disabled-item {
  opacity: 0.7;
  cursor: default;
}

.tree-item.disabled-item .tree-item-badge {
  font-size: 10px;
  padding: 1px 5px;
  border-radius: 4px;
  background-color: var(--hover-color);
  color: var(--text-secondary);
  margin-left: 6px;
  white-space: nowrap;
}

/*--------------------------------------------------------------
9. User Instructions Area
--------------------------------------------------------------*/

/* User instructions container */
.user-instructions-container {
  padding: 8px 16px 16px 16px;
  display: flex;
  flex-direction: column;
  background-color: var(--background-primary);
  border-top: 1px solid var(--border-color);
  margin-top: auto; /* Push to bottom of container */
}

.user-instructions {
  width: 100%;
}

/* User instructions textarea */
.user-instructions textarea {
  color: var(--text-primary);
  line-height: 1.5;
  font-size: 0.95rem;
  border: 1px solid var(--border-color);
  border-radius: 4px;
  padding: 10px;
  background-color: var(--background-primary);
  box-shadow: 0 1px 2px rgba(0, 0, 0, 0.05);
  transition: border-color 0.2s ease, box-shadow 0.2s ease;
  width: 100%;
  height: 100px; /* Fixed height */
}

.user-instructions textarea:focus {
  outline: none;
  border-color: var(--accent-blue);
  box-shadow: 0 0 0 2px rgba(14, 99, 156, 0.2);
}

.user-instructions textarea::placeholder {
  color: var(--text-secondary);
  opacity: 0.7;
}

/* Dark mode specific textarea styles */
.dark-mode .user-instructions textarea {
  background-color: #252526; /* Slightly darker than background-secondary */
  box-shadow: 0 1px 3px rgba(0, 0, 0, 0.2);
}

.dark-mode .user-instructions textarea:focus {
  box-shadow: 0 0 0 2px rgba(14, 99, 156, 0.3);
}

/* User instructions header */
.user-instructions-header {
  display: flex;
  justify-content: space-between;
  align-items: center;
  padding: 10px 0px 8px 0px;
  background-color: var(--background-primary);
  border-bottom: none;
}

/* User instructions description text */
.user-instructions-description {
  color: var(--text-secondary);
  font-size: 0.85rem;
  margin-bottom: 8px;
  line-height: 1.4;
}

.dark-mode .user-instructions-description {
  opacity: 0.85;
}

/*==============================================================================
 10. UTILITIES & ANIMATIONS
==============================================================================*/

/* Search Bar
 * Reusable search input with icon and clear button
 * Consistent styling across the application
 */
.search-bar {
  position: relative;
  width: 100%;
  display: flex;
  align-items: center;
  border: 1px solid var(--border-color);
  border-radius: 4px;
  background-color: var(--background-primary);
  transition: all 0.2s ease;
}

.search-bar.focused {
  border-color: var(--accent-blue);
  box-shadow: 0 0 0 1px var(--accent-blue);
}

/* Search Icon
 * Visual indicator for search functionality
 * Positioned inside the input for cleaner look
 */
.search-icon {
  position: absolute;
  left: 8px;
  top: 50%;
  transform: translateY(-50%);
  width: 16px;
  height: 16px;
  color: var(--text-secondary);
  pointer-events: none;
}

.search-bar .search-input,
.search-bar input[type="search"] {
  flex: 1;
  border: none;
  padding: 8px 8px 8px 32px;
  background-color: transparent;
  font-size: 13px;
  outline: none;
  color: var(--text-primary);
}

.search-bar .search-input:focus,
.search-bar input[type="search"]:focus {
  border: none;
  box-shadow: none;
}

/* Search Clear Button
 * Allows users to quickly clear the search input
 * Visible only when search has content
 */
.search-clear-btn {
  background: none;
  border: none;
  padding: 0 8px;
  color: var(--text-secondary);
  cursor: pointer;
  display: flex;
  align-items: center;
  justify-content: center;
  font-size: 16px;
  height: 100%;
  opacity: 0.7;
  transition: opacity 0.2s ease;
}

.search-clear-btn:hover {
  opacity: 1;
}

/* Sidebar Resize Handle
 * Allows user to adjust the width of the sidebar
 * Changes appearance on hover for affordance
 */
.sidebar-resize-handle {
  position: absolute;
  right: -3px;
  top: 0;
  width: 6px;
  height: 100%;
  cursor: ew-resize;
  z-index: 10;
}

.sidebar-resize-handle:hover,
.sidebar-resize-handle.dragging {
  background-color: var(--accent-blue);
  opacity: 0.5;
}

/* Theme Toggle Control
 * Allows switching between light and dark themes
 * Segmented control with active state indicator
 */
.theme-segmented-control {
  display: flex;
  border: 1px solid var(--border-color);
  border-radius: 6px;
  overflow: hidden;
  background-color: var(--background-secondary);
  margin-left: 16px;
}

.theme-segment {
  padding: 4px 10px;
  font-size: 12px;
  background: none;
  border: none;
  cursor: pointer;
  position: relative;
  display: flex;
  align-items: center;
  justify-content: center;
  color: var(--text-secondary);
  transition: all 0.2s ease;
  border-right: 1px solid var(--border-color);
  margin: 0;
}

.theme-segment:focus {
  outline: none;
}

.theme-segment span {
  position: relative;
}

.theme-segment.active {
  background-color: var(--accent-blue);
  color: white;
  font-weight: 500;
  border-right-color: var(--accent-blue);
}

.dark-mode .theme-segment.active {
  background-color: var(--accent-blue);
}

.theme-segment {
  padding: 4px 10px;
}

/* Header Actions
 * Container for right-aligned header controls
 * Ensures proper spacing between controls
 */
.header-actions {
  display: flex;
  align-items: center;
  gap: 8px;
}

/* Disabled Tree Item
 * Visual styling for files that can't be processed
 * Uses subdued appearance to indicate unavailability
 */
.tree-item.disabled-item {
  opacity: 0.6;
  cursor: not-allowed;
}

.tree-item.disabled-item .tree-item-badge {
  background-color: var(--error-color);
  color: white;
  opacity: 0.7;
  font-size: 9px;
  padding: 1px 3px;
  text-transform: uppercase;
  letter-spacing: 0.5px;
}

/* Helper Classes
 * Various utility classes for common style patterns
 * Can be combined with component classes for specific effects
 */
</file>

<file path="src/utils/pathUtils.ts">
/**
 * A collection of path utilities that work in both browser and desktop environments.
 * These functions handle the tricky bits of working with file paths across different
 * operating systems (Windows, Mac, Linux) so you don't have to worry about it.
 */

/**
 * Browser-compatible path utilities to replace Node.js path module
 */

/**
 * Normalizes a file path to use forward slashes regardless of operating system
 * This helps with path comparison across different platforms
 * 
 * @param filePath The file path to normalize
 * @returns The normalized path with forward slashes
 */
export function normalizePath(filePath: string): string {
  if (!filePath) return filePath;
  
  // Replace backslashes with forward slashes
  return filePath.replace(/\\/g, '/');
}

/**
 * Detects the operating system
 * 
 * @returns The detected operating system ('windows', 'mac', 'linux', or 'unknown')
 */
export function detectOS(): 'windows' | 'mac' | 'linux' | 'unknown' {
  if (typeof window !== 'undefined' && window.navigator) {
    const platform = window.navigator.platform.toLowerCase();
    
    if (platform.includes('win')) {
      return 'windows';
    } else if (platform.includes('mac')) {
      return 'mac';
    } else if (platform.includes('linux')) {
      return 'linux';
    }
  }
  
  return 'unknown';
}

/**
 * Quick check if we're running on Windows.
 * Useful when we need to handle Windows-specific path quirks.
 */
export function isWindows(): boolean {
  return detectOS() === 'windows';
}

/**
 * Compares two paths for equality, handling different OS path separators
 * and platform-specific case sensitivity
 * 
 * @param path1 First path to compare
 * @param path2 Second path to compare
 * @returns True if the paths are equivalent, false otherwise
 */
export function arePathsEqual(path1: string, path2: string): boolean {
  // Handle null/undefined cases
  if (!path1 && !path2) return true;
  if (!path1 || !path2) return false;
  
  const normalizedPath1 = normalizePath(path1);
  const normalizedPath2 = normalizePath(path2);
  
  // On Windows, paths are case-insensitive
  if (isWindows()) {
    return normalizedPath1.toLowerCase() === normalizedPath2.toLowerCase();
  }
  
  // On other systems (Mac, Linux), paths are case-sensitive
  return normalizedPath1 === normalizedPath2;
}

/**
 * Extract the basename from a path string
 * @param path The path to extract the basename from
 * @returns The basename (last part of the path)
 */
export function basename(path: string | null | undefined): string {
  if (!path) return "";

  // Ensure path is a string
  const pathStr = String(path);

  // Handle both forward and backslashes
  const normalizedPath = pathStr.replace(/\\/g, "/");
  // Remove trailing slashes
  const trimmedPath = normalizedPath.endsWith("/")
    ? normalizedPath.slice(0, -1)
    : normalizedPath;
  // Get the last part after the final slash
  const parts = trimmedPath.split("/");
  return parts[parts.length - 1] || "";
}

/**
 * Extract the directory name from a path string
 * @param path The path to extract the directory from
 * @returns The directory (everything except the last part)
 */
export function dirname(path: string | null | undefined): string {
  if (!path) return ".";

  // Ensure path is a string
  const pathStr = String(path);

  // Handle both forward and backslashes
  const normalizedPath = pathStr.replace(/\\/g, "/");
  // Remove trailing slashes
  const trimmedPath = normalizedPath.endsWith("/")
    ? normalizedPath.slice(0, -1)
    : normalizedPath;
  // Get everything before the final slash
  const lastSlashIndex = trimmedPath.lastIndexOf("/");
  return lastSlashIndex === -1 ? "." : trimmedPath.slice(0, lastSlashIndex);
}

/**
 * Join path segments together
 * @param segments The path segments to join
 * @returns The joined path
 */
export function join(...segments: (string | null | undefined)[]): string {
  return segments
    .filter(Boolean)
    .map((seg) => String(seg))
    .join("/")
    .replace(/\/+/g, "/"); // Replace multiple slashes with a single one
}

/**
 * Get the file extension
 * @param path The path to get the extension from
 * @returns The file extension including the dot
 */
export function extname(path: string | null | undefined): string {
  if (!path) return "";

  const basenameValue = basename(path);
  const dotIndex = basenameValue.lastIndexOf(".");
  return dotIndex === -1 || dotIndex === 0 ? "" : basenameValue.slice(dotIndex);
}

/**
 * Checks if one path is a subpath of another, handling platform-specific
 * path separators and case sensitivity
 * 
 * @param parent The potential parent path
 * @param child The potential child path
 * @returns True if child is a subpath of parent
 */
export function isSubPath(parent: string, child: string): boolean {
  // Handle null/undefined cases
  if (!parent || !child) return false;
  
  const normalizedParent = normalizePath(parent);
  const normalizedChild = normalizePath(child);
  
  // Ensure parent path ends with a slash for proper subpath checking
  // This prevents '/foo/bar' from matching '/foo/bart'
  const parentWithSlash = normalizedParent.endsWith('/') 
    ? normalizedParent 
    : normalizedParent + '/';
  
  if (isWindows()) {
    // Case-insensitive comparison for Windows
    return normalizedChild.toLowerCase() === normalizedParent.toLowerCase() || 
           normalizedChild.toLowerCase().startsWith(parentWithSlash.toLowerCase());
  }
  
  // Case-sensitive comparison for other platforms
  return normalizedChild === normalizedParent || 
         normalizedChild.startsWith(parentWithSlash);
}

/**
 * Generate an ASCII representation of the file tree for the selected files
 * @param files Array of selected FileData objects
 * @param rootPath The root directory path
 * @returns ASCII string representing the file tree
 */
export function generateAsciiFileTree(files: { path: string }[], rootPath: string): string {
  if (!files.length) return "No files selected.";

  // Normalize the root path for consistent path handling
  const normalizedRoot = rootPath.replace(/\\/g, "/").replace(/\/$/, "");
  
  // Create a tree structure from the file paths
  interface TreeNode {
    name: string;
    isFile: boolean;
    children: Record<string, TreeNode>;
  }
  
  const root: TreeNode = { name: basename(normalizedRoot), isFile: false, children: {} };
  
  // Insert a file path into the tree
  const insertPath = (filePath: string, node: TreeNode) => {
    const normalizedPath = filePath.replace(/\\/g, "/");
    if (!normalizedPath.startsWith(normalizedRoot)) return;
    
    const relativePath = normalizedPath.substring(normalizedRoot.length).replace(/^\//, "");
    if (!relativePath) return;
    
    const pathParts = relativePath.split("/");
    let currentNode = node;
    
    for (let i = 0; i < pathParts.length; i++) {
      const part = pathParts[i];
      const isFile = i === pathParts.length - 1;
      
      if (!currentNode.children[part]) {
        currentNode.children[part] = {
          name: part,
          isFile,
          children: {}
        };
      }
      
      currentNode = currentNode.children[part];
    }
  };
  
  // Insert all files into the tree
  files.forEach(file => insertPath(file.path, root));
  
  // Generate ASCII representation
  const generateAscii = (node: TreeNode, prefix = "", isLast = true, isRoot = true): string => {
    if (!isRoot) {
      let result = prefix;
      result += isLast ? "‚îî‚îÄ‚îÄ " : "‚îú‚îÄ‚îÄ ";
      result += node.name;
      result += "\n";
      prefix += isLast ? "    " : "‚îÇ   ";
      
      const children = Object.values(node.children).sort((a, b) => {
        // Sort by type (directories first) then by name
        if (a.isFile !== b.isFile) {
          return a.isFile ? 1 : -1;
        }
        return a.name.localeCompare(b.name);
      });
      
      return result + children
        .map((child, index) =>
          generateAscii(child, prefix, index === children.length - 1, false)
        )
        .join("");
    } else {
      // Root node special handling
      const children = Object.values(node.children).sort((a, b) => {
        // Sort by type (directories first) then by name
        if (a.isFile !== b.isFile) {
          return a.isFile ? 1 : -1;
        }
        return a.name.localeCompare(b.name);
      });
      
      return children
        .map((child, index) =>
          generateAscii(child, prefix, index === children.length - 1, false)
        )
        .join("");
    }
  };
  
  return generateAscii(root);
}
</file>

<file path="src/types/FileTypes.ts">
export interface FileData {
  name: string;
  path: string;
  content: string;
  tokenCount: number;
  size: number;
  isBinary: boolean;
  isSkipped: boolean;
  error?: string;
  fileType?: string;
  excludedByDefault?: boolean;
  isDirectory?: boolean;
}

export interface TreeNode {
  id: string;
  name: string;
  path: string;
  type: "file" | "directory";
  children?: TreeNode[];
  isExpanded?: boolean;
  level: number;
  fileData?: FileData;
}

export interface SidebarProps {
  selectedFolder: string | null;
  openFolder: () => void;
  allFiles: FileData[];
  selectedFiles: string[];
  toggleFileSelection: (filePath: string) => void;
  toggleFolderSelection: (folderPath: string, isSelected: boolean) => void;
  searchTerm: string;
  onSearchChange: (term: string) => void;
  selectAllFiles: () => void;
  deselectAllFiles: () => void;
  expandedNodes: Record<string, boolean>;
  toggleExpanded: (nodeId: string) => void;
}

export interface FileListProps {
  files: FileData[];
  selectedFiles: string[];
  toggleFileSelection: (filePath: string) => void;
}

export interface FileCardProps {
  file: FileData;
  isSelected: boolean;
  toggleSelection: (filePath: string) => void;
}

export interface TreeItemProps {
  node: TreeNode;
  selectedFiles: string[];
  toggleFileSelection: (filePath: string) => void;
  toggleFolderSelection: (folderPath: string, isSelected: boolean) => void;
  toggleExpanded: (nodeId: string) => void;
  allFiles: FileData[];
}

export interface SortOption {
  value: string;
  label: string;
}

export interface SearchBarProps {
  searchTerm: string;
  onSearchChange: (term: string) => void;
}

export interface CopyButtonProps {
  onCopy: () => void;
  isDisabled: boolean;
  copyStatus: boolean;
}
</file>

<file path="package.json">
{
  "name": "pastemax",
  "version": "1.2.0",
  "main": "main.js",
  "scripts": {
    "start": "electron .",
    "dev": "vite",
    "dev:electron": "cross-env NODE_ENV=development node dev.js",
    "build": "vite build",
    "build-electron": "cross-env NODE_ENV=production node build.js",
    "verify-build": "node scripts/verify-build.js",
    "test-build": "node scripts/test-local-build.js",
    "test-build:mac": "node scripts/test-local-build.js mac",
    "test-build:win": "node scripts/test-local-build.js win",
    "test-build:linux": "node scripts/test-local-build.js linux",
    "debug-gh-release": "git tag debug-v$(date +'%Y%m%d%H%M%S') && git push origin --tags",
    "package": "cross-env NODE_ENV=production vite build && electron-builder --publish=never",
    "package:mac": "cross-env NODE_ENV=production vite build && electron-builder --mac --publish=never",
    "package:win": "cross-env NODE_ENV=production vite build && electron-builder --win --publish=never",
    "package:linux": "cross-env NODE_ENV=production vite build && electron-builder --linux --publish=never",
    "package:all": "cross-env NODE_ENV=production vite build && electron-builder -mwl --publish=never",
    "release": "cross-env NODE_ENV=production vite build && electron-builder --publish=onTagOrDraft",
    "lint": "eslint . --ext ts,tsx --report-unused-disable-directives",
    "lint:strict": "eslint . --ext ts,tsx --report-unused-disable-directives --max-warnings 0",
    "preview": "vite preview"
  },
  "keywords": [
    "clipboard",
    "code",
    "developer-tools",
    "electron",
    "file-viewer"
  ],
  "author": {
    "name": "kleneway",
    "email": "kleneway@notreal.com"
  },
  "license": "MIT",
  "description": "A modern file viewer application for developers to easily navigate, search, and copy code from repositories.",
  "build": {
    "appId": "com.kleneway.pastemax",
    "productName": "PasteMax",
    "directories": {
      "output": "release-builds"
    },
    "files": [
      "dist/**/*",
      "main.js",
      "preload.js",
      "excluded-files.js",
      "node_modules/**/*"
    ],
    "mac": {
      "category": "public.app-category.developer-tools",
      "icon": "public/favicon.icns",
      "target": [
        "dmg",
        "zip"
      ],
      "hardenedRuntime": true,
      "gatekeeperAssess": false,
      "entitlements": "build/entitlements.mac.plist",
      "entitlementsInherit": "build/entitlements.mac.plist"
    },
    "win": {
      "target": [
        "nsis",
        "portable"
      ],
      "icon": "public/favicon.ico"
    },
    "linux": {
      "target": [
        "AppImage",
        "deb",
        "rpm"
      ],
      "category": "Development",
      "icon": "public/favicon.png"
    },
    "asarUnpack": [
      "node_modules/ignore/**",
      "node_modules/tiktoken/**",
      "node_modules/gpt-3-encoder/**"
    ],
    "asar": true,
    "afterSign": "scripts/notarize.js",
    "publish": [
      "github"
    ],
    "protocols": {
      "name": "pastemax-protocol",
      "schemes": [
        "pastemax"
      ]
    }
  },
  "devDependencies": {
    "@electron/notarize": "^2.5.0",
    "@types/node": "^20.10.5",
    "@types/react": "^18.2.43",
    "@types/react-dom": "^18.2.17",
    "@typescript-eslint/eslint-plugin": "^6.14.0",
    "@typescript-eslint/parser": "^6.14.0",
    "@vitejs/plugin-react": "^4.2.1",
    "cross-env": "^7.0.3",
    "electron": "^34.3.0",
    "electron-builder": "^24.13.3",
    "eslint": "^8.55.0",
    "eslint-plugin-react-hooks": "^4.6.0",
    "eslint-plugin-react-refresh": "^0.4.5",
    "typescript": "^5.3.3",
    "vite": "^5.0.8"
  },
  "dependencies": {
    "gpt-3-encoder": "^1.1.4",
    "ignore": "^7.0.3",
    "lucide-react": "^0.477.0",
    "react": "^18.2.0",
    "react-dom": "^18.2.0",
    "tiktoken": "^1.0.20"
  }
}
</file>

<file path="src/components/Sidebar.tsx">
import React, { useState, useEffect, useRef } from "react";
import { SidebarProps, TreeNode, FileData } from "../types/FileTypes";
import SearchBar from "./SearchBar";
import TreeItem from "./TreeItem";

/**
 * Import path utilities for handling file paths across different operating systems.
 * While not all utilities are used directly, they're kept for consistency and future use.
 */
import { normalizePath, join, isSubPath, arePathsEqual, basename } from "../utils/pathUtils";

/**
 * The Sidebar component displays a tree view of files and folders, allowing users to:
 * - Navigate through the file structure
 * - Select/deselect files and folders
 * - Search for specific files
 * - Resize the sidebar width
 */
const Sidebar = ({
  selectedFolder,
  allFiles,
  selectedFiles,
  toggleFileSelection,
  toggleFolderSelection,
  searchTerm,
  onSearchChange,
  selectAllFiles,
  deselectAllFiles,
  expandedNodes,
  toggleExpanded,
}: Omit<SidebarProps, 'openFolder'>) => {
  // State for managing the file tree and UI
  const [fileTree, setFileTree] = useState(() => [] as TreeNode[]);
  const [isTreeBuildingComplete, setIsTreeBuildingComplete] = useState(false);
  const [sidebarWidth, setSidebarWidth] = useState(300);
  const [isResizing, setIsResizing] = useState(false);

  // Sidebar width constraints for a good UX
  const MIN_SIDEBAR_WIDTH = 200;
  const MAX_SIDEBAR_WIDTH = 500;

  // Handle mouse down for resizing
  const handleResizeStart = (e: any) => {
    e.preventDefault();
    setIsResizing(true);
  };

  // Handle resize effect
  useEffect(() => {
    const handleResize = (e: any) => {
      if (isResizing) {
        const newWidth = e.clientX;
        if (newWidth >= MIN_SIDEBAR_WIDTH && newWidth <= MAX_SIDEBAR_WIDTH) {
          setSidebarWidth(newWidth);
        }
      }
    };

    const handleResizeEnd = () => {
      setIsResizing(false);
    };

    document.addEventListener("mousemove", handleResize);
    document.addEventListener("mouseup", handleResizeEnd);

    return () => {
      document.removeEventListener("mousemove", handleResize);
      document.removeEventListener("mouseup", handleResizeEnd);
    };
  }, [isResizing]);

  // Build file tree structure from flat list of files
  useEffect(() => {
    if (allFiles.length === 0) {
      setFileTree([]);
      setIsTreeBuildingComplete(false);
      return;
    }

    const buildTree = () => {
      console.log("Building file tree from", allFiles.length, "files");
      setIsTreeBuildingComplete(false);

      try {
        // First, find the root folder item if it exists
        const normalizedSelectedFolder = selectedFolder ? normalizePath(selectedFolder) : '';
        
        if (!normalizedSelectedFolder) {
          console.warn("Selected folder path is empty, can't build tree");
          setFileTree([]);
          setIsTreeBuildingComplete(true);
          return;
        }
        
        // Check if we have any valid files to process
        if (!Array.isArray(allFiles) || allFiles.length === 0) {
          console.warn("No files to process for tree building");
          setFileTree([]);
          setIsTreeBuildingComplete(true);
          return;
        }
        
        const rootFolderItem = allFiles.find(file => 
          file && file.path && file.isDirectory && arePathsEqual(normalizePath(file.path), normalizedSelectedFolder)
        );
        
        console.log("Root folder item found:", rootFolderItem ? "yes" : "no", 
          rootFolderItem ? `(${rootFolderItem.path})` : "");
        
        // Count directory items for debugging
        const directoryItems = allFiles.filter(file => file.isDirectory);
        console.log(`Found ${directoryItems.length} directory items in allFiles`);
        
        if (directoryItems.length > 0) {
          // Log the first few directory items for debugging
          directoryItems.slice(0, 3).forEach(dir => {
            console.log(`Directory: ${dir.name}, path: ${dir.path}, isDirectory: ${dir.isDirectory}`);
          });
        }

        // Create the tree structure starting with the root
        let rootTree: TreeNode[] = [];
        
        if (rootFolderItem) {
          // If we found a root folder item, use it as the top-level node
          const rootNode: TreeNode = {
            id: `node-${normalizedSelectedFolder}`,
            name: rootFolderItem.name || basename(normalizedSelectedFolder),
            path: normalizedSelectedFolder,
            type: "directory",
            level: 0,
            children: [],
            isExpanded: expandedNodes[`node-${normalizedSelectedFolder}`] !== false,
            fileData: rootFolderItem
          };
          
          // Then build the rest of the tree under this root
          buildChildrenTree(rootNode, allFiles, normalizedSelectedFolder);
          rootTree = [rootNode];
          console.log("Built tree with root node:", rootNode.name);
        } else {
          // If no root folder was found, build the tree from the files directly
          console.log("No root folder item found, building from direct file list");
          const fileMap: Record<string, any> = {};
          
          // First pass: create directories and files
          allFiles.forEach((file) => {
            if (!file.path) {
              console.log("Skipping file with no path");
              return;
            }
            
            // Skip excluded files
            if (file.excludedByDefault) {
              console.log("Skipping excluded file:", file.name);
              return;
            }
            
            const normalizedFilePath = normalizePath(file.path);
            
            // Skip the root folder itself as we're handling it separately
            if (arePathsEqual(normalizedFilePath, normalizedSelectedFolder)) {
              console.log("Skipping root folder in file loop:", normalizedFilePath);
              return;
            }
            
            // Get the relative path for non-root files
            const relativePath = normalizedSelectedFolder && isSubPath(normalizedSelectedFolder, normalizedFilePath)
              ? normalizedFilePath.substring(normalizedSelectedFolder.length + 1)
              : normalizedFilePath;
            
            const parts = relativePath.split('/');
            
            // Extra validation to prevent issues with malformed paths
            if (parts.length === 0 || (parts.length === 1 && parts[0] === '')) {
              console.log("Skipping invalid path:", relativePath);
              return;
            }
            
            let currentPath = '';
            let current = fileMap;
            
            for (let i = 0; i < parts.length; i++) {
              const part = parts[i];
              if (!part) continue;
              
              currentPath = currentPath ? join(currentPath, part) : part;
              const fullPath = normalizedSelectedFolder
                ? join(normalizedSelectedFolder, currentPath)
                : currentPath;
              
              if (i === parts.length - 1) {
                // This is a file
                current[part] = {
                  id: `node-${file.path}`,
                  name: part,
                  path: file.path,
                  type: "file",
                  level: i + 1,
                  fileData: file,
                };
              } else {
                // This is a directory
                if (!current[part]) {
                  current[part] = {
                    id: `node-${fullPath}`,
                    name: part,
                    path: fullPath,
                    type: "directory",
                    level: i + 1,
                    children: {},
                  };
                }
                current = current[part].children;
              }
            }
          });
          
          // Convert to TreeNode array
          rootTree = convertToTreeNodes(fileMap);
          console.log("Built tree from fileMap, found nodes:", rootTree.length);
        }

        // Sort the top level (directories first, then by name)
        const sortedTree = rootTree.sort((a, b) => {
          if (a.type === "directory" && b.type === "file") return -1;
          if (a.type === "file" && b.type === "directory") return 1;

          // Sort files by token count (largest first)
          if (a.type === "file" && b.type === "file") {
            const aTokens = a.fileData?.tokenCount || 0;
            const bTokens = b.fileData?.tokenCount || 0;
            return bTokens - aTokens;
          }

          return a.name.localeCompare(b.name);
        });

        setFileTree(sortedTree);
        setIsTreeBuildingComplete(true);
        console.log("Tree building complete, nodes:", sortedTree.length);
      } catch (err) {
        console.error("Error building file tree:", err);
        // On error, try to build a simple flat tree as a fallback
        try {
          console.log("Attempting to build a simple flat tree as fallback");
          const flatTree = allFiles
            .filter(file => 
              !arePathsEqual(normalizePath(file.path), selectedFolder ? normalizePath(selectedFolder) : '') && 
              !file.excludedByDefault // Filter out excluded files
            )
            .map((file, index) => {
              return {
                id: `node-${file.path}`,
                name: file.name,
                path: file.path,
                type: file.isDirectory ? "directory" as const : "file" as const,
                level: 0,
                fileData: file,
                isExpanded: true
              };
            })
            .sort((a, b) => {
              // Sort directories first
              if (a.type === "directory" && b.type === "file") return -1;
              if (a.type === "file" && b.type === "directory") return 1;
              return a.name.localeCompare(b.name);
            });
            
          setFileTree(flatTree);
          setIsTreeBuildingComplete(true);
          console.log("Built simple flat tree with", flatTree.length, "items");
        } catch (fallbackError) {
          console.error("Fallback tree building also failed:", fallbackError);
          setFileTree([]);
          setIsTreeBuildingComplete(true);
        }
      }
    };

    // Helper function to build children tree under a parent node
    const buildChildrenTree = (parentNode: TreeNode, files: any[], parentPath: string) => {
      try {
        // Find direct children of this parent
        const childFiles = files.filter(file => {
          if (!file || !file.path) {
            console.warn("Found invalid file entry in buildChildrenTree");
            return false;
          }
          if (arePathsEqual(file.path, parentPath)) return false; // Skip the parent itself
          if (file.excludedByDefault) return false; // Skip excluded files
          
          const normalizedPath = normalizePath(file.path);
          return isSubPath(parentPath, normalizedPath) && 
                 // Only direct children (one level down)
                 normalizedPath.substring(parentPath.length + 1).split('/').length === 1;
        });
        
        console.log(`Building children tree for ${parentNode.name}, found ${childFiles.length} direct children`);
        
        // Sort children (directories first, then files)
        const sortedChildren = childFiles.sort((a: any, b: any) => {
          // Make sure we treat isDirectory consistently
          const aIsDir = Boolean(a.isDirectory);
          const bIsDir = Boolean(b.isDirectory);
          
          if (aIsDir && !bIsDir) return -1;
          if (!aIsDir && bIsDir) return 1;
          return a.name.localeCompare(b.name);
        });
        
        // Create tree nodes for children
        parentNode.children = sortedChildren.map((file: any) => {
          if (!file || !file.path) {
            console.warn("Skipping invalid file in children map");
            return null;
          }
          
          const nodePath = normalizePath(file.path);
          const nodeId = `node-${nodePath}`;
          const isDirectory = Boolean(file.isDirectory);
          
          const node: TreeNode = {
            id: nodeId,
            name: file.name || basename(nodePath),
            path: nodePath,
            type: isDirectory ? "directory" : "file",
            level: parentNode.level + 1,
            fileData: file,
            isExpanded: expandedNodes[nodeId] !== undefined ? expandedNodes[nodeId] : true // Default to expanded
          };
          
          if (isDirectory) {
            node.children = [];
            buildChildrenTree(node, files, nodePath);
          }
          
          return node;
        }).filter(node => node !== null) as TreeNode[]; // Filter out null values
      } catch (err) {
        console.error(`Error building children tree for ${parentNode.name}:`, err);
        parentNode.children = []; // Ensure we have a valid array even on error
      }
    };

    // Helper function to convert the file map to TreeNode array
    const convertToTreeNodes = (node: Record<string, any>, level = 0): TreeNode[] => {
      return Object.keys(node).map((key) => {
        const item = node[key];

        if (item.type === "file") {
          return item as TreeNode;
        } else {
          const children = convertToTreeNodes(item.children, level + 1);
          const isExpanded = expandedNodes[item.id] !== undefined ? expandedNodes[item.id] : true;

          return {
            ...item,
            children: children.sort((a, b) => {
              if (a.type === "directory" && b.type === "file") return -1;
              if (a.type === "file" && b.type === "directory") return 1;
              if (a.type === "file" && b.type === "file") {
                const aTokens = a.fileData?.tokenCount || 0;
                const bTokens = b.fileData?.tokenCount || 0;
                return bTokens - aTokens;
              }
              return a.name.localeCompare(b.name);
            }),
            isExpanded,
          };
        }
      });
    };

    // Use a timeout to not block UI
    const buildTreeTimeoutId = setTimeout(buildTree, 0);
    return () => clearTimeout(buildTreeTimeoutId);
  }, [allFiles, selectedFolder, expandedNodes]);

  // Apply expanded state as a separate operation when expandedNodes change
  useEffect(() => {
    if (fileTree.length === 0) return;

    // Function to apply expanded state to nodes
    const applyExpandedState = (nodes: TreeNode[]): TreeNode[] => {
      return nodes.map((node: TreeNode): TreeNode => {
        if (node.type === "directory") {
          const isExpanded =
            expandedNodes[node.id] !== undefined
              ? expandedNodes[node.id]
              : true; // Default to expanded if not in state

          return {
            ...node,
            isExpanded,
            children: node.children ? applyExpandedState(node.children) : [],
          };
        }
        return node;
      });
    };

    setFileTree((prevTree: TreeNode[]) => applyExpandedState(prevTree));
  }, [expandedNodes, fileTree.length]);

  // Flatten the tree for rendering with proper indentation
  const flattenTree = (nodes: TreeNode[]): TreeNode[] => {
    let result: TreeNode[] = [];

    nodes.forEach((node) => {
      // Add the current node
      result.push(node);

      // If it's a directory and it's expanded, add its children
      if (node.type === "directory" && node.isExpanded && node.children) {
        result = [...result, ...flattenTree(node.children)];
      }
    });

    return result;
  };

  // Filter the tree based on search term
  const filterTree = (nodes: TreeNode[], term: string): TreeNode[] => {
    if (!term) {
      // When not searching, filter out excluded files/folders
      return nodes.filter(node => {
        // Skip excluded files/folders
        if (node.fileData?.excludedByDefault) {
          return false;
        }
        
        // For directories, also filter their children
        if (node.type === "directory" && node.children) {
          // Filter children recursively
          const filteredChildren = node.children.filter(child => !child.fileData?.excludedByDefault);
          
          // Only keep directories that have non-excluded children after filtering
          if (filteredChildren.length === 0) {
            return false; // Skip empty directories after filtering
          }
          
          // Update the node's children to only include non-excluded items
          node.children = filterTree(filteredChildren, "");
        }
        
        return true;
      });
    }

    const lowerTerm = term.toLowerCase();

    // Function to check if a node or any of its children match the search
    const nodeMatches = (node: TreeNode): boolean => {
      // Always exclude files/folders marked as excludedByDefault
      if (node.fileData?.excludedByDefault) {
        return false;
      }
      
      // Check if the node name matches
      if (node.name.toLowerCase().includes(lowerTerm)) return true;

      // If it's a file, we're done
      if (node.type === "file") return false;

      // For directories, check if any children match
      if (node.children) {
        return node.children.some(nodeMatches);
      }

      return false;
    };

    // Filter the nodes
    return nodes.filter(nodeMatches).map((node) => {
      // If it's a directory, also filter its children
      if (node.type === "directory" && node.children) {
        return {
          ...node,
          children: filterTree(node.children, term),
          isExpanded: true, // Auto-expand directories when searching
        };
      }
      return node;
    });
  };

  // The final tree to render, filtered and flattened
  const visibleTree = flattenTree(filterTree(fileTree, searchTerm));

  return (
    <div className="sidebar" style={{ width: `${sidebarWidth}px` }}>
      <div className="sidebar-header">
        <div className="sidebar-title">Files</div>
        <div className="sidebar-folder-path">{selectedFolder}</div>
      </div>

      <div className="sidebar-search">
        <SearchBar
          searchTerm={searchTerm}
          onSearchChange={onSearchChange}
          placeholder="Search files..."
        />
      </div>

      <div className="sidebar-actions">
        <button className="sidebar-action-btn" onClick={selectAllFiles}>
          Select All
        </button>
        <button className="sidebar-action-btn" onClick={deselectAllFiles}>
          Deselect All
        </button>
      </div>

      {allFiles.length > 0 ? (
        isTreeBuildingComplete ? (
          <div className="file-tree">
            {visibleTree.length > 0 ? (
              visibleTree.map((node) => (
                <TreeItem
                  key={node.id}
                  node={node}
                  selectedFiles={selectedFiles}
                  toggleFileSelection={toggleFileSelection}
                  toggleFolderSelection={toggleFolderSelection}
                  toggleExpanded={toggleExpanded}
                  allFiles={allFiles}
                />
              ))
            ) : (
              <div className="tree-empty">No files match your search.</div>
            )}
          </div>
        ) : (
          <div className="tree-loading">
            <div className="spinner"></div>
            <span>Building file tree...</span>
          </div>
        )
      ) : (
        <div className="tree-empty">No files found in this folder.</div>
      )}

      <div
        className="sidebar-resize-handle"
        onMouseDown={handleResizeStart}
        title="Drag to resize sidebar"
      ></div>
    </div>
  );
};

export default Sidebar;
</file>

<file path="src/components/TreeItem.tsx">
import React, {
  useRef,
  useEffect,
} from "react";
import { TreeItemProps, TreeNode, FileData } from "../types/FileTypes";
import { ChevronRight, File, Folder } from "lucide-react";
import { arePathsEqual, normalizePath, isSubPath } from "../utils/pathUtils";

/**
 * TreeItem represents a single item (file or folder) in the file tree.
 * It handles:
 * - File/folder selection with checkboxes
 * - Folder expansion/collapse
 * - Visual indicators for selection state
 * - Special cases for binary/skipped/excluded files
 */
const TreeItem = ({
  node,
  selectedFiles,
  toggleFileSelection,
  toggleFolderSelection,
  toggleExpanded,
  allFiles
}: TreeItemProps) => {
  const { id, name, path, type, level, isExpanded, fileData } = node;
  const checkboxRef = useRef(null);

  const isSelected = type === "file" && selectedFiles.some((selectedPath) => 
    arePathsEqual(selectedPath, path)
  );

  const isDirectorySelected = (item: FileData, selectedFiles: string[], allFiles: FileData[]): boolean => {
    // If no files are selected, return false
    if (selectedFiles.length === 0) {
      return false;
    }

    // For all folders, get all files in this folder and subfolders
    const allSelectableFiles = getAllFilesInFolder(item, allFiles);
    
    // If there are no selectable files, it can't be selected
    if (allSelectableFiles.length === 0) {
      return false;
    }
    
    // Check if all eligible files are selected
    return allSelectableFiles.every(file => selectedFiles.includes(file.path));
  };

  // Returns all files (not directories) in this folder and subfolders that are selectable
  const getAllFilesInFolder = (item: FileData, allFiles: FileData[]): FileData[] => {
    const itemPath = normalizePath(item.path);
    
    return allFiles.filter(file => {
      // Skip directories, binary files, etc.
      if (file.isDirectory || file.isBinary || file.isSkipped || file.excludedByDefault) {
        return false;
      }
      
      const filePath = normalizePath(file.path);
      
      // Check if this file is in the folder or its subfolders
      return arePathsEqual(filePath, itemPath) || isSubPath(itemPath, filePath);
    });
  };

  // Returns only direct child files (not directories) that are selectable
  // This function is no longer used as we now use getAllFilesInFolder for all selection operations
  const isDirectoryPartiallySelected = (item: FileData, selectedFiles: string[], allFiles: FileData[]): boolean => {
    // If no files are selected, return false
    if (selectedFiles.length === 0) {
      return false;
    }
    
    // For all folders, get all files in this folder and subfolders
    const allSelectableFiles = getAllFilesInFolder(item, allFiles);
    
    // If no selectable files, it can't be partially selected
    if (allSelectableFiles.length === 0) {
      return false;
    }
    
    // Check if any of the files are selected but not all of them
    const someSelected = allSelectableFiles.some(file => selectedFiles.includes(file.path));
    const allSelected = allSelectableFiles.every(file => selectedFiles.includes(file.path));
    
    return someSelected && !allSelected;
  };

  // Update the indeterminate state manually whenever it changes
  useEffect(() => {
    if (checkboxRef.current && fileData) {
      checkboxRef.current.indeterminate = isDirectoryPartiallySelected(fileData, selectedFiles, allFiles);
    }
  }, [fileData, selectedFiles, allFiles]);

  const handleToggle = (e: any) => {
    e.stopPropagation();
    toggleExpanded(id);
  };

  const handleItemClick = (e: any) => {
    if (type === "directory") {
      toggleExpanded(id);
    } else if (type === "file" && !isDisabled) {
      toggleFileSelection(path);
    }
  };

  const handleCheckboxChange = (e: any) => {
    e.stopPropagation();
    if (type === "file") {
      toggleFileSelection(path);
    } else if (type === "directory") {
      // Use toggleFolderSelection for all folders
      toggleFolderSelection(path, e.target.checked);
    }
  };

  // Check if file is binary or otherwise unselectable
  const isDisabled = fileData ? fileData.isBinary || fileData.isSkipped : false;

  // Check if the file is excluded by default (but still selectable)
  const isExcludedByDefault = fileData?.excludedByDefault || false;

  return (
    <div
      className={`tree-item ${isSelected ? "selected" : ""} ${
        isExcludedByDefault ? "excluded-by-default" : ""
      }`}
      style={{ marginLeft: `${level * 16}px` }}
      onClick={handleItemClick}
    >
      {/* Expand/collapse arrow for directories */}
      {type === "directory" && (
        <div
          className={`tree-item-toggle ${isExpanded ? "expanded" : ""}`}
          onClick={handleToggle}
          aria-label={isExpanded ? "Collapse folder" : "Expand folder"}
        >
          <ChevronRight size={16} />
        </div>
      )}

      {/* Spacing for files to align with directories */}
      {type === "file" && <div className="tree-item-indent"></div>}

      {/* Selection checkbox */}
      <input
        type="checkbox"
        className="tree-item-checkbox"
        checked={type === "file" ? isSelected : (fileData ? isDirectorySelected(fileData, selectedFiles, allFiles) : false)}
        ref={checkboxRef}
        onChange={handleCheckboxChange}
        disabled={isDisabled}
        onClick={(e) => e.stopPropagation()}
      />

      {/* Item content (icon, name, and metadata) */}
      <div className="tree-item-content">
        <div className="tree-item-icon">
          {type === "directory" ? <Folder size={16} /> : <File size={16} />}
        </div>

        <div className="tree-item-name">{name}</div>

        {/* Show token count for files that have it */}
        {fileData && fileData.tokenCount > 0 && (
          <span className="tree-item-tokens">
            (~{fileData.tokenCount.toLocaleString()})
          </span>
        )}

        {/* Show badge for unselectable files */}
        {isDisabled && fileData && (
          <span className="tree-item-badge">
            {fileData.isBinary ? "Binary" : "Skipped"}
          </span>
        )}

        {!isDisabled && isExcludedByDefault && (
          <span className="tree-item-badge excluded">Excluded</span>
        )}
      </div>
    </div>
  );
};

export default TreeItem;
</file>

<file path="main.js">
const { app, BrowserWindow, ipcMain, dialog, globalShortcut } = require("electron");
const fs = require("fs");
const path = require("path");
const os = require("os");
const crypto = require("crypto"); // Added for CSP nonce generation

// Global variables for directory loading control
let isLoadingDirectory = false;
let loadingTimeoutId = null;
const MAX_DIRECTORY_LOAD_TIME = 60000; // 60 seconds timeout

/**
 * Enhanced path handling functions for cross-platform compatibility
 */

/**
 * Normalize file paths to use forward slashes regardless of OS
 * This ensures consistent path formatting between main and renderer processes
 * Also handles UNC paths on Windows
 */
function normalizePath(filePath) {
  if (!filePath) return filePath;

  // Handle Windows UNC paths
  if (process.platform === 'win32' && filePath.startsWith('\\\\')) {
    // Preserve the UNC path format but normalize separators
    return '\\\\' + filePath.slice(2).replace(/\\/g, '/');
  }

  return filePath.replace(/\\/g, '/');
}

/**
 * Get the platform-specific path separator
 */
function getPathSeparator() {
  return path.sep;
}

/**
 * Ensures a path is absolute and normalized for the current platform
 * @param {string} inputPath - The path to normalize
 * @returns {string} - Normalized absolute path
 */
function ensureAbsolutePath(inputPath) {
  if (!path.isAbsolute(inputPath)) {
    inputPath = path.resolve(inputPath);
  }
  return normalizePath(inputPath);
}

/**
 * Safely joins paths across different platforms
 * @param {...string} paths - Path segments to join
 * @returns {string} - Normalized joined path
 */
function safePathJoin(...paths) {
  const joined = path.join(...paths);
  return normalizePath(joined);
}

/**
 * Safely calculates relative path between two paths
 * Handles different OS path formats and edge cases
 * @param {string} from - Base path
 * @param {string} to - Target path
 * @returns {string} - Normalized relative path
 */
function safeRelativePath(from, to) {
  // Normalize both paths to use the same separator format
  from = normalizePath(from);
  to = normalizePath(to);
  
  // Handle Windows drive letter case-insensitivity
  if (process.platform === 'win32') {
    from = from.toLowerCase();
    to = to.toLowerCase();
  }
  
  let relativePath = path.relative(from, to);
  return normalizePath(relativePath);
}

/**
 * Checks if a path is a valid path for the current OS
 * @param {string} pathToCheck - Path to validate
 * @returns {boolean} - True if path is valid
 */
function isValidPath(pathToCheck) {
  try {
    path.parse(pathToCheck);
    return true;
  } catch (err) {
    return false;
  }
}

// Add handling for the 'ignore' module
let ignore;
try {
  ignore = require("ignore");
  console.log("Successfully loaded ignore module");
} catch (err) {
  console.error("Failed to load ignore module:", err);
  // Simple fallback implementation for when the ignore module fails to load
  ignore = {
    // Simple implementation that just matches exact paths
    createFilter: () => {
      return (path) => !excludedFiles.includes(path);
    },
  };
  console.log("Using fallback for ignore module");
}

// Initialize tokenizer with better error handling
let tiktoken;
try {
  tiktoken = require("tiktoken");
  console.log("Successfully loaded tiktoken module");
} catch (err) {
  console.error("Failed to load tiktoken module:", err);
  tiktoken = null;
}

// Import the excluded files list
const { excludedFiles, binaryExtensions } = require("./excluded-files");

// Initialize the encoder once at startup with better error handling
let encoder;
try {
  if (tiktoken) {
    encoder = tiktoken.get_encoding("o200k_base"); // gpt-4o encoding
    console.log("Tiktoken encoder initialized successfully");
  } else {
    throw new Error("Tiktoken module not available");
  }
} catch (err) {
  console.error("Failed to initialize tiktoken encoder:", err);
  // Fallback to a simpler method if tiktoken fails
  console.log("Using fallback token counter");
  encoder = null;
}

// Binary file extensions that should be excluded from token counting
const BINARY_EXTENSIONS = [
  // Images
  ".jpg",
  ".jpeg",
  ".png",
  ".gif",
  ".bmp",
  ".tiff",
  ".ico",
  ".icns",
  ".webp",
  ".svg",
  ".heic",
  ".heif",
  ".pdf",
  ".psd",
  // Audio/Video
  ".mp3",
  ".mp4",
  ".wav",
  ".ogg",
  ".avi",
  ".mov",
  ".mkv",
  ".flac",
  // Archives
  ".zip",
  ".rar",
  ".tar",
  ".gz",
  ".7z",
  // Documents
  ".pdf",
  ".doc",
  ".docx",
  ".ppt",
  ".pptx",
  ".xls",
  ".xlsx",
  // Compiled
  ".exe",
  ".dll",
  ".so",
  ".class",
  ".o",
  ".pyc",
  // Database
  ".db",
  ".sqlite",
  ".sqlite3",
  // Others
  ".bin",
  ".dat",
].concat(binaryExtensions || []); // Add any additional binary extensions from excluded-files.js

// Max file size to read (5MB)
const MAX_FILE_SIZE = 5 * 1024 * 1024;

function createWindow() {
  // Check if we're starting in safe mode (Shift key pressed)
  const isSafeMode = process.argv.includes('--safe-mode');
  const isDev = process.env.NODE_ENV === "development";
  
  // In development, suppress Electron security warnings about CSP
  // This is only for development since we need 'unsafe-eval' for Vite HMR
  if (isDev) {
    process.env.ELECTRON_DISABLE_SECURITY_WARNINGS = 'true';
    console.log("Development mode: Security warnings about CSP are suppressed");
  } else {
    // Production security enhancements
    console.log("Production mode: Applying strict security settings");
  }
  
  const mainWindow = new BrowserWindow({
    width: 1200,
    height: 800,
    webPreferences: {
      nodeIntegration: false,
      contextIsolation: true,
      preload: path.join(__dirname, "preload.js"),
      // Production security settings
      sandbox: !isDev, // Enable sandbox in production for better security
      devTools: isDev, // Only enable DevTools in development
      webSecurity: true, // Enforce web security
      additionalArguments: [`--app-path=${app.getAppPath()}`], // Pass app path for better cross-platform file resolution
    },
  });

  // Set proper Content-Security-Policy
  // This helps prevent the Insecure Content-Security-Policy warning
  mainWindow.webContents.session.webRequest.onHeadersReceived((details, callback) => {
    // Generate a random nonce for CSP
    const nonce = Buffer.from(crypto.randomBytes(16)).toString('base64');
    
    // Different CSP for development and production
    const isDev = process.env.NODE_ENV === "development";
    
    // Only log CSP once for main documents
    if (details.resourceType === 'mainFrame') {
      if (isDev) {
        console.log("Using development CSP with 'unsafe-eval' for Vite HMR");
      } else {
        console.log("Using production CSP with nonce-based script-src");
      }
    }
    
    let cspValue;
    if (isDev) {
      // Development policy that works with Vite's HMR
      // 'unsafe-eval' is required for Vite HMR in development mode only
      cspValue = [
        "default-src 'self';" +
        "script-src 'self' 'unsafe-inline' 'unsafe-eval';" +
        "style-src 'self' 'unsafe-inline' https://fonts.googleapis.com;" +
        "font-src 'self' data: https://fonts.gstatic.com;" +
        "connect-src 'self' ws: wss: http://localhost:* https://localhost:*;" +
        "img-src 'self' data:;"
      ];
    } else {
      // Secure policy for production with nonce-based script-src
      cspValue = [
        "default-src 'self';" +
        `script-src 'self' 'nonce-${nonce}';` +
        "style-src 'self' 'unsafe-inline';" + // 'unsafe-inline' needed for most CSS frameworks
        "font-src 'self' data:;" +
        "connect-src 'self';" +
        "img-src 'self' data:;" +
        "object-src 'none';" + // Prevent object/embed tags
        "base-uri 'self';" + // Restrict base URIs
        "form-action 'self';" + // Restrict form submissions
        "frame-ancestors 'self';" + // Control embedding 
        "upgrade-insecure-requests;" // Upgrade HTTP to HTTPS
      ];
    }
    
    callback({
      responseHeaders: {
        ...details.responseHeaders,
        'Content-Security-Policy': cspValue,
        'X-Content-Type-Options': ['nosniff'],
        'X-XSS-Protection': ['1; mode=block'],
        'X-Frame-Options': ['SAMEORIGIN']
      }
    });
  });

  // Pass the safe mode flag to the renderer
  mainWindow.webContents.once('did-finish-load', () => {
    mainWindow.webContents.send('startup-mode', { 
      safeMode: isSafeMode 
    });
  });

  // Register the escape key to cancel directory loading
  globalShortcut.register('Escape', () => {
    if (isLoadingDirectory) {
      cancelDirectoryLoading(mainWindow);
    }
  });

  // Clean up shortcuts when window is closed
  mainWindow.on('closed', () => {
    globalShortcut.unregisterAll();
  });

  // In development, load from Vite dev server
  // In production, load from built files
  if (process.env.NODE_ENV === "development") {
    // Use the URL provided by the dev script, or fall back to Vite's default port
    const startUrl = process.env.ELECTRON_START_URL || "http://localhost:5173";
    // Wait a moment for dev server to be ready (increased timeout)
    setTimeout(() => {
      // Clear any cached data to prevent redirection loops
      mainWindow.webContents.session.clearCache().then(() => {
        // Set development-specific webPreferences before loading URL
        mainWindow.webContents.setWindowOpenHandler(({ url }) => {
          // Open external links in browser, internal links in the app
          if (url.startsWith('http')) {
            return { action: 'allow' };
          }
          return { action: 'deny' };
        });
        
        mainWindow.loadURL(startUrl);
        // Open DevTools in development mode with options to reduce warnings
        if (mainWindow.webContents.isDevToolsOpened()) {
          mainWindow.webContents.closeDevTools();
        }
        // Open DevTools in the same window instead of detached
        mainWindow.webContents.openDevTools();
        console.log(`Loading from dev server at ${startUrl}`);
      });
    }, 2000);
  } else {
    const indexPath = path.join(__dirname, "dist", "index.html");
    console.log(`Loading from built files at ${indexPath}`);

    // Use loadURL with file protocol for better path resolution
    const indexUrl = `file://${indexPath}`;
    mainWindow.loadURL(indexUrl);
  }

  // Add basic error handling for failed loads
  mainWindow.webContents.on(
    "did-fail-load",
    (event, errorCode, errorDescription, validatedURL) => {
      console.error(
        `Failed to load the application: ${errorDescription} (${errorCode})`,
      );
      console.error(`Attempted to load URL: ${validatedURL}`);

      if (process.env.NODE_ENV === "development") {
        const retryUrl =
          process.env.ELECTRON_START_URL || "http://localhost:5173";
        // Clear cache before retrying
        mainWindow.webContents.session.clearCache().then(() => {
          setTimeout(() => mainWindow.loadURL(retryUrl), 2000);
        });
      } else {
        // Retry with explicit file URL
        const indexPath = path.join(__dirname, "dist", "index.html");
        const indexUrl = `file://${indexPath}`;
        mainWindow.loadURL(indexUrl);
      }
    },
  );
}

app.whenReady().then(() => {
  // Set secure app-wide defaults for production
  const isDev = process.env.NODE_ENV === "development";
  
  if (!isDev) {
    // Production security settings
    
    // Prevent navigation to non-local content
    app.on('web-contents-created', (event, contents) => {
      contents.on('will-navigate', (event, navigationUrl) => {
        const parsedUrl = new URL(navigationUrl);
        // Only allow navigation to local content
        if (!parsedUrl.protocol.includes('file:')) {
          console.log('Blocked navigation to:', navigationUrl);
          event.preventDefault();
        }
      });
      
      // Block new window creation to external URLs
      contents.setWindowOpenHandler(({ url }) => {
        // Only allow opening windows for internal pages
        if (url.startsWith('file:')) {
          return { action: 'allow' };
        }
        // Open external URLs in the default browser instead
        if (url.startsWith('https:')) {
          setImmediate(() => {
            console.log('Opening in browser:', url);
            require('electron').shell.openExternal(url);
          });
        }
        return { action: 'deny' };
      });
    });
  }
  
  createWindow();

  app.on("activate", () => {
    if (BrowserWindow.getAllWindows().length === 0) createWindow();
  });
});

app.on("window-all-closed", () => {
  if (process.platform !== "darwin") {
    app.quit();
  }
});

// Handle folder selection
ipcMain.on("open-folder", async (event) => {
  const result = await dialog.showOpenDialog({
    properties: ["openDirectory"],
  });

  if (!result.canceled && result.filePaths && result.filePaths.length > 0) {
    const selectedPath = result.filePaths[0];
    try {
      // Ensure we're only sending a string, not an object
      const pathString = String(selectedPath);
      console.log("Sending folder-selected event with path:", pathString);
      event.sender.send("folder-selected", pathString);
    } catch (err) {
      console.error("Error sending folder-selected event:", err);
      // Try a more direct approach as a fallback
      event.sender.send("folder-selected", String(selectedPath));
    }
  }
});

/**
 * Parse .gitignore file if it exists and create an ignore filter
 * Handles path normalization for cross-platform compatibility
 * 
 * @param {string} rootDir - The root directory containing .gitignore
 * @returns {object} - Configured ignore filter
 */
function loadGitignore(rootDir) {
  // Create a default ignore filter
  let ig;
  
  try {
    ig = ignore();
  } catch (err) {
    console.error("Error creating ignore filter:", err);
    // Return a simple fallback filter that doesn't ignore anything
    return {
      ignores: (path) => {
        console.log("Using fallback ignore filter for:", path);
        return false;
      }
    };
  }
  
  try {
    // Ensure root directory path is absolute and normalized
    rootDir = ensureAbsolutePath(rootDir);
    const gitignorePath = safePathJoin(rootDir, ".gitignore");

    if (fs.existsSync(gitignorePath)) {
      try {
        const gitignoreContent = fs.readFileSync(gitignorePath, "utf8");
        // Split content into lines and normalize path separators
        const normalizedPatterns = gitignoreContent
          .split(/\r?\n/)
          .map(pattern => pattern.trim())
          .filter(pattern => pattern && !pattern.startsWith('#'))
          .map(pattern => normalizePath(pattern));

        ig.add(normalizedPatterns);
      } catch (err) {
        console.error("Error reading .gitignore:", err);
      }
    }

    // Add some default ignores that are common
    ig.add([
      ".git",
      "node_modules",
      ".DS_Store",
      // Add Windows-specific files to ignore
      "Thumbs.db",
      "desktop.ini",
      // Add common IDE files
      ".idea",
      ".vscode",
      // Add common build directories
      "dist",
      "build",
      "out"
    ]);

    // Normalize and add the excludedFiles patterns
    if (Array.isArray(excludedFiles)) {
      const normalizedExcludedFiles = excludedFiles.map(pattern => normalizePath(pattern));
      ig.add(normalizedExcludedFiles);
    } else {
      console.warn("excludedFiles is not an array, skipping");
    }
  } catch (err) {
    console.error("Error configuring ignore filter:", err);
  }

  // Wrap the ignores function to handle errors
  const originalIgnores = ig.ignores;
  ig.ignores = (path) => {
    if (!path || typeof path !== 'string' || path.trim() === '') {
      console.warn("Ignores called with invalid path:", path);
      return false;
    }
    
    try {
      return originalIgnores.call(ig, path);
    } catch (err) {
      console.error(`Error in ignores for path '${path}':`, err);
      return false;
    }
  };

  return ig;
}

// Check if file is binary based on extension
function isBinaryFile(filePath) {
  const ext = path.extname(filePath).toLowerCase();
  return BINARY_EXTENSIONS.includes(ext);
}

// Count tokens using tiktoken with o200k_base encoding
function countTokens(text) {
  // Simple fallback implementation if encoder fails
  if (!encoder) {
    return Math.ceil(text.length / 4);
  }

  try {
    // Remove any special tokens that might cause issues
    const cleanText = text.replace(/<\|endoftext\|>/g, '');
    const tokens = encoder.encode(cleanText);
    return tokens.length;
  } catch (err) {
    console.error("Error counting tokens:", err);
    // Fallback to character-based estimation on error
    return Math.ceil(text.length / 4);
  }
}

/**
 * Recursively reads files from a directory with chunked processing and cancellation support.
 * Implements several performance and safety features:
 * - Processes files in small chunks to maintain UI responsiveness
 * - Supports immediate cancellation at any point
 * - Handles binary files and large files appropriately
 * - Respects .gitignore and custom exclusion patterns
 * - Provides progress updates to the UI
 * - Handles cross-platform path issues including UNC paths
 *
 * @param {string} dir - The directory to process
 * @param {string} rootDir - The root directory (used for relative path calculations)
 * @param {object} ignoreFilter - The ignore filter instance for file exclusions
 * @param {BrowserWindow} window - The Electron window instance for sending updates
 * @returns {Promise<Array>} Array of processed file objects
 */
async function readFilesRecursively(dir, rootDir, ignoreFilter, window, isRoot = false) {
  if (!isLoadingDirectory) return [];
  
  // Ensure absolute and normalized paths
  dir = ensureAbsolutePath(dir);
  rootDir = ensureAbsolutePath(rootDir || dir);
  ignoreFilter = ignoreFilter || loadGitignore(rootDir);

  let results = [];
  let processedFiles = 0;
  const CHUNK_SIZE = 20;

  // Add root folder if this is the top-level call
  if (isRoot) {
    try {
      const stats = await fs.promises.stat(dir);
      const rootName = basename(dir); // Get the folder name, not the full path
      
      const rootEntry = {
        name: rootName,
        path: normalizePath(dir),
        content: "",
        tokenCount: 0,
        size: stats.size,
        isBinary: false,
        isSkipped: false,
        isDirectory: true,
        relativePath: ""
      };
      
      console.log("Added root folder to file list:", rootEntry.name, rootEntry.path);
      results.push(rootEntry);
    } catch (err) {
      console.error("Error adding root folder:", err);
    }
  }

  try {
    const dirents = await fs.promises.readdir(dir, { withFileTypes: true });
    if (!isLoadingDirectory) return results;

    const directories = dirents.filter(dirent => dirent.isDirectory());
    const files = dirents.filter(dirent => dirent.isFile());

    // Process directories first
    for (const dirent of directories) {
      if (!isLoadingDirectory) return results;

      const fullPath = safePathJoin(dir, dirent.name);
      // Calculate relative path safely
      const relativePath = safeRelativePath(rootDir, fullPath);

      // Skip PasteMax app directories and invalid paths
      if (fullPath.includes('.app') || fullPath === app.getAppPath() || 
          !isValidPath(relativePath) || relativePath.startsWith('..')) {
        console.log('Skipping directory:', fullPath);
        continue;
      }

      // Add the directory itself to the results
      try {
        const dirStats = await fs.promises.stat(fullPath);
        results.push({
          name: dirent.name,
          path: normalizePath(fullPath),
          relativePath: relativePath,
          tokenCount: 0,
          size: dirStats.size || 0,
          content: "",
          isBinary: false,
          isSkipped: false,
          isDirectory: true,
          error: null
        });
      } catch (dirErr) {
        console.error(`Error adding directory ${fullPath}:`, dirErr);
        // Still add the directory entry with default values if we can't stat it
        results.push({
          name: dirent.name,
          path: normalizePath(fullPath),
          relativePath: relativePath,
          tokenCount: 0,
          size: 0,
          content: "",
          isBinary: false,
          isSkipped: false,
          isDirectory: true,
          error: `Error reading directory: ${dirErr.message}`
        });
      }

      // Only process if not ignored
      try {
        // Safely check if directory should be ignored
        if (ignoreFilter && typeof ignoreFilter.ignores === 'function' && 
            relativePath && relativePath.trim() !== '' && 
            !ignoreFilter.ignores(relativePath)) {
          const subResults = await readFilesRecursively(fullPath, rootDir, ignoreFilter, window, false);
          if (!isLoadingDirectory) return results;
          if (Array.isArray(subResults)) {
            results = results.concat(subResults);
          } else {
            console.warn(`Non-array result from recursive call for ${fullPath}:`, subResults);
          }
        }
      } catch (subDirErr) {
        console.error(`Error processing subdirectory ${fullPath}:`, subDirErr);
      }

      window.webContents.send("file-processing-status", {
        status: "processing",
        message: `Scanning directories... (Press ESC to cancel)`,
      });
    }

    // Process files in chunks
    for (let i = 0; i < files.length; i += CHUNK_SIZE) {
      if (!isLoadingDirectory) return results;

      const chunk = files.slice(i, i + CHUNK_SIZE);
      
      const chunkPromises = chunk.map(async (dirent) => {
        if (!isLoadingDirectory) return null;

        const fullPath = safePathJoin(dir, dirent.name);
        // Calculate relative path safely
        const relativePath = safeRelativePath(rootDir, fullPath);

        // Skip PasteMax app files and invalid paths
        if (fullPath.includes('.app') || fullPath === app.getAppPath() || 
            !isValidPath(relativePath) || relativePath.startsWith('..')) {
          console.log('Skipping file:', fullPath);
          return null;
        }

        // Early check for binary files
        if (isBinaryFile(fullPath)) {
          console.log(`Skipping binary file: ${relativePath}`);
          return null; // Skip binary files completely - don't even add them to results
        }

        // Safely check if file should be ignored
        try {
          if (ignoreFilter && typeof ignoreFilter.ignores === 'function' && 
              relativePath && relativePath.trim() !== '' && 
              ignoreFilter.ignores(relativePath)) {
            console.log(`Skipping ignored file: ${relativePath}`);
            return null; // Skip ignored files completely
          }
        } catch (ignoreErr) {
          console.error(`Error in ignore filter for ${fullPath}:`, ignoreErr);
        }

        try {
          const stats = await fs.promises.stat(fullPath);
          if (!isLoadingDirectory) return null;
          
          if (stats.size > MAX_FILE_SIZE) {
            return {
              name: dirent.name,
              path: normalizePath(fullPath),
              relativePath: relativePath,
              tokenCount: 0,
              size: stats.size,
              content: "",
              isBinary: false,
              isSkipped: true,
              isDirectory: false,
              error: "File too large to process"
            };
          }

          if (isBinaryFile(fullPath)) {
            return {
              name: dirent.name,
              path: normalizePath(fullPath),
              relativePath: relativePath,
              tokenCount: 0,
              size: stats.size,
              content: "",
              isBinary: true,
              isSkipped: false,
              isDirectory: false,
              fileType: path.extname(fullPath).substring(1).toUpperCase()
            };
          }

          const fileContent = await fs.promises.readFile(fullPath, "utf8");
          if (!isLoadingDirectory) return null;
          
          return {
            name: dirent.name,
            path: normalizePath(fullPath),
            relativePath: relativePath,
            content: fileContent,
            tokenCount: countTokens(fileContent),
            size: stats.size,
            isBinary: false,
            isSkipped: false,
            isDirectory: false
          };
        } catch (err) {
          console.error(`Error reading file ${fullPath}:`, err);
          return {
            name: dirent.name,
            path: normalizePath(fullPath),
            relativePath: relativePath,
            tokenCount: 0,
            size: 0,
            isBinary: false,
            isSkipped: true,
            isDirectory: false,
            error: err.code === 'EPERM' ? "Permission denied" : 
                   err.code === 'ENOENT' ? "File not found" : 
                   "Could not read file"
          };
        }
      });

      const chunkResults = await Promise.all(chunkPromises);
      if (!isLoadingDirectory) return results;
      
      results = results.concat(chunkResults.filter(result => result !== null));
      processedFiles += chunk.length;
      
      window.webContents.send("file-processing-status", {
        status: "processing",
        message: `Processing files... ${processedFiles}/${files.length} (Press ESC to cancel)`,
      });
    }
  } catch (err) {
    console.error(`Error reading directory ${dir}:`, err);
    if (err.code === 'EPERM' || err.code === 'EACCES') {
      console.log(`Skipping inaccessible directory: ${dir}`);
      return results;
    }
  }

  return results;
}

// Helper function to get basename
function basename(path) {
  if (!path) return "";
  const normalizedPath = normalizePath(path);
  const parts = normalizedPath.split('/');
  // Get the last non-empty part
  for (let i = parts.length - 1; i >= 0; i--) {
    if (parts[i]) return parts[i];
  }
  return "";
}

// Handle file list request
ipcMain.on("request-file-list", async (event, folderPath) => {
  try {
    console.log("Processing file list for folder:", folderPath);
    console.log("OS platform:", os.platform());
    console.log("Path separator:", getPathSeparator());

    // Set the loading flag to true
    isLoadingDirectory = true;
    
    // Get the current BrowserWindow
    const window = BrowserWindow.fromWebContents(event.sender);
    
    // Set up a safety timeout
    setupDirectoryLoadingTimeout(window, folderPath);

    // Send initial progress update
    event.sender.send("file-processing-status", {
      status: "processing",
      message: "Scanning directory structure...",
    });

    // Process files in a way that can be properly awaited
    const processFiles = async () => {
      try {
        console.log("Starting directory scan, isLoadingDirectory =", isLoadingDirectory);
        
        // Await the result of readFilesRecursively
        const files = await readFilesRecursively(folderPath, folderPath, null, window, true);
        console.log(`Found ${files ? files.length : 0} files in ${folderPath}`);

        if (!files || !Array.isArray(files)) {
          console.error("Error: readFilesRecursively did not return an array");
          event.sender.send("file-processing-status", {
            status: "error",
            message: "Error: Failed to process directory structure",
          });
          return;
        }

        // Update with processing complete status
        event.sender.send("file-processing-status", {
          status: "complete",
          message: `Found ${files.length} files`,
        });

        // Process the files to ensure they're serializable
        const serializableFiles = files.map((file) => {
          // Normalize the path to use forward slashes consistently
          const normalizedPath = normalizePath(file.path);
          
          // Create a clean file object
          return {
            name: file.name ? String(file.name) : "",
            path: normalizedPath, // Use normalized path
            tokenCount: typeof file.tokenCount === "number" ? file.tokenCount : 0,
            size: typeof file.size === "number" ? file.size : 0,
            content: file.isBinary || file.isDirectory
              ? ""
              : typeof file.content === "string"
              ? file.content
              : "",
            isBinary: Boolean(file.isBinary),
            isSkipped: Boolean(file.isSkipped),
            error: file.error ? String(file.error) : null,
            fileType: file.fileType ? String(file.fileType) : null,
            excludedByDefault: shouldExcludeByDefault(normalizedPath, normalizePath(folderPath)), // Also normalize folder path
            isDirectory: Boolean(file.isDirectory)
          };
        });

        try {
          console.log(`Sending ${serializableFiles.length} files to renderer`);
          // Log a sample of paths to check normalization
          if (serializableFiles.length > 0) {
            console.log("Sample file paths (first 3):");
            serializableFiles.slice(0, 3).forEach(file => {
              console.log(`- Name: ${file.name}, Path: ${file.path}, isDirectory: ${file.isDirectory}`);
            });

            // Log some directory entries specifically
            const directoryEntries = serializableFiles.filter(file => file.isDirectory);
            console.log(`Found ${directoryEntries.length} directory entries`);
            if (directoryEntries.length > 0) {
              console.log("Sample directory entries (first 3):");
              directoryEntries.slice(0, 3).forEach(dir => {
                console.log(`- Name: ${dir.name}, Path: ${dir.path}, isDirectory: ${dir.isDirectory}`);
              });
            }
          }
          
          event.sender.send("file-list-data", serializableFiles);
        } catch (sendErr) {
          console.error("Error sending file data:", sendErr);

          // If sending fails, try again with minimal data
          const minimalFiles = serializableFiles.map((file) => ({
            name: file.name,
            path: file.path,
            tokenCount: file.tokenCount,
            size: file.size,
            isBinary: file.isBinary,
            isSkipped: file.isSkipped,
            excludedByDefault: file.excludedByDefault,
            isDirectory: file.isDirectory
          }));

          event.sender.send("file-list-data", minimalFiles);
        }
      } finally {
        // Clear the loading flag when done
        isLoadingDirectory = false;
        if (loadingTimeoutId) {
          clearTimeout(loadingTimeoutId);
          loadingTimeoutId = null;
        }
      }
    };

    // Use setTimeout to allow UI to update before processing starts
    setTimeout(() => processFiles(), 100);
  } catch (err) {
    console.error("Error processing file list:", err);
    isLoadingDirectory = false;
    event.sender.send("file-processing-status", {
      status: "error",
      message: `Error: ${err.message}`,
    });
  }
});

// Check if a file should be excluded by default, using glob matching
function shouldExcludeByDefault(filePath, rootDir) {
  // Handle empty paths to prevent errors
  if (!filePath || !rootDir) {
    console.warn("shouldExcludeByDefault received empty path:", { filePath, rootDir });
    return false;
  }

  try {
    // Ensure both paths are normalized for consistent handling across platforms
    filePath = normalizePath(filePath);
    rootDir = normalizePath(rootDir);

    // Handle Windows drive letter case sensitivity
    if (process.platform === 'win32') {
      filePath = filePath.toLowerCase();
      rootDir = rootDir.toLowerCase();
    }

    // Use path.relative for proper cross-platform path handling
    const relativePath = path.relative(rootDir, filePath);
    const relativePathNormalized = normalizePath(relativePath);
    
    // Handle empty relative paths (root directory case)
    if (!relativePathNormalized || relativePathNormalized === '') {
      console.log("Root directory or empty path detected in shouldExcludeByDefault");
      return false; // Don't exclude the root directory itself
    }
    
    // Use the ignore package to do glob pattern matching
    try {
      const ig = ignore().add(excludedFiles);
      return ig.ignores(relativePathNormalized);
    } catch (ignoreError) {
      console.error("Error in ignore.ignores():", ignoreError);
      return false; // On ignore error, don't exclude the file
    }
  } catch (error) {
    console.error("Error in shouldExcludeByDefault:", error);
    return false; // On any error, don't exclude the file
  }
}

// Add a debug handler for file selection
ipcMain.on("debug-file-selection", (event, data) => {
  console.log("DEBUG - File Selection:", data);
});

/**
 * Handles the cancellation of directory loading operations.
 * Ensures clean cancellation by:
 * - Clearing all timeouts
 * - Resetting loading flags
 * - Notifying the UI immediately
 * 
 * @param {BrowserWindow} window - The Electron window instance to send updates to
 */
function cancelDirectoryLoading(window) {
  if (!isLoadingDirectory) return;
  
  console.log("Cancelling directory loading process immediately");
  isLoadingDirectory = false;
  
  if (loadingTimeoutId) {
    clearTimeout(loadingTimeoutId);
    loadingTimeoutId = null;
  }
  
  // Send cancellation message immediately
  window.webContents.send("file-processing-status", {
    status: "cancelled",
    message: "Directory loading cancelled",
  });
}

/**
 * Sets up a safety timeout for directory loading operations.
 * Prevents infinite loading by automatically cancelling after MAX_DIRECTORY_LOAD_TIME.
 * 
 * @param {BrowserWindow} window - The Electron window instance
 * @param {string} folderPath - The path being processed (for logging)
 */
function setupDirectoryLoadingTimeout(window, folderPath) {
  // Clear any existing timeout
  if (loadingTimeoutId) {
    clearTimeout(loadingTimeoutId);
  }
  
  // Set a new timeout
  loadingTimeoutId = setTimeout(() => {
    console.log(`Directory loading timed out after ${MAX_DIRECTORY_LOAD_TIME / 1000} seconds: ${folderPath}`);
    cancelDirectoryLoading(window);
  }, MAX_DIRECTORY_LOAD_TIME);
}
</file>

<file path="src/App.tsx">
import React, { useState, useEffect, useCallback } from "react";
import Sidebar from "./components/Sidebar";
import FileList from "./components/FileList";
import CopyButton from "./components/CopyButton";
import UserInstructions from "./components/UserInstructions";
import { FileData } from "./types/FileTypes";
import { ThemeProvider } from "./context/ThemeContext";
import ThemeToggle from "./components/ThemeToggle";

/**
 * Import path utilities for handling file paths across different operating systems.
 * While not all utilities are used directly, they're kept for consistency and future use.
 */
import { generateAsciiFileTree, normalizePath, arePathsEqual, isSubPath, join, basename } from "./utils/pathUtils";

// Access the electron API from the window object
declare global {
  interface Window {
    electron: {
      ipcRenderer: {
        send: (channel: string, data?: any) => void;
        on: (channel: string, func: (...args: any[]) => void) => void;
        removeListener: (
          channel: string,
          func: (...args: any[]) => void,
        ) => void;
      };
    };
  }
}

/**
 * Keys used for storing app state in localStorage.
 * Keeping them in one place makes them easier to manage and update.
 */
const STORAGE_KEYS = {
  SELECTED_FOLDER: "pastemax-selected-folder",
  SELECTED_FILES: "pastemax-selected-files",
  SORT_ORDER: "pastemax-sort-order",
  SEARCH_TERM: "pastemax-search-term",
  EXPANDED_NODES: "pastemax-expanded-nodes",
};

/**
 * The main App component that handles:
 * - File selection and management
 * - Folder navigation
 * - File content copying
 * - UI state management
 */
const App = (): JSX.Element => {
  // Clear saved folder on startup (temporary, for testing)
  useEffect(() => {
    localStorage.removeItem(STORAGE_KEYS.SELECTED_FOLDER);
    localStorage.removeItem("hasLoadedInitialData");
    sessionStorage.removeItem("hasLoadedInitialData");
  }, []);

  // Load initial state from localStorage if available
  const savedFolder = localStorage.getItem(STORAGE_KEYS.SELECTED_FOLDER);
  const savedFiles = localStorage.getItem(STORAGE_KEYS.SELECTED_FILES);
  const savedSortOrder = localStorage.getItem(STORAGE_KEYS.SORT_ORDER);
  const savedSearchTerm = localStorage.getItem(STORAGE_KEYS.SEARCH_TERM);

  const [selectedFolder, setSelectedFolder] = useState(
    savedFolder as string | null
  );
  const [allFiles, setAllFiles] = useState([] as FileData[]);
  const [selectedFiles, setSelectedFiles] = useState(
    savedFiles ? JSON.parse(savedFiles) : [] as string[]
  );
  const [sortOrder, setSortOrder] = useState(
    savedSortOrder || "tokens-desc"
  );
  const [searchTerm, setSearchTerm] = useState(savedSearchTerm || "");
  const [expandedNodes, setExpandedNodes] = useState(
    {} as Record<string, boolean>
  );
  const [displayedFiles, setDisplayedFiles] = useState([] as FileData[]);
  const [processingStatus, setProcessingStatus] = useState(
    { status: "idle", message: "" } as {
      status: "idle" | "processing" | "complete" | "error";
      message: string;
    }
  );
  const [includeFileTree, setIncludeFileTree] = useState(false);
  


  // State for sort dropdown
  const [sortDropdownOpen, setSortDropdownOpen] = useState(false);

  // Check if we're running in Electron or browser environment
  const isElectron = window.electron !== undefined;

  const [isSafeMode, setIsSafeMode] = useState(false);

  // Load expanded nodes state from localStorage
  useEffect(() => {
    const savedExpandedNodes = localStorage.getItem(
      STORAGE_KEYS.EXPANDED_NODES,
    );
    if (savedExpandedNodes) {
      try {
        setExpandedNodes(JSON.parse(savedExpandedNodes));
      } catch (error) {
        console.error("Error parsing saved expanded nodes:", error);
      }
    }
  }, []);

  // Persist selected folder when it changes
  useEffect(() => {
    if (selectedFolder) {
      localStorage.setItem(STORAGE_KEYS.SELECTED_FOLDER, selectedFolder);
    } else {
      localStorage.removeItem(STORAGE_KEYS.SELECTED_FOLDER);
    }
  }, [selectedFolder]);

  // Persist selected files when they change
  useEffect(() => {
    localStorage.setItem(
      STORAGE_KEYS.SELECTED_FILES,
      JSON.stringify(selectedFiles),
    );
  }, [selectedFiles]);

  // Persist sort order when it changes
  useEffect(() => {
    localStorage.setItem(STORAGE_KEYS.SORT_ORDER, sortOrder);
  }, [sortOrder]);

  // Persist search term when it changes
  useEffect(() => {
    localStorage.setItem(STORAGE_KEYS.SEARCH_TERM, searchTerm);
  }, [searchTerm]);

  // Add a function to cancel directory loading
  const cancelDirectoryLoading = useCallback(() => {
    if (isElectron) {
      window.electron.ipcRenderer.send("cancel-directory-loading");
      setProcessingStatus({
        status: "idle",
        message: "Directory loading cancelled",
      });
    }
  }, [isElectron]);

  // Add this new useEffect for safe mode detection
  useEffect(() => {
    if (!isElectron) return;
    
    const handleStartupMode = (mode: { safeMode: boolean }) => {
      setIsSafeMode(mode.safeMode);
    
      // If we're in safe mode, don't auto-load the previously selected folder
      if (mode.safeMode) {
        console.log("Starting in safe mode - not loading saved folder");
        localStorage.removeItem("hasLoadedInitialData");
        localStorage.removeItem(STORAGE_KEYS.SELECTED_FOLDER);
      }
    };
    
    window.electron.ipcRenderer.on("startup-mode", handleStartupMode);
    
    return () => {
      window.electron.ipcRenderer.removeListener("startup-mode", handleStartupMode);
    };
  }, [isElectron]);

  // Modify the existing useEffect for loading initial data
  useEffect(() => {
    if (!isElectron || !selectedFolder || isSafeMode) return;
    
    // Use a flag in sessionStorage to ensure we only load data once per session
    const hasLoadedInitialData = sessionStorage.getItem("hasLoadedInitialData");
    if (hasLoadedInitialData === "true") return;
    
    console.log("Loading saved folder on startup:", selectedFolder);
    setProcessingStatus({
      status: "processing",
      message: "Loading files from previously selected folder... (Press ESC to cancel)",
    });
    window.electron.ipcRenderer.send("request-file-list", selectedFolder);
    
    // Mark that we've loaded the initial data
    sessionStorage.setItem("hasLoadedInitialData", "true");
  }, [isElectron, selectedFolder, isSafeMode]);
  

  // Listen for folder selection from main process
  useEffect(() => {
    if (!isElectron) {
      console.warn("Not running in Electron environment");
      return;
    }

    const handleFolderSelected = (folderPath: string) => {
      // Check if folderPath is valid string
      if (typeof folderPath === "string") {
        console.log("Folder selected:", folderPath);
        setSelectedFolder(folderPath);
        // We'll select all files after they're loaded
        setSelectedFiles([]);
        setProcessingStatus({
          status: "processing",
          message: "Requesting file list...",
        });
        window.electron.ipcRenderer.send("request-file-list", folderPath);
      } else {
        console.error("Invalid folder path received:", folderPath);
        setProcessingStatus({
          status: "error",
          message: "Invalid folder path received",
        });
      }
    };

    const handleFileListData = (files: FileData[]) => {
      console.log("Received file list data:", files ? files.length : 0, "files");
      
      // Ensure we have a valid array of files
      if (!files || !Array.isArray(files)) {
        console.error("Invalid file list data received:", files);
        setProcessingStatus({
          status: "error",
          message: "Error: Received invalid file list data",
        });
        return;
      }
      
      // Log directory entries for debugging
      const directoryEntries = files.filter(file => file && file.isDirectory);
      console.log(`Directory entries in file list: ${directoryEntries.length}`);
      if (directoryEntries.length > 0) {
        directoryEntries.slice(0, 3).forEach(dir => {
          console.log(`Directory: ${dir.name}, path: ${dir.path}, isDirectory: ${dir.isDirectory}`);
        });
      }
      
      // Process files and ensure they have the correct structure
      setAllFiles(files);
      setProcessingStatus({
        status: "complete",
        message: `Loaded ${files.length} files`,
      });

      // Apply filters and sort to the new files
      applyFiltersAndSort(files, sortOrder, searchTerm);

      // Ensure the root folder is expanded by default if it exists
      const rootFolder = files.find(file => 
        file && file.path && file.isDirectory && 
        arePathsEqual(file.path, selectedFolder || '')
      );
      
      if (rootFolder) {
        console.log("Found root folder in file list:", rootFolder.name, rootFolder.path);
        setExpandedNodes((prev: Record<string, boolean>) => ({
          ...prev,
          [`node-${selectedFolder}`]: true
        }));
      } else {
        console.log("Root folder not found in file list, selected folder is:", selectedFolder);
      }

      // Try to restore saved selection from localStorage, filtering for files that still exist
      const savedFiles = localStorage.getItem(STORAGE_KEYS.SELECTED_FILES);
      let newSelectedFiles: string[] = [];
      
      if (savedFiles) {
        try {
          const parsedSavedFiles: string[] = JSON.parse(savedFiles);
          // Filter saved files to ensure they exist in the new file list and are selectable
          newSelectedFiles = parsedSavedFiles.filter((path: string) =>
            files.some((file: FileData) =>
              file && file.path && path && 
              file.path === path && 
              !file.isBinary && !file.isSkipped && 
              !file.excludedByDefault && !file.isDirectory
            )
          );
        } catch (error) {
          console.error("Error parsing saved selected files:", error);
        }
      }

      // If no valid saved selection, default to selecting all non-binary, non-skipped, non-excluded files
      if (newSelectedFiles.length === 0) {
        newSelectedFiles = files
          .filter(
            (file: FileData) =>
              file && file.path && 
              !file.isBinary && !file.isSkipped && 
              !file.excludedByDefault && !file.isDirectory
          )
          .map((file: FileData) => file.path);
      }

      setSelectedFiles(newSelectedFiles);
    };

    const handleProcessingStatus = (status: {
      status: "idle" | "processing" | "complete" | "error";
      message: string;
    }) => {
      console.log("Processing status:", status);
      setProcessingStatus(status);
    };

    window.electron.ipcRenderer.on("folder-selected", handleFolderSelected);
    window.electron.ipcRenderer.on("file-list-data", handleFileListData);
    window.electron.ipcRenderer.on(
      "file-processing-status",
      handleProcessingStatus,
    );

    return () => {
      window.electron.ipcRenderer.removeListener(
        "folder-selected",
        handleFolderSelected,
      );
      window.electron.ipcRenderer.removeListener(
        "file-list-data",
        handleFileListData,
      );
      window.electron.ipcRenderer.removeListener(
        "file-processing-status",
        handleProcessingStatus,
      );
    };
  }, [isElectron, sortOrder, searchTerm]);

  const openFolder = () => {
    if (isElectron) {
      console.log("Opening folder dialog");
      setProcessingStatus({ status: "idle", message: "Select a folder..." });
      window.electron.ipcRenderer.send("open-folder");
    } else {
      console.warn("Folder selection not available in browser");
    }
  };

  // Apply filters and sorting to files
  const applyFiltersAndSort = (
    files: FileData[],
    sort: string,
    filter: string,
  ) => {
    let filtered = files;

    // Apply filter
    if (filter) {
      const lowerFilter = filter.toLowerCase();
      filtered = files.filter(
        (file) =>
          file.name.toLowerCase().includes(lowerFilter) ||
          file.path.toLowerCase().includes(lowerFilter),
      );
    }

    // Apply sort
    const [sortKey, sortDir] = sort.split("-");
    const sorted = [...filtered].sort((a, b) => {
      let comparison = 0;

      if (sortKey === "name") {
        comparison = a.name.localeCompare(b.name);
      } else if (sortKey === "tokens") {
        comparison = a.tokenCount - b.tokenCount;
      } else if (sortKey === "size") {
        comparison = a.size - b.size;
      }

      return sortDir === "asc" ? comparison : -comparison;
    });

    setDisplayedFiles(sorted);
  };

  // Toggle file selection
  const toggleFileSelection = (filePath: string) => {
    // Normalize the incoming file path
    const normalizedPath = normalizePath(filePath);
    
    setSelectedFiles((prev: string[]) => {
      // Check if the file is already selected using case-sensitive/insensitive comparison as appropriate
      const isSelected = prev.some(path => arePathsEqual(path, normalizedPath));
      
      if (isSelected) {
        // Remove the file from selected files
        return prev.filter((path: string) => !arePathsEqual(path, normalizedPath));
      } else {
        // Add the file to selected files
        return [...prev, normalizedPath];
      }
    });
  };

  // Toggle folder selection (select/deselect all files in folder)
  const toggleFolderSelection = (folderPath: string, isSelected: boolean) => {
    console.log('toggleFolderSelection called with:', { folderPath, isSelected });
    
    // Normalize the folder path for cross-platform compatibility
    const normalizedFolderPath = normalizePath(folderPath);
    console.log('Normalized folder path:', normalizedFolderPath);
    
    // Function to check if a file is in the given folder or its subfolders
    const isFileInFolder = (filePath: string, folderPath: string): boolean => {
      const normalizedFilePath = normalizePath(filePath);
      
      // A file is in the folder if:
      // 1. The paths are equal (exact match)
      // 2. The file path is a subpath of the folder
      return arePathsEqual(normalizedFilePath, folderPath) || 
             isSubPath(folderPath, normalizedFilePath);
    };
    
    // Filter all files to get only those in this folder (and subfolders) that are selectable
    const filesInFolder = allFiles.filter((file: FileData) => {
      const inFolder = isFileInFolder(file.path, normalizedFolderPath);
      const selectable = !file.isBinary && !file.isSkipped && !file.excludedByDefault && !file.isDirectory;
      return selectable && inFolder;
    });
    
    console.log('Found', filesInFolder.length, 'selectable files in folder and subfolders');
    
    // If no selectable files were found, do nothing
    if (filesInFolder.length === 0) {
      console.log('No selectable files found in folder, nothing to do');
      return;
    }
    
    // Extract just the paths from the files and normalize them
    const folderFilePaths = filesInFolder.map((file: FileData) => normalizePath(file.path));
    console.log('File paths in folder:', folderFilePaths);
    
    if (isSelected) {
      // Adding files - create a new Set with all existing + new files
      setSelectedFiles((prev: string[]) => {
        const existingSelection = new Set(prev.map(normalizePath));
        folderFilePaths.forEach((path: string) => existingSelection.add(path));
        const newSelection = Array.from(existingSelection);
        console.log(`Added ${folderFilePaths.length} files to selection, total now: ${newSelection.length}`);
        return newSelection;
      });
    } else {
      // Removing files - filter out any file that's in our folder or subfolders
      setSelectedFiles((prev: string[]) => {
        const newSelection = prev.filter((path: string) => !isFileInFolder(path, normalizedFolderPath));
        console.log(`Removed ${prev.length - newSelection.length} files from selection, total now: ${newSelection.length}`);
        return newSelection;
      });
    }
  };

  // Handle sort change
  const handleSortChange = (newSort: string) => {
    setSortOrder(newSort);
    applyFiltersAndSort(allFiles, newSort, searchTerm);
    setSortDropdownOpen(false); // Close dropdown after selection
  };

  // Handle search change
  const handleSearchChange = (newSearch: string) => {
    setSearchTerm(newSearch);
    applyFiltersAndSort(allFiles, sortOrder, newSearch);
  };

  // Toggle sort dropdown
  const toggleSortDropdown = () => {
    setSortDropdownOpen(!sortDropdownOpen);
  };

  // Calculate total tokens from selected files
  const calculateTotalTokens = () => {
    return selectedFiles.reduce((total: number, path: string) => {
      const file = allFiles.find((f: FileData) => arePathsEqual(f.path, path));
      return total + (file ? file.tokenCount : 0);
    }, 0);
  };

  // NEW: State for user instructions
  const [userInstructions, setUserInstructions] = useState("");

  // Concatenate selected files content for copying,
  // and add user instructions (wrapped in tags) at the bottom if provided.
  const getSelectedFilesContent = () => {
    // Sort selected files according to current sort order
    const [sortKey, sortDir] = sortOrder.split("-");
    const sortedSelected = allFiles
      .filter((file: FileData) => 
        selectedFiles.some((selectedPath: string) => 
          arePathsEqual(selectedPath, file.path)
        )
      )
      .sort((a: FileData, b: FileData) => {
        let comparison = 0;
    
        if (sortKey === "name") {
          comparison = a.name.localeCompare(b.name);
        } else if (sortKey === "tokens") {
          comparison = a.tokenCount - b.tokenCount;
        } else if (sortKey === "size") {
          comparison = a.size - b.size;
        }
    
        return sortDir === "asc" ? comparison : -comparison;
      });
    
    if (sortedSelected.length === 0) {
      return "No files selected.";
    }
    
    // Wrap user instructions if any and add to the beginning
    const userInstructionsBlock = userInstructions.trim()
      ? `<user_instructions>\n${userInstructions}\n</user_instructions>\n\n`
      : "";
    
    let concatenatedString = userInstructionsBlock;
    
    // Add ASCII file tree if enabled
    if (includeFileTree && selectedFolder) {
      const asciiTree = generateAsciiFileTree(sortedSelected, selectedFolder);
      concatenatedString += `<file_map>\n${selectedFolder}\n${asciiTree}\n</file_map>\n\n`;
    }
    
    sortedSelected.forEach((file: FileData) => {
      concatenatedString += `\n\n// ---- File: ${file.name} ----\n\n`;
      concatenatedString += file.content;
    });
    
    return concatenatedString;
  };

  // Handle select all files
  const selectAllFiles = () => {
    const selectablePaths = displayedFiles
      .filter((file: FileData) => !file.isBinary && !file.isSkipped && !file.excludedByDefault && !file.isDirectory)
      .map((file: FileData) => file.path);

    setSelectedFiles((prev: string[]) => {
      const newSelection = [...prev];
      selectablePaths.forEach((path: string) => {
        if (!newSelection.includes(path)) {
          newSelection.push(path);
        }
      });
      return newSelection;
    });
  };

  // Handle deselect all files
  const deselectAllFiles = () => {
    const displayedPaths = displayedFiles.map((file: FileData) => file.path);
    setSelectedFiles((prev: string[]) =>
      prev.filter((path: string) => 
        !displayedPaths.some((displayedPath: string) => arePathsEqual(displayedPath, path))
      )
    );
  };

  // Sort options for the dropdown
  const sortOptions = [
    { value: "tokens-desc", label: "Tokens: High to Low" },
    { value: "tokens-asc", label: "Tokens: Low to High" },
    { value: "name-asc", label: "Name: A to Z" },
    { value: "name-desc", label: "Name: Z to A" },
  ];

  // Handle expand/collapse state changes
  const toggleExpanded = (nodeId: string) => {
    setExpandedNodes((prev: Record<string, boolean>) => {
      const newState = {
        ...prev,
        [nodeId]: prev[nodeId] === undefined ? false : !prev[nodeId],
      };

      // Save to localStorage
      localStorage.setItem(
        STORAGE_KEYS.EXPANDED_NODES,
        JSON.stringify(newState),
      );

      return newState;
    });
  };

  return (
    <ThemeProvider children={
      <div className="app-container">
        <header className="header">
          <h1>PasteMax</h1>
          <div className="header-actions">
            <ThemeToggle />
            <div className="folder-info">
              {selectedFolder ? (
                <div className="selected-folder">{selectedFolder}</div>
              ) : (
                <span>No folder selected</span>
              )}
              <button
                className="select-folder-btn"
                onClick={openFolder}
                disabled={processingStatus.status === "processing"}
              >
                Select Folder
              </button>
            </div>
          </div>
        </header>

        {processingStatus.status === "processing" && (
          <div className="processing-indicator">
            <div className="spinner"></div>
            <span>{processingStatus.message}</span>
            <button
              className="cancel-btn"
              onClick={cancelDirectoryLoading}
            >
              Cancel
            </button>
          </div>
        )}

        {processingStatus.status === "error" && (
          <div className="error-message">Error: {processingStatus.message}</div>
        )}

        {selectedFolder && (
          <div className="main-content">
            <Sidebar
              selectedFolder={selectedFolder}
              allFiles={allFiles}
              selectedFiles={selectedFiles}
              toggleFileSelection={toggleFileSelection}
              toggleFolderSelection={toggleFolderSelection}
              searchTerm={searchTerm}
              onSearchChange={handleSearchChange}
              selectAllFiles={selectAllFiles}
              deselectAllFiles={deselectAllFiles}
              expandedNodes={expandedNodes}
              toggleExpanded={toggleExpanded}
            />
            <div className="content-area">
              <div className="content-header">
                <div className="content-title">Selected Files</div>
                <div className="content-actions">
                  <div className="sort-dropdown">
                    <button
                      className="sort-dropdown-button"
                      onClick={toggleSortDropdown}
                    >
                      Sort:{" "}
                      {sortOptions.find((opt) => opt.value === sortOrder)
                        ?.label || sortOrder}
                    </button>
                    {sortDropdownOpen && (
                      <div className="sort-options">
                        {sortOptions.map((option) => (
                          <div
                            key={option.value}
                            className={`sort-option ${
                              sortOrder === option.value ? "active" : ""
                            }`}
                            onClick={() => handleSortChange(option.value)}
                          >
                            {option.label}
                          </div>
                        ))}
                      </div>
                    )}
                  </div>
                  <div className="file-stats">
                    {selectedFiles.length} files | ~
                    {calculateTotalTokens().toLocaleString()} tokens
                  </div>
                </div>
              </div>

              <FileList
                files={displayedFiles}
                selectedFiles={selectedFiles}
                toggleFileSelection={toggleFileSelection}
              />

              {/* Render the user instructions textbox */}
              <div className="user-instructions-container">
                <UserInstructions
                  instructions={userInstructions}
                  setInstructions={setUserInstructions}
                />
              </div>

              <div className="copy-button-container">
                <div style={{ display: "flex", flexDirection: "column", alignItems: "center", gap: "12px", width: "100%", maxWidth: "400px" }}>
                  <label style={{ display: "flex", alignItems: "center", gap: "8px", cursor: "pointer" }}>
                    <input
                      type="checkbox"
                      checked={includeFileTree}
                      onChange={() => setIncludeFileTree(!includeFileTree)}
                    />
                    <span>Include File Tree</span>
                  </label>
                  <CopyButton
                    text={getSelectedFilesContent()}
                    className="primary full-width"
                  >
                    <span>COPY ALL SELECTED ({selectedFiles.length} files)</span>
                  </CopyButton>
                </div>
              </div>
            </div>
          </div>
        )}
      </div>
    } />
  );
};

export default App;
</file>

</files>
